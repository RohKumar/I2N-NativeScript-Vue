webpackHotUpdate("vendor",{

/***/ "../node_modules/assert/assert.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) { // compare and isBuffer taken from https://github.com/feross/buffer/blob/680e9e5e488f22aac27599a57dc844a6315928dd/index.js
// original notice:

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

function compare(a, b) {
  if (a === b) {
    return 0;
  }

  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) {
    return -1;
  }

  if (y < x) {
    return 1;
  }

  return 0;
}

function isBuffer(b) {
  if (global.Buffer && typeof global.Buffer.isBuffer === 'function') {
    return global.Buffer.isBuffer(b);
  }

  return !!(b != null && b._isBuffer);
} // based on node assert, original notice:
// http://wiki.commonjs.org/wiki/Unit_Testing/1.0
//
// THIS IS NOT TESTED NOR LIKELY TO WORK OUTSIDE V8!
//
// Originally from narwhal.js (http://narwhaljs.org)
// Copyright (c) 2009 Thomas Robinson <280north.com>
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the 'Software'), to
// deal in the Software without restriction, including without limitation the
// rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
// sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
// ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.


var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

var hasOwn = Object.prototype.hasOwnProperty;
var pSlice = Array.prototype.slice;

var functionsHaveNames = function () {
  return function foo() {}.name === 'foo';
}();

function pToString(obj) {
  return Object.prototype.toString.call(obj);
}

function isView(arrbuf) {
  if (isBuffer(arrbuf)) {
    return false;
  }

  if (typeof global.ArrayBuffer !== 'function') {
    return false;
  }

  if (typeof ArrayBuffer.isView === 'function') {
    return ArrayBuffer.isView(arrbuf);
  }

  if (!arrbuf) {
    return false;
  }

  if (arrbuf instanceof DataView) {
    return true;
  }

  if (arrbuf.buffer && arrbuf.buffer instanceof ArrayBuffer) {
    return true;
  }

  return false;
} // 1. The assert module provides functions that throw
// AssertionError's when particular conditions are not met. The
// assert module must conform to the following interface.


var assert = module.exports = ok; // 2. The AssertionError is defined in assert.
// new assert.AssertionError({ message: message,
//                             actual: actual,
//                             expected: expected })

var regex = /\s*function\s+([^\(\s]*)\s*/; // based on https://github.com/ljharb/function.prototype.name/blob/adeeeec8bfcc6068b187d7d9fb3d5bb1d3a30899/implementation.js

function getName(func) {
  if (!util.isFunction(func)) {
    return;
  }

  if (functionsHaveNames) {
    return func.name;
  }

  var str = func.toString();
  var match = str.match(regex);
  return match && match[1];
}

assert.AssertionError = function AssertionError(options) {
  this.name = 'AssertionError';
  this.actual = options.actual;
  this.expected = options.expected;
  this.operator = options.operator;

  if (options.message) {
    this.message = options.message;
    this.generatedMessage = false;
  } else {
    this.message = getMessage(this);
    this.generatedMessage = true;
  }

  var stackStartFunction = options.stackStartFunction || fail;

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, stackStartFunction);
  } else {
    // non v8 browsers so we can have a stacktrace
    var err = new Error();

    if (err.stack) {
      var out = err.stack; // try to strip useless frames

      var fn_name = getName(stackStartFunction);
      var idx = out.indexOf('\n' + fn_name);

      if (idx >= 0) {
        // once we have located the function frame
        // we need to strip out everything before it (and its line)
        var next_line = out.indexOf('\n', idx + 1);
        out = out.substring(next_line + 1);
      }

      this.stack = out;
    }
  }
}; // assert.AssertionError instanceof Error


util.inherits(assert.AssertionError, Error);

function truncate(s, n) {
  if (typeof s === 'string') {
    return s.length < n ? s : s.slice(0, n);
  } else {
    return s;
  }
}

function inspect(something) {
  if (functionsHaveNames || !util.isFunction(something)) {
    return util.inspect(something);
  }

  var rawname = getName(something);
  var name = rawname ? ': ' + rawname : '';
  return '[Function' + name + ']';
}

function getMessage(self) {
  return truncate(inspect(self.actual), 128) + ' ' + self.operator + ' ' + truncate(inspect(self.expected), 128);
} // At present only the three keys mentioned above are used and
// understood by the spec. Implementations or sub modules can pass
// other keys to the AssertionError's constructor - they will be
// ignored.
// 3. All of the following functions must throw an AssertionError
// when a corresponding condition is not met, with a message that
// may be undefined if not provided.  All assertion methods provide
// both the actual and expected values to the assertion error for
// display purposes.


function fail(actual, expected, message, operator, stackStartFunction) {
  throw new assert.AssertionError({
    message: message,
    actual: actual,
    expected: expected,
    operator: operator,
    stackStartFunction: stackStartFunction
  });
} // EXTENSION! allows for well behaved errors defined elsewhere.


assert.fail = fail; // 4. Pure assertion tests whether a value is truthy, as determined
// by !!guard.
// assert.ok(guard, message_opt);
// This statement is equivalent to assert.equal(true, !!guard,
// message_opt);. To test strictly for the value true, use
// assert.strictEqual(true, guard, message_opt);.

function ok(value, message) {
  if (!value) fail(value, true, message, '==', assert.ok);
}

assert.ok = ok; // 5. The equality assertion tests shallow, coercive equality with
// ==.
// assert.equal(actual, expected, message_opt);

assert.equal = function equal(actual, expected, message) {
  if (actual != expected) fail(actual, expected, message, '==', assert.equal);
}; // 6. The non-equality assertion tests for whether two objects are not equal
// with != assert.notEqual(actual, expected, message_opt);


assert.notEqual = function notEqual(actual, expected, message) {
  if (actual == expected) {
    fail(actual, expected, message, '!=', assert.notEqual);
  }
}; // 7. The equivalence assertion tests a deep equality relation.
// assert.deepEqual(actual, expected, message_opt);


assert.deepEqual = function deepEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'deepEqual', assert.deepEqual);
  }
};

assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
  if (!_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'deepStrictEqual', assert.deepStrictEqual);
  }
};

function _deepEqual(actual, expected, strict, memos) {
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;
  } else if (isBuffer(actual) && isBuffer(expected)) {
    return compare(actual, expected) === 0; // 7.2. If the expected value is a Date object, the actual value is
    // equivalent if it is also a Date object that refers to the same time.
  } else if (util.isDate(actual) && util.isDate(expected)) {
    return actual.getTime() === expected.getTime(); // 7.3 If the expected value is a RegExp object, the actual value is
    // equivalent if it is also a RegExp object with the same source and
    // properties (`global`, `multiline`, `lastIndex`, `ignoreCase`).
  } else if (util.isRegExp(actual) && util.isRegExp(expected)) {
    return actual.source === expected.source && actual.global === expected.global && actual.multiline === expected.multiline && actual.lastIndex === expected.lastIndex && actual.ignoreCase === expected.ignoreCase; // 7.4. Other pairs that do not both pass typeof value == 'object',
    // equivalence is determined by ==.
  } else if ((actual === null || typeof actual !== 'object') && (expected === null || typeof expected !== 'object')) {
    return strict ? actual === expected : actual == expected; // If both values are instances of typed arrays, wrap their underlying
    // ArrayBuffers in a Buffer each to increase performance
    // This optimization requires the arrays to have the same type as checked by
    // Object.prototype.toString (aka pToString). Never perform binary
    // comparisons for Float*Arrays, though, since e.g. +0 === -0 but their
    // bit patterns are not identical.
  } else if (isView(actual) && isView(expected) && pToString(actual) === pToString(expected) && !(actual instanceof Float32Array || actual instanceof Float64Array)) {
    return compare(new Uint8Array(actual.buffer), new Uint8Array(expected.buffer)) === 0; // 7.5 For all other Object pairs, including Array objects, equivalence is
    // determined by having the same number of owned properties (as verified
    // with Object.prototype.hasOwnProperty.call), the same set of keys
    // (although not necessarily the same order), equivalent values for every
    // corresponding key, and an identical 'prototype' property. Note: this
    // accounts for both named and indexed properties on Arrays.
  } else if (isBuffer(actual) !== isBuffer(expected)) {
    return false;
  } else {
    memos = memos || {
      actual: [],
      expected: []
    };
    var actualIndex = memos.actual.indexOf(actual);

    if (actualIndex !== -1) {
      if (actualIndex === memos.expected.indexOf(expected)) {
        return true;
      }
    }

    memos.actual.push(actual);
    memos.expected.push(expected);
    return objEquiv(actual, expected, strict, memos);
  }
}

function isArguments(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
}

function objEquiv(a, b, strict, actualVisitedObjects) {
  if (a === null || a === undefined || b === null || b === undefined) return false; // if one is a primitive, the other must be same

  if (util.isPrimitive(a) || util.isPrimitive(b)) return a === b;
  if (strict && Object.getPrototypeOf(a) !== Object.getPrototypeOf(b)) return false;
  var aIsArgs = isArguments(a);
  var bIsArgs = isArguments(b);
  if (aIsArgs && !bIsArgs || !aIsArgs && bIsArgs) return false;

  if (aIsArgs) {
    a = pSlice.call(a);
    b = pSlice.call(b);
    return _deepEqual(a, b, strict);
  }

  var ka = objectKeys(a);
  var kb = objectKeys(b);
  var key, i; // having the same number of owned properties (keys incorporates
  // hasOwnProperty)

  if (ka.length !== kb.length) return false; //the same set of keys (although not necessarily the same order),

  ka.sort();
  kb.sort(); //~~~cheap key test

  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] !== kb[i]) return false;
  } //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test


  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!_deepEqual(a[key], b[key], strict, actualVisitedObjects)) return false;
  }

  return true;
} // 8. The non-equivalence assertion tests for any deep inequality.
// assert.notDeepEqual(actual, expected, message_opt);


assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, false)) {
    fail(actual, expected, message, 'notDeepEqual', assert.notDeepEqual);
  }
};

assert.notDeepStrictEqual = notDeepStrictEqual;

function notDeepStrictEqual(actual, expected, message) {
  if (_deepEqual(actual, expected, true)) {
    fail(actual, expected, message, 'notDeepStrictEqual', notDeepStrictEqual);
  }
} // 9. The strict equality assertion tests strict equality, as determined by ===.
// assert.strictEqual(actual, expected, message_opt);


assert.strictEqual = function strictEqual(actual, expected, message) {
  if (actual !== expected) {
    fail(actual, expected, message, '===', assert.strictEqual);
  }
}; // 10. The strict non-equality assertion tests for strict inequality, as
// determined by !==.  assert.notStrictEqual(actual, expected, message_opt);


assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
  if (actual === expected) {
    fail(actual, expected, message, '!==', assert.notStrictEqual);
  }
};

function expectedException(actual, expected) {
  if (!actual || !expected) {
    return false;
  }

  if (Object.prototype.toString.call(expected) == '[object RegExp]') {
    return expected.test(actual);
  }

  try {
    if (actual instanceof expected) {
      return true;
    }
  } catch (e) {// Ignore.  The instanceof check doesn't work for arrow functions.
  }

  if (Error.isPrototypeOf(expected)) {
    return false;
  }

  return expected.call({}, actual) === true;
}

function _tryBlock(block) {
  var error;

  try {
    block();
  } catch (e) {
    error = e;
  }

  return error;
}

function _throws(shouldThrow, block, expected, message) {
  var actual;

  if (typeof block !== 'function') {
    throw new TypeError('"block" argument must be a function');
  }

  if (typeof expected === 'string') {
    message = expected;
    expected = null;
  }

  actual = _tryBlock(block);
  message = (expected && expected.name ? ' (' + expected.name + ').' : '.') + (message ? ' ' + message : '.');

  if (shouldThrow && !actual) {
    fail(actual, expected, 'Missing expected exception' + message);
  }

  var userProvidedMessage = typeof message === 'string';
  var isUnwantedException = !shouldThrow && util.isError(actual);
  var isUnexpectedException = !shouldThrow && actual && !expected;

  if (isUnwantedException && userProvidedMessage && expectedException(actual, expected) || isUnexpectedException) {
    fail(actual, expected, 'Got unwanted exception' + message);
  }

  if (shouldThrow && actual && expected && !expectedException(actual, expected) || !shouldThrow && actual) {
    throw actual;
  }
} // 11. Expected to throw an error:
// assert.throws(block, Error_opt, message_opt);


assert.throws = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(true, block, error, message);
}; // EXTENSION! This is annoying to write outside this module.


assert.doesNotThrow = function (block,
/*optional*/
error,
/*optional*/
message) {
  _throws(false, block, error, message);
};

assert.ifError = function (err) {
  if (err) throw err;
};

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    if (hasOwn.call(obj, key)) keys.push(key);
  }

  return keys;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/axios/index.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/axios/lib/axios.js");

/***/ }),

/***/ "../node_modules/axios/lib/adapters/http.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {

var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var settle = __webpack_require__("../node_modules/axios/lib/core/settle.js");

var buildFullPath = __webpack_require__("../node_modules/axios/lib/core/buildFullPath.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var http = __webpack_require__("../node_modules/@nativescript/core/http/http.js");

var https = __webpack_require__("../node_modules/https-browserify/index.js");

var httpFollow = __webpack_require__("../node_modules/follow-redirects/index.js").http;

var httpsFollow = __webpack_require__("../node_modules/follow-redirects/index.js").https;

var url = __webpack_require__("../node_modules/url/url.js");

var zlib = __webpack_require__("../node_modules/browserify-zlib/lib/index.js");

var pkg = __webpack_require__("../node_modules/axios/package.json");

var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");

var enhanceError = __webpack_require__("../node_modules/axios/lib/core/enhanceError.js");

var isHttps = /https:?/;
/*eslint consistent-return:0*/

module.exports = function httpAdapter(config) {
  return new Promise(function dispatchHttpRequest(resolvePromise, rejectPromise) {
    var resolve = function resolve(value) {
      resolvePromise(value);
    };

    var reject = function reject(value) {
      rejectPromise(value);
    };

    var data = config.data;
    var headers = config.headers; // Set User-Agent (required by some servers)
    // Only set header if it hasn't been set in config
    // See https://github.com/axios/axios/issues/69

    if (!headers['User-Agent'] && !headers['user-agent']) {
      headers['User-Agent'] = 'axios/' + pkg.version;
    }

    if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {// Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(createError('Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream', config));
      } // Add Content-Length header if data exists


      headers['Content-Length'] = data.length;
    } // HTTP basic authentication


    var auth = undefined;

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      auth = username + ':' + password;
    } // Parse url


    var fullPath = buildFullPath(config.baseURL, config.url);
    var parsed = url.parse(fullPath);
    var protocol = parsed.protocol || 'http:';

    if (!auth && parsed.auth) {
      var urlAuth = parsed.auth.split(':');
      var urlUsername = urlAuth[0] || '';
      var urlPassword = urlAuth[1] || '';
      auth = urlUsername + ':' + urlPassword;
    }

    if (auth) {
      delete headers.Authorization;
    }

    var isHttpsRequest = isHttps.test(protocol);
    var agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    var options = {
      path: buildURL(parsed.path, config.params, config.paramsSerializer).replace(/^\?/, ''),
      method: config.method.toUpperCase(),
      headers: headers,
      agent: agent,
      agents: {
        http: config.httpAgent,
        https: config.httpsAgent
      },
      auth: auth
    };

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname;
      options.port = parsed.port;
    }

    var proxy = config.proxy;

    if (!proxy && proxy !== false) {
      var proxyEnv = protocol.slice(0, -1) + '_proxy';
      var proxyUrl = global.process.env[proxyEnv] || global.process.env[proxyEnv.toUpperCase()];

      if (proxyUrl) {
        var parsedProxyUrl = url.parse(proxyUrl);
        var noProxyEnv = global.process.env.no_proxy || global.process.env.NO_PROXY;
        var shouldProxy = true;

        if (noProxyEnv) {
          var noProxy = noProxyEnv.split(',').map(function trim(s) {
            return s.trim();
          });
          shouldProxy = !noProxy.some(function proxyMatch(proxyElement) {
            if (!proxyElement) {
              return false;
            }

            if (proxyElement === '*') {
              return true;
            }

            if (proxyElement[0] === '.' && parsed.hostname.substr(parsed.hostname.length - proxyElement.length) === proxyElement) {
              return true;
            }

            return parsed.hostname === proxyElement;
          });
        }

        if (shouldProxy) {
          proxy = {
            host: parsedProxyUrl.hostname,
            port: parsedProxyUrl.port
          };

          if (parsedProxyUrl.auth) {
            var proxyUrlAuth = parsedProxyUrl.auth.split(':');
            proxy.auth = {
              username: proxyUrlAuth[0],
              password: proxyUrlAuth[1]
            };
          }
        }
      }
    }

    if (proxy) {
      options.hostname = proxy.host;
      options.host = proxy.host;
      options.headers.host = parsed.hostname + (parsed.port ? ':' + parsed.port : '');
      options.port = proxy.port;
      options.path = protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path; // Basic proxy authorization

      if (proxy.auth) {
        var base64 = Buffer.from(proxy.auth.username + ':' + proxy.auth.password, 'utf8').toString('base64');
        options.headers['Proxy-Authorization'] = 'Basic ' + base64;
      }
    }

    var transport;
    var isHttpsProxy = isHttpsRequest && (proxy ? isHttps.test(proxy.protocol) : true);

    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsProxy ? https : http;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }

      transport = isHttpsProxy ? httpsFollow : httpFollow;
    }

    if (config.maxContentLength && config.maxContentLength > -1) {
      options.maxBodyLength = config.maxContentLength;
    } // Create the request


    var req = transport.request(options, function handleResponse(res) {
      if (req.aborted) return; // uncompress the response body transparently if required

      var stream = res;

      switch (res.headers['content-encoding']) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'compress':
        case 'deflate':
          // add the unzipper to the body stream processing pipeline
          stream = res.statusCode === 204 ? stream : stream.pipe(zlib.createUnzip()); // remove the content-encoding in order to not confuse downstream operations

          delete res.headers['content-encoding'];
          break;
      } // return the last request in case of redirects


      var lastRequest = res.req || req;
      var response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: res.headers,
        config: config,
        request: lastRequest
      };

      if (config.responseType === 'stream') {
        response.data = stream;
        settle(resolve, reject, response);
      } else {
        var responseBuffer = [];
        stream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk); // make sure the content length is not over the maxContentLength if specified

          if (config.maxContentLength > -1 && Buffer.concat(responseBuffer).length > config.maxContentLength) {
            stream.destroy();
            reject(createError('maxContentLength size of ' + config.maxContentLength + ' exceeded', config, null, lastRequest));
          }
        });
        stream.on('error', function handleStreamError(err) {
          if (req.aborted) return;
          reject(enhanceError(err, config, null, lastRequest));
        });
        stream.on('end', function handleStreamEnd() {
          var responseData = Buffer.concat(responseBuffer);

          if (config.responseType !== 'arraybuffer') {
            responseData = responseData.toString(config.responseEncoding);
          }

          response.data = responseData;
          settle(resolve, reject, response);
        });
      }
    }); // Handle errors

    req.on('error', function handleRequestError(err) {
      if (req.aborted) return;
      reject(enhanceError(err, config, null, req));
    }); // Handle request timeout

    if (config.timeout) {
      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devoring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(config.timeout, function handleRequestTimeout() {
        req.abort();
        reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', req));
      });
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (req.aborted) return;
        req.abort();
        reject(cancel);
      });
    } // Send the request


    if (utils.isStream(data)) {
      data.on('error', function handleStreamError(err) {
        reject(enhanceError(err, config, null, req));
      }).pipe(req);
    } else {
      req.end(data);
    }
  });
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/axios/lib/adapters/xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var settle = __webpack_require__("../node_modules/axios/lib/core/settle.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var buildFullPath = __webpack_require__("../node_modules/axios/lib/core/buildFullPath.js");

var parseHeaders = __webpack_require__("../node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__("../node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout; // Listen for ready state

    request.onreadystatechange = function handleLoad() {
      if (!request || request.readyState !== 4) {
        return;
      } // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request


      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }; // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__("../node_modules/axios/lib/helpers/cookies.js"); // Add xsrf header


      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var bind = __webpack_require__("../node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__("../node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__("../node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__("../node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__("../node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__("../node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__("../node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__("../node_modules/axios/lib/helpers/spread.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports.default = axios;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/Cancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/CancelToken.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__("../node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "../node_modules/axios/lib/cancel/isCancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "../node_modules/axios/lib/core/Axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__("../node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__("../node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__("../node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__("../node_modules/axios/lib/core/mergeConfig.js");
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */


function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  } // Hook up interceptors middleware


  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "../node_modules/axios/lib/core/InterceptorManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "../node_modules/axios/lib/core/buildFullPath.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isAbsoluteURL = __webpack_require__("../node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__("../node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ "../node_modules/axios/lib/core/createError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__("../node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "../node_modules/axios/lib/core/dispatchRequest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var transformData = __webpack_require__("../node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__("../node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__("../node_modules/axios/lib/defaults.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData(response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/core/enhanceError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function () {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "../node_modules/axios/lib/core/mergeConfig.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'params', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy'];
  var defaultToConfig2Keys = ['baseURL', 'url', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'maxContentLength', 'validateStatus', 'maxRedirects', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath'];
  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, function mergeDeepProperties(prop) {
    if (utils.isObject(config2[prop])) {
      config[prop] = utils.deepMerge(config1[prop], config2[prop]);
    } else if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (utils.isObject(config1[prop])) {
      config[prop] = utils.deepMerge(config1[prop]);
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys);
  var otherKeys = Object.keys(config2).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, function otherKeysDefaultToConfig2(prop) {
    if (typeof config2[prop] !== 'undefined') {
      config[prop] = config2[prop];
    } else if (typeof config1[prop] !== 'undefined') {
      config[prop] = config1[prop];
    }
  });
  return config;
};

/***/ }),

/***/ "../node_modules/axios/lib/core/settle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__("../node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "../node_modules/axios/lib/core/transformData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });
  return data;
};

/***/ }),

/***/ "../node_modules/axios/lib/defaults.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__("../node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__("../node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof global.process !== 'undefined' && Object.prototype.toString.call(global.process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__("../node_modules/axios/lib/adapters/http.js");
  }

  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        /* Ignore */
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "../node_modules/axios/lib/helpers/bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/buildURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/combineURLs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/cookies.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isAbsoluteURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/isURLSameOrigin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "../node_modules/axios/lib/helpers/normalizeHeaderName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/parseHeaders.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("../node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "../node_modules/axios/lib/helpers/spread.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "../node_modules/axios/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var bind = __webpack_require__("../node_modules/axios/lib/helpers/bind.js");
/*global toString:true*/
// utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && typeof val === 'object';
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function merge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Function equal to merge with the difference being that no reference
 * to original objects is kept.
 *
 * @see merge
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function deepMerge()
/* obj1, obj2, obj3, ... */
{
  var result = {};

  function assignValue(val, key) {
    if (typeof result[key] === 'object' && typeof val === 'object') {
      result[key] = deepMerge(result[key], val);
    } else if (typeof val === 'object') {
      result[key] = deepMerge({}, val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  deepMerge: deepMerge,
  extend: extend,
  trim: trim
};

/***/ }),

/***/ "../node_modules/axios/package.json":
/***/ (function(module) {

module.exports = JSON.parse("{\"_from\":\"axios\",\"_id\":\"axios@0.19.2\",\"_inBundle\":false,\"_integrity\":\"sha512-fjgm5MvRHLhx+osE2xoekY70AhARk3a6hkN+3Io1jc00jtquGvxYlKlsFUhmUET0V5te6CcZI7lcv2Ym61mjHA==\",\"_location\":\"/axios\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"tag\",\"registry\":true,\"raw\":\"axios\",\"name\":\"axios\",\"escapedName\":\"axios\",\"rawSpec\":\"\",\"saveSpec\":null,\"fetchSpec\":\"latest\"},\"_requiredBy\":[\"#USER\",\"/\"],\"_resolved\":\"https://registry.npmjs.org/axios/-/axios-0.19.2.tgz\",\"_shasum\":\"3ea36c5d8818d0d5f8a8a97a6d36b86cdc00cb27\",\"_spec\":\"axios\",\"_where\":\"D:\\\\Learning projects\\\\VueNewProj\",\"author\":{\"name\":\"Matt Zabriskie\"},\"browser\":{\"./lib/adapters/http.js\":\"./lib/adapters/xhr.js\"},\"bugs\":{\"url\":\"https://github.com/axios/axios/issues\"},\"bundleDependencies\":false,\"bundlesize\":[{\"path\":\"./dist/axios.min.js\",\"threshold\":\"5kB\"}],\"dependencies\":{\"follow-redirects\":\"1.5.10\"},\"deprecated\":false,\"description\":\"Promise based HTTP client for the browser and node.js\",\"devDependencies\":{\"bundlesize\":\"^0.17.0\",\"coveralls\":\"^3.0.0\",\"es6-promise\":\"^4.2.4\",\"grunt\":\"^1.0.2\",\"grunt-banner\":\"^0.6.0\",\"grunt-cli\":\"^1.2.0\",\"grunt-contrib-clean\":\"^1.1.0\",\"grunt-contrib-watch\":\"^1.0.0\",\"grunt-eslint\":\"^20.1.0\",\"grunt-karma\":\"^2.0.0\",\"grunt-mocha-test\":\"^0.13.3\",\"grunt-ts\":\"^6.0.0-beta.19\",\"grunt-webpack\":\"^1.0.18\",\"istanbul-instrumenter-loader\":\"^1.0.0\",\"jasmine-core\":\"^2.4.1\",\"karma\":\"^1.3.0\",\"karma-chrome-launcher\":\"^2.2.0\",\"karma-coverage\":\"^1.1.1\",\"karma-firefox-launcher\":\"^1.1.0\",\"karma-jasmine\":\"^1.1.1\",\"karma-jasmine-ajax\":\"^0.1.13\",\"karma-opera-launcher\":\"^1.0.0\",\"karma-safari-launcher\":\"^1.0.0\",\"karma-sauce-launcher\":\"^1.2.0\",\"karma-sinon\":\"^1.0.5\",\"karma-sourcemap-loader\":\"^0.3.7\",\"karma-webpack\":\"^1.7.0\",\"load-grunt-tasks\":\"^3.5.2\",\"minimist\":\"^1.2.0\",\"mocha\":\"^5.2.0\",\"sinon\":\"^4.5.0\",\"typescript\":\"^2.8.1\",\"url-search-params\":\"^0.10.0\",\"webpack\":\"^1.13.1\",\"webpack-dev-server\":\"^1.14.1\"},\"homepage\":\"https://github.com/axios/axios\",\"keywords\":[\"xhr\",\"http\",\"ajax\",\"promise\",\"node\"],\"license\":\"MIT\",\"main\":\"index.js\",\"name\":\"axios\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/axios/axios.git\"},\"scripts\":{\"build\":\"NODE_ENV=production grunt build\",\"coveralls\":\"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js\",\"examples\":\"node ./examples/server.js\",\"fix\":\"eslint --fix lib/**/*.js\",\"postversion\":\"git push && git push --tags\",\"preversion\":\"npm test\",\"start\":\"node ./sandbox/server.js\",\"test\":\"grunt test && bundlesize\",\"version\":\"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json\"},\"typings\":\"./index.d.ts\",\"version\":\"0.19.2\"}");

/***/ }),

/***/ "../node_modules/base64-js/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "../node_modules/browserify-zlib/lib/binding.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/* eslint camelcase: "off" */

var assert = __webpack_require__("../node_modules/assert/assert.js");

var Zstream = __webpack_require__("../node_modules/pako/lib/zlib/zstream.js");

var zlib_deflate = __webpack_require__("../node_modules/pako/lib/zlib/deflate.js");

var zlib_inflate = __webpack_require__("../node_modules/pako/lib/zlib/inflate.js");

var constants = __webpack_require__("../node_modules/pako/lib/zlib/constants.js");

for (var key in constants) {
  exports[key] = constants[key];
} // zlib modes


exports.NONE = 0;
exports.DEFLATE = 1;
exports.INFLATE = 2;
exports.GZIP = 3;
exports.GUNZIP = 4;
exports.DEFLATERAW = 5;
exports.INFLATERAW = 6;
exports.UNZIP = 7;
var GZIP_HEADER_ID1 = 0x1f;
var GZIP_HEADER_ID2 = 0x8b;
/**
 * Emulate Node's zlib C++ layer for use by the JS layer in index.js
 */

function Zlib(mode) {
  if (typeof mode !== 'number' || mode < exports.DEFLATE || mode > exports.UNZIP) {
    throw new TypeError('Bad argument');
  }

  this.dictionary = null;
  this.err = 0;
  this.flush = 0;
  this.init_done = false;
  this.level = 0;
  this.memLevel = 0;
  this.mode = mode;
  this.strategy = 0;
  this.windowBits = 0;
  this.write_in_progress = false;
  this.pending_close = false;
  this.gzip_id_bytes_read = 0;
}

Zlib.prototype.close = function () {
  if (this.write_in_progress) {
    this.pending_close = true;
    return;
  }

  this.pending_close = false;
  assert(this.init_done, 'close before init');
  assert(this.mode <= exports.UNZIP);

  if (this.mode === exports.DEFLATE || this.mode === exports.GZIP || this.mode === exports.DEFLATERAW) {
    zlib_deflate.deflateEnd(this.strm);
  } else if (this.mode === exports.INFLATE || this.mode === exports.GUNZIP || this.mode === exports.INFLATERAW || this.mode === exports.UNZIP) {
    zlib_inflate.inflateEnd(this.strm);
  }

  this.mode = exports.NONE;
  this.dictionary = null;
};

Zlib.prototype.write = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(true, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype.writeSync = function (flush, input, in_off, in_len, out, out_off, out_len) {
  return this._write(false, flush, input, in_off, in_len, out, out_off, out_len);
};

Zlib.prototype._write = function (async, flush, input, in_off, in_len, out, out_off, out_len) {
  assert.equal(arguments.length, 8);
  assert(this.init_done, 'write before init');
  assert(this.mode !== exports.NONE, 'already finalized');
  assert.equal(false, this.write_in_progress, 'write already in progress');
  assert.equal(false, this.pending_close, 'close is pending');
  this.write_in_progress = true;
  assert.equal(false, flush === undefined, 'must provide flush value');
  this.write_in_progress = true;

  if (flush !== exports.Z_NO_FLUSH && flush !== exports.Z_PARTIAL_FLUSH && flush !== exports.Z_SYNC_FLUSH && flush !== exports.Z_FULL_FLUSH && flush !== exports.Z_FINISH && flush !== exports.Z_BLOCK) {
    throw new Error('Invalid flush value');
  }

  if (input == null) {
    input = Buffer.alloc(0);
    in_len = 0;
    in_off = 0;
  }

  this.strm.avail_in = in_len;
  this.strm.input = input;
  this.strm.next_in = in_off;
  this.strm.avail_out = out_len;
  this.strm.output = out;
  this.strm.next_out = out_off;
  this.flush = flush;

  if (!async) {
    // sync version
    this._process();

    if (this._checkError()) {
      return this._afterSync();
    }

    return;
  } // async version


  var self = this;
  global.process.nextTick(function () {
    self._process();

    self._after();
  });
  return this;
};

Zlib.prototype._afterSync = function () {
  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false;
  return [avail_in, avail_out];
};

Zlib.prototype._process = function () {
  var next_expected_header_byte = null; // If the avail_out is left at 0, then it means that it ran out
  // of room.  If there was avail_out left over, then it means
  // that all of the input was consumed.

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflate(this.strm, this.flush);
      break;

    case exports.UNZIP:
      if (this.strm.avail_in > 0) {
        next_expected_header_byte = this.strm.next_in;
      }

      switch (this.gzip_id_bytes_read) {
        case 0:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID1) {
            this.gzip_id_bytes_read = 1;
            next_expected_header_byte++;

            if (this.strm.avail_in === 1) {
              // The only available byte was already read.
              break;
            }
          } else {
            this.mode = exports.INFLATE;
            break;
          }

        // fallthrough

        case 1:
          if (next_expected_header_byte === null) {
            break;
          }

          if (this.strm.input[next_expected_header_byte] === GZIP_HEADER_ID2) {
            this.gzip_id_bytes_read = 2;
            this.mode = exports.GUNZIP;
          } else {
            // There is no actual difference between INFLATE and INFLATERAW
            // (after initialization).
            this.mode = exports.INFLATE;
          }

          break;

        default:
          throw new Error('invalid number of gzip magic number bytes read');
      }

    // fallthrough

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
      this.err = zlib_inflate.inflate(this.strm, this.flush // If data was encoded with dictionary
      );

      if (this.err === exports.Z_NEED_DICT && this.dictionary) {
        // Load it
        this.err = zlib_inflate.inflateSetDictionary(this.strm, this.dictionary);

        if (this.err === exports.Z_OK) {
          // And try to decode again
          this.err = zlib_inflate.inflate(this.strm, this.flush);
        } else if (this.err === exports.Z_DATA_ERROR) {
          // Both inflateSetDictionary() and inflate() return Z_DATA_ERROR.
          // Make it possible for After() to tell a bad dictionary from bad
          // input.
          this.err = exports.Z_NEED_DICT;
        }
      }

      while (this.strm.avail_in > 0 && this.mode === exports.GUNZIP && this.err === exports.Z_STREAM_END && this.strm.next_in[0] !== 0x00) {
        // Bytes remain in input buffer. Perhaps this is another compressed
        // member in the same archive, or just trailing garbage.
        // Trailing zero bytes are okay, though, since they are frequently
        // used for padding.
        this.reset();
        this.err = zlib_inflate.inflate(this.strm, this.flush);
      }

      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }
};

Zlib.prototype._checkError = function () {
  // Acceptable error states depend on the type of zlib stream.
  switch (this.err) {
    case exports.Z_OK:
    case exports.Z_BUF_ERROR:
      if (this.strm.avail_out !== 0 && this.flush === exports.Z_FINISH) {
        this._error('unexpected end of file');

        return false;
      }

      break;

    case exports.Z_STREAM_END:
      // normal statuses, not fatal
      break;

    case exports.Z_NEED_DICT:
      if (this.dictionary == null) {
        this._error('Missing dictionary');
      } else {
        this._error('Bad dictionary');
      }

      return false;

    default:
      // something else.
      this._error('Zlib error');

      return false;
  }

  return true;
};

Zlib.prototype._after = function () {
  if (!this._checkError()) {
    return;
  }

  var avail_out = this.strm.avail_out;
  var avail_in = this.strm.avail_in;
  this.write_in_progress = false; // call the write() cb

  this.callback(avail_in, avail_out);

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype._error = function (message) {
  if (this.strm.msg) {
    message = this.strm.msg;
  }

  this.onerror(message, this.err // no hope of rescue.
  );
  this.write_in_progress = false;

  if (this.pending_close) {
    this.close();
  }
};

Zlib.prototype.init = function (windowBits, level, memLevel, strategy, dictionary) {
  assert(arguments.length === 4 || arguments.length === 5, 'init(windowBits, level, memLevel, strategy, [dictionary])');
  assert(windowBits >= 8 && windowBits <= 15, 'invalid windowBits');
  assert(level >= -1 && level <= 9, 'invalid compression level');
  assert(memLevel >= 1 && memLevel <= 9, 'invalid memlevel');
  assert(strategy === exports.Z_FILTERED || strategy === exports.Z_HUFFMAN_ONLY || strategy === exports.Z_RLE || strategy === exports.Z_FIXED || strategy === exports.Z_DEFAULT_STRATEGY, 'invalid strategy');

  this._init(level, windowBits, memLevel, strategy, dictionary);

  this._setDictionary();
};

Zlib.prototype.params = function () {
  throw new Error('deflateParams Not supported');
};

Zlib.prototype.reset = function () {
  this._reset();

  this._setDictionary();
};

Zlib.prototype._init = function (level, windowBits, memLevel, strategy, dictionary) {
  this.level = level;
  this.windowBits = windowBits;
  this.memLevel = memLevel;
  this.strategy = strategy;
  this.flush = exports.Z_NO_FLUSH;
  this.err = exports.Z_OK;

  if (this.mode === exports.GZIP || this.mode === exports.GUNZIP) {
    this.windowBits += 16;
  }

  if (this.mode === exports.UNZIP) {
    this.windowBits += 32;
  }

  if (this.mode === exports.DEFLATERAW || this.mode === exports.INFLATERAW) {
    this.windowBits = -1 * this.windowBits;
  }

  this.strm = new Zstream();

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.GZIP:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateInit2(this.strm, this.level, exports.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
      break;

    case exports.INFLATE:
    case exports.GUNZIP:
    case exports.INFLATERAW:
    case exports.UNZIP:
      this.err = zlib_inflate.inflateInit2(this.strm, this.windowBits);
      break;

    default:
      throw new Error('Unknown mode ' + this.mode);
  }

  if (this.err !== exports.Z_OK) {
    this._error('Init error');
  }

  this.dictionary = dictionary;
  this.write_in_progress = false;
  this.init_done = true;
};

Zlib.prototype._setDictionary = function () {
  if (this.dictionary == null) {
    return;
  }

  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
      this.err = zlib_deflate.deflateSetDictionary(this.strm, this.dictionary);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to set dictionary');
  }
};

Zlib.prototype._reset = function () {
  this.err = exports.Z_OK;

  switch (this.mode) {
    case exports.DEFLATE:
    case exports.DEFLATERAW:
    case exports.GZIP:
      this.err = zlib_deflate.deflateReset(this.strm);
      break;

    case exports.INFLATE:
    case exports.INFLATERAW:
    case exports.GUNZIP:
      this.err = zlib_inflate.inflateReset(this.strm);
      break;

    default:
      break;
  }

  if (this.err !== exports.Z_OK) {
    this._error('Failed to reset stream');
  }
};

exports.Zlib = Zlib;
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/browserify-zlib/lib/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__("../node_modules/buffer/index.js").Buffer;

var Transform = __webpack_require__("../node_modules/stream-browserify/index.js").Transform;

var binding = __webpack_require__("../node_modules/browserify-zlib/lib/binding.js");

var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

var assert = __webpack_require__("../node_modules/assert/assert.js").ok;

var kMaxLength = __webpack_require__("../node_modules/buffer/index.js").kMaxLength;

var kRangeErrorMessage = 'Cannot create final Buffer. It would be larger ' + 'than 0x' + kMaxLength.toString(16) + ' bytes'; // zlib doesn't provide these, so kludge them in following the same
// const naming scheme zlib uses.

binding.Z_MIN_WINDOWBITS = 8;
binding.Z_MAX_WINDOWBITS = 15;
binding.Z_DEFAULT_WINDOWBITS = 15; // fewer than 64 bytes per chunk is stupid.
// technically it could work with as few as 8, but even 64 bytes
// is absurdly low.  Usually a MB or more is best.

binding.Z_MIN_CHUNK = 64;
binding.Z_MAX_CHUNK = Infinity;
binding.Z_DEFAULT_CHUNK = 16 * 1024;
binding.Z_MIN_MEMLEVEL = 1;
binding.Z_MAX_MEMLEVEL = 9;
binding.Z_DEFAULT_MEMLEVEL = 8;
binding.Z_MIN_LEVEL = -1;
binding.Z_MAX_LEVEL = 9;
binding.Z_DEFAULT_LEVEL = binding.Z_DEFAULT_COMPRESSION; // expose all the zlib constants

var bkeys = Object.keys(binding);

for (var bk = 0; bk < bkeys.length; bk++) {
  var bkey = bkeys[bk];

  if (bkey.match(/^Z/)) {
    Object.defineProperty(exports, bkey, {
      enumerable: true,
      value: binding[bkey],
      writable: false
    });
  }
} // translation table for return codes.


var codes = {
  Z_OK: binding.Z_OK,
  Z_STREAM_END: binding.Z_STREAM_END,
  Z_NEED_DICT: binding.Z_NEED_DICT,
  Z_ERRNO: binding.Z_ERRNO,
  Z_STREAM_ERROR: binding.Z_STREAM_ERROR,
  Z_DATA_ERROR: binding.Z_DATA_ERROR,
  Z_MEM_ERROR: binding.Z_MEM_ERROR,
  Z_BUF_ERROR: binding.Z_BUF_ERROR,
  Z_VERSION_ERROR: binding.Z_VERSION_ERROR
};
var ckeys = Object.keys(codes);

for (var ck = 0; ck < ckeys.length; ck++) {
  var ckey = ckeys[ck];
  codes[codes[ckey]] = ckey;
}

Object.defineProperty(exports, 'codes', {
  enumerable: true,
  value: Object.freeze(codes),
  writable: false
});
exports.Deflate = Deflate;
exports.Inflate = Inflate;
exports.Gzip = Gzip;
exports.Gunzip = Gunzip;
exports.DeflateRaw = DeflateRaw;
exports.InflateRaw = InflateRaw;
exports.Unzip = Unzip;

exports.createDeflate = function (o) {
  return new Deflate(o);
};

exports.createInflate = function (o) {
  return new Inflate(o);
};

exports.createDeflateRaw = function (o) {
  return new DeflateRaw(o);
};

exports.createInflateRaw = function (o) {
  return new InflateRaw(o);
};

exports.createGzip = function (o) {
  return new Gzip(o);
};

exports.createGunzip = function (o) {
  return new Gunzip(o);
};

exports.createUnzip = function (o) {
  return new Unzip(o);
}; // Convenience methods.
// compress/decompress a string or buffer in one step.


exports.deflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Deflate(opts), buffer, callback);
};

exports.deflateSync = function (buffer, opts) {
  return zlibBufferSync(new Deflate(opts), buffer);
};

exports.gzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gzip(opts), buffer, callback);
};

exports.gzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gzip(opts), buffer);
};

exports.deflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new DeflateRaw(opts), buffer, callback);
};

exports.deflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new DeflateRaw(opts), buffer);
};

exports.unzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Unzip(opts), buffer, callback);
};

exports.unzipSync = function (buffer, opts) {
  return zlibBufferSync(new Unzip(opts), buffer);
};

exports.inflate = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Inflate(opts), buffer, callback);
};

exports.inflateSync = function (buffer, opts) {
  return zlibBufferSync(new Inflate(opts), buffer);
};

exports.gunzip = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new Gunzip(opts), buffer, callback);
};

exports.gunzipSync = function (buffer, opts) {
  return zlibBufferSync(new Gunzip(opts), buffer);
};

exports.inflateRaw = function (buffer, opts, callback) {
  if (typeof opts === 'function') {
    callback = opts;
    opts = {};
  }

  return zlibBuffer(new InflateRaw(opts), buffer, callback);
};

exports.inflateRawSync = function (buffer, opts) {
  return zlibBufferSync(new InflateRaw(opts), buffer);
};

function zlibBuffer(engine, buffer, callback) {
  var buffers = [];
  var nread = 0;
  engine.on('error', onError);
  engine.on('end', onEnd);
  engine.end(buffer);
  flow();

  function flow() {
    var chunk;

    while (null !== (chunk = engine.read())) {
      buffers.push(chunk);
      nread += chunk.length;
    }

    engine.once('readable', flow);
  }

  function onError(err) {
    engine.removeListener('end', onEnd);
    engine.removeListener('readable', flow);
    callback(err);
  }

  function onEnd() {
    var buf;
    var err = null;

    if (nread >= kMaxLength) {
      err = new RangeError(kRangeErrorMessage);
    } else {
      buf = Buffer.concat(buffers, nread);
    }

    buffers = [];
    engine.close();
    callback(err, buf);
  }
}

function zlibBufferSync(engine, buffer) {
  if (typeof buffer === 'string') buffer = Buffer.from(buffer);
  if (!Buffer.isBuffer(buffer)) throw new TypeError('Not a string or buffer');
  var flushFlag = engine._finishFlushFlag;
  return engine._processChunk(buffer, flushFlag);
} // generic zlib
// minimal 2-byte header


function Deflate(opts) {
  if (!(this instanceof Deflate)) return new Deflate(opts);
  Zlib.call(this, opts, binding.DEFLATE);
}

function Inflate(opts) {
  if (!(this instanceof Inflate)) return new Inflate(opts);
  Zlib.call(this, opts, binding.INFLATE);
} // gzip - bigger header, same deflate compression


function Gzip(opts) {
  if (!(this instanceof Gzip)) return new Gzip(opts);
  Zlib.call(this, opts, binding.GZIP);
}

function Gunzip(opts) {
  if (!(this instanceof Gunzip)) return new Gunzip(opts);
  Zlib.call(this, opts, binding.GUNZIP);
} // raw - no header


function DeflateRaw(opts) {
  if (!(this instanceof DeflateRaw)) return new DeflateRaw(opts);
  Zlib.call(this, opts, binding.DEFLATERAW);
}

function InflateRaw(opts) {
  if (!(this instanceof InflateRaw)) return new InflateRaw(opts);
  Zlib.call(this, opts, binding.INFLATERAW);
} // auto-detect header.


function Unzip(opts) {
  if (!(this instanceof Unzip)) return new Unzip(opts);
  Zlib.call(this, opts, binding.UNZIP);
}

function isValidFlushFlag(flag) {
  return flag === binding.Z_NO_FLUSH || flag === binding.Z_PARTIAL_FLUSH || flag === binding.Z_SYNC_FLUSH || flag === binding.Z_FULL_FLUSH || flag === binding.Z_FINISH || flag === binding.Z_BLOCK;
} // the Zlib class they all inherit from
// This thing manages the queue of requests, and returns
// true or false if there is anything in the queue when
// you call the .write() method.


function Zlib(opts, mode) {
  var _this = this;

  this._opts = opts = opts || {};
  this._chunkSize = opts.chunkSize || exports.Z_DEFAULT_CHUNK;
  Transform.call(this, opts);

  if (opts.flush && !isValidFlushFlag(opts.flush)) {
    throw new Error('Invalid flush flag: ' + opts.flush);
  }

  if (opts.finishFlush && !isValidFlushFlag(opts.finishFlush)) {
    throw new Error('Invalid flush flag: ' + opts.finishFlush);
  }

  this._flushFlag = opts.flush || binding.Z_NO_FLUSH;
  this._finishFlushFlag = typeof opts.finishFlush !== 'undefined' ? opts.finishFlush : binding.Z_FINISH;

  if (opts.chunkSize) {
    if (opts.chunkSize < exports.Z_MIN_CHUNK || opts.chunkSize > exports.Z_MAX_CHUNK) {
      throw new Error('Invalid chunk size: ' + opts.chunkSize);
    }
  }

  if (opts.windowBits) {
    if (opts.windowBits < exports.Z_MIN_WINDOWBITS || opts.windowBits > exports.Z_MAX_WINDOWBITS) {
      throw new Error('Invalid windowBits: ' + opts.windowBits);
    }
  }

  if (opts.level) {
    if (opts.level < exports.Z_MIN_LEVEL || opts.level > exports.Z_MAX_LEVEL) {
      throw new Error('Invalid compression level: ' + opts.level);
    }
  }

  if (opts.memLevel) {
    if (opts.memLevel < exports.Z_MIN_MEMLEVEL || opts.memLevel > exports.Z_MAX_MEMLEVEL) {
      throw new Error('Invalid memLevel: ' + opts.memLevel);
    }
  }

  if (opts.strategy) {
    if (opts.strategy != exports.Z_FILTERED && opts.strategy != exports.Z_HUFFMAN_ONLY && opts.strategy != exports.Z_RLE && opts.strategy != exports.Z_FIXED && opts.strategy != exports.Z_DEFAULT_STRATEGY) {
      throw new Error('Invalid strategy: ' + opts.strategy);
    }
  }

  if (opts.dictionary) {
    if (!Buffer.isBuffer(opts.dictionary)) {
      throw new Error('Invalid dictionary: it should be a Buffer instance');
    }
  }

  this._handle = new binding.Zlib(mode);
  var self = this;
  this._hadError = false;

  this._handle.onerror = function (message, errno) {
    // there is no way to cleanly recover.
    // continuing only obscures problems.
    _close(self);

    self._hadError = true;
    var error = new Error(message);
    error.errno = errno;
    error.code = exports.codes[errno];
    self.emit('error', error);
  };

  var level = exports.Z_DEFAULT_COMPRESSION;
  if (typeof opts.level === 'number') level = opts.level;
  var strategy = exports.Z_DEFAULT_STRATEGY;
  if (typeof opts.strategy === 'number') strategy = opts.strategy;

  this._handle.init(opts.windowBits || exports.Z_DEFAULT_WINDOWBITS, level, opts.memLevel || exports.Z_DEFAULT_MEMLEVEL, strategy, opts.dictionary);

  this._buffer = Buffer.allocUnsafe(this._chunkSize);
  this._offset = 0;
  this._level = level;
  this._strategy = strategy;
  this.once('end', this.close);
  Object.defineProperty(this, '_closed', {
    get: function get() {
      return !_this._handle;
    },
    configurable: true,
    enumerable: true
  });
}

util.inherits(Zlib, Transform);

Zlib.prototype.params = function (level, strategy, callback) {
  if (level < exports.Z_MIN_LEVEL || level > exports.Z_MAX_LEVEL) {
    throw new RangeError('Invalid compression level: ' + level);
  }

  if (strategy != exports.Z_FILTERED && strategy != exports.Z_HUFFMAN_ONLY && strategy != exports.Z_RLE && strategy != exports.Z_FIXED && strategy != exports.Z_DEFAULT_STRATEGY) {
    throw new TypeError('Invalid strategy: ' + strategy);
  }

  if (this._level !== level || this._strategy !== strategy) {
    var self = this;
    this.flush(binding.Z_SYNC_FLUSH, function () {
      assert(self._handle, 'zlib binding closed');

      self._handle.params(level, strategy);

      if (!self._hadError) {
        self._level = level;
        self._strategy = strategy;
        if (callback) callback();
      }
    });
  } else {
    global.process.nextTick(callback);
  }
};

Zlib.prototype.reset = function () {
  assert(this._handle, 'zlib binding closed');
  return this._handle.reset();
}; // This is the _flush function called by the transform class,
// internally, when the last chunk has been written.


Zlib.prototype._flush = function (callback) {
  this._transform(Buffer.alloc(0), '', callback);
};

Zlib.prototype.flush = function (kind, callback) {
  var _this2 = this;

  var ws = this._writableState;

  if (typeof kind === 'function' || kind === undefined && !callback) {
    callback = kind;
    kind = binding.Z_FULL_FLUSH;
  }

  if (ws.ended) {
    if (callback) global.process.nextTick(callback);
  } else if (ws.ending) {
    if (callback) this.once('end', callback);
  } else if (ws.needDrain) {
    if (callback) {
      this.once('drain', function () {
        return _this2.flush(kind, callback);
      });
    }
  } else {
    this._flushFlag = kind;
    this.write(Buffer.alloc(0), '', callback);
  }
};

Zlib.prototype.close = function (callback) {
  _close(this, callback);

  global.process.nextTick(emitCloseNT, this);
};

function _close(engine, callback) {
  if (callback) global.process.nextTick(callback); // Caller may invoke .close after a zlib error (which will null _handle).

  if (!engine._handle) return;

  engine._handle.close();

  engine._handle = null;
}

function emitCloseNT(self) {
  self.emit('close');
}

Zlib.prototype._transform = function (chunk, encoding, cb) {
  var flushFlag;
  var ws = this._writableState;
  var ending = ws.ending || ws.ended;
  var last = ending && (!chunk || ws.length === chunk.length);
  if (chunk !== null && !Buffer.isBuffer(chunk)) return cb(new Error('invalid input'));
  if (!this._handle) return cb(new Error('zlib binding closed')); // If it's the last chunk, or a final flush, we use the Z_FINISH flush flag
  // (or whatever flag was provided using opts.finishFlush).
  // If it's explicitly flushing at some other time, then we use
  // Z_FULL_FLUSH. Otherwise, use Z_NO_FLUSH for maximum compression
  // goodness.

  if (last) flushFlag = this._finishFlushFlag;else {
    flushFlag = this._flushFlag; // once we've flushed the last of the queue, stop flushing and
    // go back to the normal behavior.

    if (chunk.length >= ws.length) {
      this._flushFlag = this._opts.flush || binding.Z_NO_FLUSH;
    }
  }

  this._processChunk(chunk, flushFlag, cb);
};

Zlib.prototype._processChunk = function (chunk, flushFlag, cb) {
  var availInBefore = chunk && chunk.length;
  var availOutBefore = this._chunkSize - this._offset;
  var inOff = 0;
  var self = this;
  var async = typeof cb === 'function';

  if (!async) {
    var buffers = [];
    var nread = 0;
    var error;
    this.on('error', function (er) {
      error = er;
    });
    assert(this._handle, 'zlib binding closed');

    do {
      var res = this._handle.writeSync(flushFlag, chunk, // in
      inOff, // in_off
      availInBefore, // in_len
      this._buffer, // out
      this._offset, //out_off
      availOutBefore); // out_len

    } while (!this._hadError && callback(res[0], res[1]));

    if (this._hadError) {
      throw error;
    }

    if (nread >= kMaxLength) {
      _close(this);

      throw new RangeError(kRangeErrorMessage);
    }

    var buf = Buffer.concat(buffers, nread);

    _close(this);

    return buf;
  }

  assert(this._handle, 'zlib binding closed');

  var req = this._handle.write(flushFlag, chunk, // in
  inOff, // in_off
  availInBefore, // in_len
  this._buffer, // out
  this._offset, //out_off
  availOutBefore); // out_len


  req.buffer = chunk;
  req.callback = callback;

  function callback(availInAfter, availOutAfter) {
    // When the callback is used in an async write, the callback's
    // context is the `req` object that was created. The req object
    // is === this._handle, and that's why it's important to null
    // out the values after they are done being used. `this._handle`
    // can stay in memory longer than the callback and buffer are needed.
    if (this) {
      this.buffer = null;
      this.callback = null;
    }

    if (self._hadError) return;
    var have = availOutBefore - availOutAfter;
    assert(have >= 0, 'have should not go down');

    if (have > 0) {
      var out = self._buffer.slice(self._offset, self._offset + have);

      self._offset += have; // serve some output to the consumer.

      if (async) {
        self.push(out);
      } else {
        buffers.push(out);
        nread += out.length;
      }
    } // exhausted the output buffer, or used all the input create a new one.


    if (availOutAfter === 0 || self._offset >= self._chunkSize) {
      availOutBefore = self._chunkSize;
      self._offset = 0;
      self._buffer = Buffer.allocUnsafe(self._chunkSize);
    }

    if (availOutAfter === 0) {
      // Not actually done.  Need to reprocess.
      // Also, update the availInBefore to the availInAfter value,
      // so that if we have to hit it a third (fourth, etc.) time,
      // it'll have the correct byte counts.
      inOff += availInBefore - availInAfter;
      availInBefore = availInAfter;
      if (!async) return true;

      var newReq = self._handle.write(flushFlag, chunk, inOff, availInBefore, self._buffer, self._offset, self._chunkSize);

      newReq.callback = callback; // this same function

      newReq.buffer = chunk;
      return;
    }

    if (!async) return false; // finished with the chunk.

    cb();
  }
};

util.inherits(Deflate, Zlib);
util.inherits(Inflate, Zlib);
util.inherits(Gzip, Zlib);
util.inherits(Gunzip, Zlib);
util.inherits(DeflateRaw, Zlib);
util.inherits(InflateRaw, Zlib);
util.inherits(Unzip, Zlib);

/***/ }),

/***/ "../node_modules/buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__("../node_modules/base64-js/index.js");

var ieee754 = __webpack_require__("../node_modules/ieee754/index.js");

var isArray = __webpack_require__("../node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/core-util-is/lib/util.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }

  return objectToString(arg) === '[object Array]';
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return objectToString(e) === '[object Error]' || e instanceof Error;
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/debug/src/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}
/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */


exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
/**
 * Colors.
 */

exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */


function log() {
  var _console; // This hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'


  return (typeof console === "undefined" ? "undefined" : _typeof(console)) === 'object' && console.log && (_console = console).log.apply(_console, arguments);
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {} // Swallow
  // XXX (@Qix-) should we be logging these?
  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof global.process !== 'undefined' && 'env' in global.process) {
    r = global.process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__("../node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "../node_modules/debug/src/common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__("../node_modules/ms/index.js");
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * Active `debug` instances.
  */

  createDebug.instances = [];
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;

    function debug() {
      // Disabled?
      if (!debug.enabled) {
        return;
      }

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return match;
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.enabled = createDebug.enabled(namespace);
    debug.useColors = createDebug.useColors();
    debug.color = selectColor(namespace);
    debug.destroy = destroy;
    debug.extend = extend; // Debug.formatArgs = formatArgs;
    // debug.rawLog = rawLog;
    // env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    createDebug.instances.push(debug);
    return debug;
  }

  function destroy() {
    var index = createDebug.instances.indexOf(this);

    if (index !== -1) {
      createDebug.instances.splice(index, 1);
      return true;
    }

    return false;
  }

  function extend(namespace, delimiter) {
    return createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }

    for (i = 0; i < createDebug.instances.length; i++) {
      var instance = createDebug.instances[i];
      instance.enabled = createDebug.enabled(instance.namespace);
    }
  }
  /**
  * Disable debug output.
  *
  * @api public
  */


  function disable() {
    createDebug.enable('');
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "../node_modules/debug/src/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof global.process === 'undefined' || global.process.type === 'renderer' || global.process.browser === true || global.process.__nwjs) {
  module.exports = __webpack_require__("../node_modules/debug/src/browser.js");
} else {
  module.exports = __webpack_require__("../node_modules/debug/src/node.js");
}

/***/ }),

/***/ "../node_modules/debug/src/node.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/**
 * Module dependencies.
 */

var tty = __webpack_require__("../node_modules/tty-browserify/index.js");

var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");
/**
 * This is the Node.js implementation of `debug()`.
 */


exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
  // Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
  // eslint-disable-next-line import/no-extraneous-dependencies
  var supportsColor = __webpack_require__("../node_modules/supports-color/index.js");

  if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
    exports.colors = [20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221];
  }
} catch (error) {} // Swallow - we only care if `supports-color` is available; it doesn't have to be.

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */


exports.inspectOpts = Object.keys(global.process.env).filter(function (key) {
  return /^debug_/i.test(key);
}).reduce(function (obj, key) {
  // Camel-case
  var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function (_, k) {
    return k.toUpperCase();
  }); // Coerce string value into JS value

  var val = global.process.env[key];

  if (/^(yes|on|true|enabled)$/i.test(val)) {
    val = true;
  } else if (/^(no|off|false|disabled)$/i.test(val)) {
    val = false;
  } else if (val === 'null') {
    val = null;
  } else {
    val = Number(val);
  }

  obj[prop] = val;
  return obj;
}, {});
/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
  return 'colors' in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(global.process.stderr.fd);
}
/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  var name = this.namespace,
      useColors = this.useColors;

  if (useColors) {
    var c = this.color;
    var colorCode = "\x1B[3" + (c < 8 ? c : '8;5;' + c);
    var prefix = "  ".concat(colorCode, ";1m").concat(name, " \x1B[0m");
    args[0] = prefix + args[0].split('\n').join('\n' + prefix);
    args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + "\x1B[0m");
  } else {
    args[0] = getDate() + name + ' ' + args[0];
  }
}

function getDate() {
  if (exports.inspectOpts.hideDate) {
    return '';
  }

  return new Date().toISOString() + ' ';
}
/**
 * Invokes `util.format()` with the specified arguments and writes to stderr.
 */


function log() {
  return global.process.stderr.write(util.format.apply(util, arguments) + '\n');
}
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  if (namespaces) {
    global.process.env.DEBUG = namespaces;
  } else {
    // If you set a process.env field to null or undefined, it gets cast to the
    // string 'null' or 'undefined'. Just delete instead.
    delete global.process.env.DEBUG;
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  return global.process.env.DEBUG;
}
/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */


function init(debug) {
  debug.inspectOpts = {};
  var keys = Object.keys(exports.inspectOpts);

  for (var i = 0; i < keys.length; i++) {
    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
  }
}

module.exports = __webpack_require__("../node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, ' ');
};
/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */


formatters.O = function (v) {
  this.inspectOpts.colors = this.useColors;
  return util.inspect(v, this.inspectOpts);
};

/***/ }),

/***/ "../node_modules/events/events.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var R = typeof Reflect === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;
Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = $getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  var args = [];

  for (var i = 0; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

/***/ }),

/***/ "../node_modules/follow-redirects/index.js":
/***/ (function(module, exports, __webpack_require__) {

var url = __webpack_require__("../node_modules/url/url.js");

var http = __webpack_require__("../node_modules/@nativescript/core/http/http.js");

var https = __webpack_require__("../node_modules/https-browserify/index.js");

var assert = __webpack_require__("../node_modules/assert/assert.js");

var Writable = __webpack_require__("../node_modules/stream-browserify/index.js").Writable;

var debug = __webpack_require__("../node_modules/debug/src/index.js")("follow-redirects"); // RFC7231§4.2.1: Of the request methods defined by this specification,
// the GET, HEAD, OPTIONS, and TRACE methods are defined to be safe.


var SAFE_METHODS = {
  GET: true,
  HEAD: true,
  OPTIONS: true,
  TRACE: true
}; // Create handlers that pass events from native requests

var eventHandlers = Object.create(null);
["abort", "aborted", "error", "socket", "timeout"].forEach(function (event) {
  eventHandlers[event] = function (arg) {
    this._redirectable.emit(event, arg);
  };
}); // An HTTP(S) request that can be redirected

function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  options.headers = options.headers || {};
  this._options = options;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = []; // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.

  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }

    delete options.host;
  } // Attach a callback if passed


  if (responseCallback) {
    this.on("response", responseCallback);
  } // React to responses of native requests


  var self = this;

  this._onNativeResponse = function (response) {
    self._processResponse(response);
  }; // Complete the URL object when necessary


  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");

    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  } // Perform the first request


  this._performRequest();
}

RedirectableRequest.prototype = Object.create(Writable.prototype); // Writes buffered data to the current native request

RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Validate input and shift parameters if necessary
  if (!(typeof data === "string" || typeof data === "object" && "length" in data)) {
    throw new Error("data should be a string, Buffer or Uint8Array");
  }

  if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  } // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066


  if (data.length === 0) {
    if (callback) {
      callback();
    }

    return;
  } // Only write when we don't exceed the maximum body length


  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;

    this._requestBodyBuffers.push({
      data: data,
      encoding: encoding
    });

    this._currentRequest.write(data, encoding, callback);
  } // Error when we exceed the maximum body length
  else {
      this.emit("error", new Error("Request body larger than maxBodyLength limit"));
      this.abort();
    }
}; // Ends the current native request


RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (typeof data === "function") {
    callback = data;
    data = encoding = null;
  } else if (typeof encoding === "function") {
    callback = encoding;
    encoding = null;
  } // Write data and end


  var currentRequest = this._currentRequest;
  this.write(data || "", encoding, function () {
    currentRequest.end(null, null, callback);
  });
}; // Sets a header value on the current native request


RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;

  this._currentRequest.setHeader(name, value);
}; // Clears a header value on the current native request


RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];

  this._currentRequest.removeHeader(name);
}; // Proxy all other public ClientRequest methods


["abort", "flushHeaders", "getHeader", "setNoDelay", "setSocketKeepAlive", "setTimeout"].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
}); // Proxy all public ClientRequest properties

["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function get() {
      return this._currentRequest[property];
    }
  });
}); // Executes the next native request (initial or redirect)

RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];

  if (!nativeProtocol) {
    this.emit("error", new Error("Unsupported protocol " + protocol));
    return;
  } // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)


  if (this._options.agents) {
    var scheme = protocol.substr(0, protocol.length - 1);
    this._options.agent = this._options.agents[scheme];
  } // Create the native request


  var request = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  this._currentUrl = url.format(this._options); // Set up event handlers

  request._redirectable = this;

  for (var event in eventHandlers) {
    /* istanbul ignore else */
    if (event) {
      request.on(event, eventHandlers[event]);
    }
  } // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)


  if (this._isRedirect) {
    // Write the request entity and end.
    var i = 0;
    var buffers = this._requestBodyBuffers;

    (function writeNext() {
      if (i < buffers.length) {
        var buffer = buffers[i++];
        request.write(buffer.data, buffer.encoding, writeNext);
      } else {
        request.end();
      }
    })();
  }
}; // Processes a response from the current native request


RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: response.statusCode
    });
  } // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.


  var location = response.headers.location;

  if (location && this._options.followRedirects !== false && response.statusCode >= 300 && response.statusCode < 400) {
    // RFC7231§6.4: A client SHOULD detect and intervene
    // in cyclical redirections (i.e., "infinite" redirection loops).
    if (++this._redirectCount > this._options.maxRedirects) {
      this.emit("error", new Error("Max redirects exceeded."));
      return;
    } // RFC7231§6.4: Automatic redirection needs to done with
    // care for methods not known to be safe […],
    // since the user might not wish to redirect an unsafe request.
    // RFC7231§6.4.7: The 307 (Temporary Redirect) status code indicates
    // that the target resource resides temporarily under a different URI
    // and the user agent MUST NOT change the request method
    // if it performs an automatic redirection to that URI.


    var header;
    var headers = this._options.headers;

    if (response.statusCode !== 307 && !(this._options.method in SAFE_METHODS)) {
      this._options.method = "GET"; // Drop a possible entity and headers related to it

      this._requestBodyBuffers = [];

      for (header in headers) {
        if (/^content-/i.test(header)) {
          delete headers[header];
        }
      }
    } // Drop the Host header, as the redirect might lead to a different host


    if (!this._isRedirect) {
      for (header in headers) {
        if (/^host$/i.test(header)) {
          delete headers[header];
        }
      }
    } // Perform the redirected request


    var redirectUrl = url.resolve(this._currentUrl, location);
    debug("redirecting to", redirectUrl);
    Object.assign(this._options, url.parse(redirectUrl));
    this._isRedirect = true;

    this._performRequest(); // Discard the remainder of the response to avoid waiting for data


    response.destroy();
  } else {
    // The response is not a redirect; return it as-is
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response); // Clean up

    this._requestBodyBuffers = [];
  }
}; // Wraps the key/value object of protocols with redirect functionality


function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  }; // Wrap each protocol

  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol); // Executes a request, following redirects

    wrappedProtocol.request = function (options, callback) {
      if (typeof options === "string") {
        options = url.parse(options);
        options.maxRedirects = exports.maxRedirects;
      } else {
        options = Object.assign({
          protocol: protocol,
          maxRedirects: exports.maxRedirects,
          maxBodyLength: exports.maxBodyLength
        }, options);
      }

      options.nativeProtocols = nativeProtocols;
      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }; // Executes a GET request, following redirects


    wrappedProtocol.get = function (options, callback) {
      var request = wrappedProtocol.request(options, callback);
      request.end();
      return request;
    };
  });
  return exports;
} // Exports


module.exports = wrap({
  http: http,
  https: https
});
module.exports.wrap = wrap;

/***/ }),

/***/ "../node_modules/has-flag/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = (flag, argv) => {
  argv = argv || global.process.argv;
  var prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
  var pos = argv.indexOf(prefix + flag);
  var terminatorPos = argv.indexOf('--');
  return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
};

/***/ }),

/***/ "../node_modules/https-browserify/index.js":
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__("../node_modules/@nativescript/core/http/http.js");

var url = __webpack_require__("../node_modules/url/url.js");

var https = module.exports;

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key];
}

https.request = function (params, cb) {
  params = validateParams(params);
  return http.request.call(this, params, cb);
};

https.get = function (params, cb) {
  params = validateParams(params);
  return http.get.call(this, params, cb);
};

function validateParams(params) {
  if (typeof params === 'string') {
    params = url.parse(params);
  }

  if (!params.protocol) {
    params.protocol = 'https:';
  }

  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"');
  }

  return params;
}

/***/ }),

/***/ "../node_modules/ieee754/index.js":
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "../node_modules/inherits/inherits.js":
/***/ (function(module, exports, __webpack_require__) {

try {
  var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");
  /* istanbul ignore next */


  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__("../node_modules/inherits/inherits_browser.js");
}

/***/ }),

/***/ "../node_modules/inherits/inherits_browser.js":
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "../node_modules/isarray/index.js":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "../node_modules/ms/index.js":
/***/ (function(module, exports) {

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/support/isBuffer.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {module.exports = function isBuffer(arg) {
  return arg instanceof Buffer;
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/node-libs-browser/node_modules/util/util.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors(obj) {
  var keys = Object.keys(obj);
  var descriptors = {};

  for (var i = 0; i < keys.length; i++) {
    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
  }

  return descriptors;
};

var formatRegExp = /%[sdj%]/g;

exports.format = function (f) {
  if (!isString(f)) {
    var objects = [];

    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }

    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function (x) {
    if (x === '%%') return '%';
    if (i >= len) return x;

    switch (x) {
      case '%s':
        return String(args[i++]);

      case '%d':
        return Number(args[i++]);

      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }

      default:
        return x;
    }
  });

  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }

  return str;
}; // Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.


exports.deprecate = function (fn, msg) {
  if (typeof global.process !== 'undefined' && global.process.noDeprecation === true) {
    return fn;
  } // Allow for deprecating things in the process of starting up.


  if (typeof global.process === 'undefined') {
    return function () {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (global.process.throwDeprecation) {
        throw new Error(msg);
      } else if (global.process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
};

var debugs = {};
var debugEnviron;

exports.debuglog = function (set) {
  if (isUndefined(debugEnviron)) debugEnviron = global.process.env.NODE_DEBUG || '';
  set = set.toUpperCase();

  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = global.process.pid;

      debugs[set] = function () {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function () {};
    }
  }

  return debugs[set];
};
/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */

/* legacy: obj, showHidden, depth, colors*/


function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  }; // legacy...

  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];

  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  } // set default options


  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}

exports.inspect = inspect; // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics

inspect.colors = {
  'bold': [1, 22],
  'italic': [3, 23],
  'underline': [4, 24],
  'inverse': [7, 27],
  'white': [37, 39],
  'grey': [90, 39],
  'black': [30, 39],
  'blue': [34, 39],
  'cyan': [36, 39],
  'green': [32, 39],
  'magenta': [35, 39],
  'red': [31, 39],
  'yellow': [33, 39]
}; // Don't use 'blue' not visible on cmd.exe

inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};

function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str + '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}

function stylizeNoColor(str, styleType) {
  return str;
}

function arrayToHash(array) {
  var hash = {};
  array.forEach(function (val, idx) {
    hash[val] = true;
  });
  return hash;
}

function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
  !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);

    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }

    return ret;
  } // Primitive types cannot have properties


  var primitive = formatPrimitive(ctx, value);

  if (primitive) {
    return primitive;
  } // Look up the keys of the object.


  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  } // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx


  if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  } // Some type of object without properties can be shortcutted.


  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }

    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }

    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }

    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '',
      array = false,
      braces = ['{', '}']; // Make Array say that they are Array

  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  } // Make functions say that they are functions


  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  } // Make RegExps say that they are RegExps


  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  } // Make dates with properties first say the date


  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  } // Make error with message first say the error


  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);
  var output;

  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function (key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();
  return reduceToSingleString(output, base, braces);
}

function formatPrimitive(ctx, value) {
  if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');

  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }

  if (isNumber(value)) return ctx.stylize('' + value, 'number');
  if (isBoolean(value)) return ctx.stylize('' + value, 'boolean'); // For some reason typeof null is "object", so special case here.

  if (isNull(value)) return ctx.stylize('null', 'null');
}

function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}

function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];

  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
    } else {
      output.push('');
    }
  }

  keys.forEach(function (key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
    }
  });
  return output;
}

function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || {
    value: value[key]
  };

  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }

  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }

  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }

      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function (line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function (line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }

  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }

    name = JSON.stringify('' + key);

    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}

function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function (prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
} // NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.


function isArray(ar) {
  return Array.isArray(ar);
}

exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}

exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}

exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}

exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}

exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}

exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}

exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}

exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}

exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}

exports.isDate = isDate;

function isError(e) {
  return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
}

exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}

exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null || typeof arg === 'boolean' || typeof arg === 'number' || typeof arg === 'string' || typeof arg === 'symbol' || // ES6 symbol
  typeof arg === 'undefined';
}

exports.isPrimitive = isPrimitive;
exports.isBuffer = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/support/isBuffer.js");

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}

var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']; // 26 Feb 16:19:34

function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()), pad(d.getMinutes()), pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
} // log is just a thin wrapper to console.log that prepends a timestamp


exports.log = function () {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */


exports.inherits = __webpack_require__("../node_modules/inherits/inherits.js");

exports._extend = function (origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;
  var keys = Object.keys(add);
  var i = keys.length;

  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }

  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

exports.promisify = function promisify(original) {
  if (typeof original !== 'function') throw new TypeError('The "original" argument must be of type Function');

  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
    var fn = original[kCustomPromisifiedSymbol];

    if (typeof fn !== 'function') {
      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
    }

    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
      value: fn,
      enumerable: false,
      writable: false,
      configurable: true
    });
    return fn;
  }

  function fn() {
    var promiseResolve, promiseReject;
    var promise = new Promise(function (resolve, reject) {
      promiseResolve = resolve;
      promiseReject = reject;
    });
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    args.push(function (err, value) {
      if (err) {
        promiseReject(err);
      } else {
        promiseResolve(value);
      }
    });

    try {
      original.apply(this, args);
    } catch (err) {
      promiseReject(err);
    }

    return promise;
  }

  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
    value: fn,
    enumerable: false,
    writable: false,
    configurable: true
  });
  return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
};

exports.promisify.custom = kCustomPromisifiedSymbol;

function callbackifyOnRejected(reason, cb) {
  // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
  // Because `null` is a special error value in callbacks which means "no error
  // occurred", we error-wrap so the callback consumer can distinguish between
  // "the promise rejected with null" or "the promise fulfilled with undefined".
  if (!reason) {
    var newReason = new Error('Promise was rejected with a falsy value');
    newReason.reason = reason;
    reason = newReason;
  }

  return cb(reason);
}

function callbackify(original) {
  if (typeof original !== 'function') {
    throw new TypeError('The "original" argument must be of type Function');
  } // We DO NOT return the promise as it gives the user a false sense that
  // the promise is actually somehow related to the callback's execution
  // and that the callback throwing will reject the promise.


  function callbackified() {
    var args = [];

    for (var i = 0; i < arguments.length; i++) {
      args.push(arguments[i]);
    }

    var maybeCb = args.pop();

    if (typeof maybeCb !== 'function') {
      throw new TypeError('The last argument must be of type Function');
    }

    var self = this;

    var cb = function cb() {
      return maybeCb.apply(self, arguments);
    }; // In true node style we process the callback on `nextTick` with all the
    // implications (stack, `uncaughtException`, `async_hooks`)


    original.apply(this, args).then(function (ret) {
      global.process.nextTick(cb, null, ret);
    }, function (rej) {
      global.process.nextTick(callbackifyOnRejected, rej, cb);
    });
  }

  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
  Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
  return callbackified;
}

exports.callbackify = callbackify;

/***/ }),

/***/ "../node_modules/os-browserify/browser.js":
/***/ (function(module, exports) {

exports.endianness = function () {
  return 'LE';
};

exports.hostname = function () {
  if (typeof location !== 'undefined') {
    return location.hostname;
  } else return '';
};

exports.loadavg = function () {
  return [];
};

exports.uptime = function () {
  return 0;
};

exports.freemem = function () {
  return Number.MAX_VALUE;
};

exports.totalmem = function () {
  return Number.MAX_VALUE;
};

exports.cpus = function () {
  return [];
};

exports.type = function () {
  return 'Browser';
};

exports.release = function () {
  if (typeof navigator !== 'undefined') {
    return navigator.appVersion;
  }

  return '';
};

exports.networkInterfaces = exports.getNetworkInterfaces = function () {
  return {};
};

exports.arch = function () {
  return 'javascript';
};

exports.platform = function () {
  return 'browser';
};

exports.tmpdir = exports.tmpDir = function () {
  return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
  return '/';
};

/***/ }),

/***/ "../node_modules/pako/lib/utils/common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var TYPED_OK = typeof Uint8Array !== 'undefined' && typeof Uint16Array !== 'undefined' && typeof Int32Array !== 'undefined';

function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

exports.assign = function (obj
/*from1, from2, from3, ...*/
) {
  var sources = Array.prototype.slice.call(arguments, 1);

  while (sources.length) {
    var source = sources.shift();

    if (!source) {
      continue;
    }

    if (typeof source !== 'object') {
      throw new TypeError(source + 'must be non-object');
    }

    for (var p in source) {
      if (_has(source, p)) {
        obj[p] = source[p];
      }
    }
  }

  return obj;
}; // reduce buffer size, avoiding mem copy


exports.shrinkBuf = function (buf, size) {
  if (buf.length === size) {
    return buf;
  }

  if (buf.subarray) {
    return buf.subarray(0, size);
  }

  buf.length = size;
  return buf;
};

var fnTyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    } // Fallback to ordinary array


    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    var i, l, len, pos, chunk, result; // calculate data length

    len = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    } // join chunks


    result = new Uint8Array(len);
    pos = 0;

    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }

    return result;
  }
};
var fnUntyped = {
  arraySet: function arraySet(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function flattenChunks(chunks) {
    return [].concat.apply([], chunks);
  }
}; // Enable/Disable typed arrays use, for testing
//

exports.setTyped = function (on) {
  if (on) {
    exports.Buf8 = Uint8Array;
    exports.Buf16 = Uint16Array;
    exports.Buf32 = Int32Array;
    exports.assign(exports, fnTyped);
  } else {
    exports.Buf8 = Array;
    exports.Buf16 = Array;
    exports.Buf32 = Array;
    exports.assign(exports, fnUntyped);
  }
};

exports.setTyped(TYPED_OK);

/***/ }),

/***/ "../node_modules/pako/lib/zlib/adler32.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: adler32 takes 12% for level 0 and 2% for level 6.
// It isn't worth it to make additional optimizations as in original.
// Small size is preferable.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function adler32(adler, buf, len, pos) {
  var s1 = adler & 0xffff | 0,
      s2 = adler >>> 16 & 0xffff | 0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return s1 | s2 << 16 | 0;
}

module.exports = adler32;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/constants.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  /* Allowed flush values; see deflate() and inflate() below for details */
  Z_NO_FLUSH: 0,
  Z_PARTIAL_FLUSH: 1,
  Z_SYNC_FLUSH: 2,
  Z_FULL_FLUSH: 3,
  Z_FINISH: 4,
  Z_BLOCK: 5,
  Z_TREES: 6,

  /* Return codes for the compression/decompression functions. Negative values
  * are errors, positive values are used for special but normal events.
  */
  Z_OK: 0,
  Z_STREAM_END: 1,
  Z_NEED_DICT: 2,
  Z_ERRNO: -1,
  Z_STREAM_ERROR: -2,
  Z_DATA_ERROR: -3,
  //Z_MEM_ERROR:     -4,
  Z_BUF_ERROR: -5,
  //Z_VERSION_ERROR: -6,

  /* compression levels */
  Z_NO_COMPRESSION: 0,
  Z_BEST_SPEED: 1,
  Z_BEST_COMPRESSION: 9,
  Z_DEFAULT_COMPRESSION: -1,
  Z_FILTERED: 1,
  Z_HUFFMAN_ONLY: 2,
  Z_RLE: 3,
  Z_FIXED: 4,
  Z_DEFAULT_STRATEGY: 0,

  /* Possible values of the data_type field (though see inflate()) */
  Z_BINARY: 0,
  Z_TEXT: 1,
  //Z_ASCII:                1, // = Z_TEXT (deprecated)
  Z_UNKNOWN: 2,

  /* The deflate compression method */
  Z_DEFLATED: 8 //Z_NULL:                 null // Use -1 or null inline, depending on var type

};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/crc32.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.
// (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// Use ordinary array, since untyped makes no boost here

function makeTable() {
  var c,
      table = [];

  for (var n = 0; n < 256; n++) {
    c = n;

    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 0xEDB88320 ^ c >>> 1 : c >>> 1;
    }

    table[n] = c;
  }

  return table;
} // Create table on load. Just 255 signed longs. Not a problem.


var crcTable = makeTable();

function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;
  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return crc ^ -1; // >>> 0;
}

module.exports = crc32;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/deflate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var trees = __webpack_require__("../node_modules/pako/lib/zlib/trees.js");

var adler32 = __webpack_require__("../node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__("../node_modules/pako/lib/zlib/crc32.js");

var msg = __webpack_require__("../node_modules/pako/lib/zlib/messages.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */


var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1; //var Z_SYNC_FLUSH    = 2;

var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5; //var Z_TREES         = 6;

/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1; //var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3; //var Z_MEM_ERROR     = -4;

var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* compression levels */
//var Z_NO_COMPRESSION      = 0;
//var Z_BEST_SPEED          = 1;
//var Z_BEST_COMPRESSION    = 9;

var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
/* Possible values of the data_type field (though see inflate()) */
//var Z_BINARY              = 0;
//var Z_TEXT                = 1;
//var Z_ASCII               = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/* The deflate compression method */

var Z_DEFLATED = 8;
/*============================================================================*/

var MAX_MEM_LEVEL = 9;
/* Maximum value for memLevel in deflateInit2 */

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_MEM_LEVEL = 8;
var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
var PRESET_DICT = 0x20;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
/* block not completed, need more input or more output */

var BS_BLOCK_DONE = 2;
/* block flush performed */

var BS_FINISH_STARTED = 3;
/* finish started, need only more output at next deflate */

var BS_FINISH_DONE = 4;
/* finish done, accept no more input or output */

var OS_CODE = 0x03; // Unix :) . Don't detect, use this default.

function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}

function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
}
/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->output buffer and copying into it.
 * (See also read_buf()).
 */


function flush_pending(strm) {
  var s = strm.state; //_tr_flush_bits(s);

  var len = s.pending;

  if (len > strm.avail_out) {
    len = strm.avail_out;
  }

  if (len === 0) {
    return;
  }

  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;

  if (s.pending === 0) {
    s.pending_out = 0;
  }
}

function flush_block_only(s, last) {
  trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);

  s.block_start = s.strstart;
  flush_pending(s.strm);
}

function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */


function putShortMSB(s, b) {
  //  put_byte(s, (Byte)(b >> 8));
  //  put_byte(s, (Byte)(b & 0xff));
  s.pending_buf[s.pending++] = b >>> 8 & 0xff;
  s.pending_buf[s.pending++] = b & 0xff;
}
/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->input buffer and copying from it.
 * (See also flush_pending()).
 */


function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;

  if (len > size) {
    len = size;
  }

  if (len === 0) {
    return 0;
  }

  strm.avail_in -= len; // zmemcpy(buf, strm->next_in, len);

  utils.arraySet(buf, strm.input, strm.next_in, len, start);

  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }

  strm.next_in += len;
  strm.total_in += len;
  return len;
}
/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */


function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  /* max hash chain length */

  var scan = s.strstart;
  /* current string */

  var match;
  /* matched string */

  var len;
  /* length of current match */

  var best_len = s.prev_length;
  /* best match length so far */

  var nice_match = s.nice_match;
  /* stop if match long enough */

  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0
  /*NIL*/
  ;
  var _win = s.window; // shortcut

  var wmask = s.w_mask;
  var prev = s.prev;
  /* Stop when cur_match becomes <= limit. To simplify the code,
   * we prevent matches with the string of window index 0.
   */

  var strend = s.strstart + MAX_MATCH;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
   * It is easy to get rid of this optimization if necessary.
   */
  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

  /* Do not waste too much time if we already have a good match: */

  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  /* Do not look for matches beyond the end of the input. This is necessary
   * to make deflate deterministic.
   */


  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  } // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");


  do {
    // Assert(cur_match < s->strstart, "no future");
    match = cur_match;
    /* Skip to next match if the match length cannot increase
     * or if the match length is less than 2.  Note that the checks below
     * for insufficient lookahead only occur occasionally for performance
     * reasons.  Therefore uninitialized memory will be accessed, and
     * conditional jumps will be made that depend on those values.
     * However the length of the match is limited to the lookahead, so
     * the output of deflate is not affected by the uninitialized values.
     */

    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */


    scan += 2;
    match++; // Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */

    do {
      /*jshint noempty:false*/
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend); // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");


    len = MAX_MATCH - (strend - scan);
    scan = strend - MAX_MATCH;

    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;

      if (len >= nice_match) {
        break;
      }

      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);

  if (best_len <= s.lookahead) {
    return best_len;
  }

  return s.lookahead;
}
/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */


function fill_window(s) {
  var _w_size = s.w_size;
  var p, n, m, more, str; //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");

  do {
    more = s.window_size - s.lookahead - s.strstart; // JS ints have 32 bit, block below not needed

    /* Deal with !@#$% 64K limit: */
    //if (sizeof(int) <= 2) {
    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
    //        more = wsize;
    //
    //  } else if (more == (unsigned)(-1)) {
    //        /* Very unlikely, but possible on 16 bit machine if
    //         * strstart == 0 && lookahead == 1 (input done a byte at time)
    //         */
    //        more--;
    //    }
    //}

    /* If the window is almost full and there is insufficient lookahead,
     * move the upper half to the lower one to make room in the upper half.
     */

    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      /* we now have strstart >= MAX_DIST */

      s.block_start -= _w_size;
      /* Slide the hash table (could be avoided with 32 bit values
       at the expense of memory usage). We slide even when level == 0
       to keep the hash table consistent if we switch back to level > 0
       later. (Using level 0 permanently is not an optimal usage of
       zlib, so we don't care about this pathological case.)
       */

      n = s.hash_size;
      p = n;

      do {
        m = s.head[--p];
        s.head[p] = m >= _w_size ? m - _w_size : 0;
      } while (--n);

      n = _w_size;
      p = n;

      do {
        m = s.prev[--p];
        s.prev[p] = m >= _w_size ? m - _w_size : 0;
        /* If n is not on any hash chain, prev[n] is garbage but
         * its value will never be used.
         */
      } while (--n);

      more += _w_size;
    }

    if (s.strm.avail_in === 0) {
      break;
    }
    /* If there was no sliding:
     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
     *    more == window_size - lookahead - strstart
     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
     * => more >= window_size - 2*WSIZE + 2
     * In the BIG_MEM or MMAP case (not yet supported),
     *   window_size == input_size + MIN_LOOKAHEAD  &&
     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
     * Otherwise, window_size == 2*WSIZE so more >= 2.
     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
     */
    //Assert(more >= 2, "more < 2");


    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    /* Initialize the hash value now that we have some input: */

    if (s.lookahead + s.insert >= MIN_MATCH) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */

      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; //#if MIN_MATCH != 3
      //        Call update_hash() MIN_MATCH-3 more times
      //#endif

      while (s.insert) {
        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;

        if (s.lookahead + s.insert < MIN_MATCH) {
          break;
        }
      }
    }
    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
     * but this is not important since only literal bytes will be emitted.
     */

  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
  /* If the WIN_INIT bytes after the end of the current data have never been
   * written, then zero those bytes in order to avoid memory check reports of
   * the use of uninitialized (or uninitialised as Julian writes) bytes by
   * the longest match routines.  Update the high water mark for the next
   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match
   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.
   */
  //  if (s.high_water < s.window_size) {
  //    var curr = s.strstart + s.lookahead;
  //    var init = 0;
  //
  //    if (s.high_water < curr) {
  //      /* Previous high water mark below current data -- zero WIN_INIT
  //       * bytes or up to end of window, whichever is less.
  //       */
  //      init = s.window_size - curr;
  //      if (init > WIN_INIT)
  //        init = WIN_INIT;
  //      zmemzero(s->window + curr, (unsigned)init);
  //      s->high_water = curr + init;
  //    }
  //    else if (s->high_water < (ulg)curr + WIN_INIT) {
  //      /* High water mark at or above current data, but below current data
  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up
  //       * to end of window, whichever is less.
  //       */
  //      init = (ulg)curr + WIN_INIT - s->high_water;
  //      if (init > s->window_size - s->high_water)
  //        init = s->window_size - s->high_water;
  //      zmemzero(s->window + s->high_water, (unsigned)init);
  //      s->high_water += init;
  //    }
  //  }
  //
  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,
  //    "not enough room for search");

}
/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */


function deflate_stored(s, flush) {
  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
   * to pending_buf_size, and each stored block has a 5 byte header:
   */
  var max_block_size = 0xffff;

  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  /* Copy as much as possible from input to output: */


  for (;;) {
    /* Fill the window as much as possible: */
    if (s.lookahead <= 1) {
      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||
      //  s->block_start >= (long)s->w_size, "slide too late");
      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||
      //        s.block_start >= s.w_size)) {
      //        throw  new Error("slide too late");
      //      }
      fill_window(s);

      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    } //Assert(s->block_start >= 0L, "block gone");
    //    if (s.block_start < 0) throw new Error("block gone");


    s.strstart += s.lookahead;
    s.lookahead = 0;
    /* Emit a stored block if pending_buf will be full: */

    var max_start = s.block_start + max_block_size;

    if (s.strstart === 0 || s.strstart >= max_start) {
      /* strstart == 0 is possible when wraparound on 16-bit machine */
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      /*** FLUSH_BLOCK(s, 0); ***/

      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
    /* Flush if we may have to slide, otherwise block_start may become
     * negative and the data will be gone:
     */


    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.strstart > s.block_start) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_NEED_MORE;
}
/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */


function deflate_fast(s, flush) {
  var hash_head;
  /* head of the hash chain */

  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
        /* flush the current block */
      }
    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     * At this point we have always match_length < MIN_MATCH
     */


    if (hash_head !== 0
    /*NIL*/
    && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      /* To simplify the code, we prevent matches with the string
       * of window index 0 (in particular we have to avoid a match
       * of the string with itself at the start of the input file).
       */
      s.match_length = longest_match(s, hash_head);
      /* longest_match() sets match_start */
    }

    if (s.match_length >= MIN_MATCH) {
      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only

      /*** _tr_tally_dist(s, s.strstart - s.match_start,
                     s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      /* Insert new strings in the hash table only if the match length
       * is not too large. This saves time but degrades compression.
       */

      if (s.match_length <= s.max_lazy_match
      /*max_insert_length*/
      && s.lookahead >= MIN_MATCH) {
        s.match_length--;
        /* string at strstart already in table */

        do {
          s.strstart++;
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/

          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/

          /* strstart never exceeds WSIZE-MAX_MATCH, so there are
           * always MIN_MATCH bytes ahead.
           */
        } while (--s.match_length !== 0);

        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */

        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask; //#if MIN_MATCH != 3
        //                Call UPDATE_HASH() MIN_MATCH-3 more times
        //#endif

        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
         * matter since it will be recomputed at next deflate call.
         */
      }
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s.window[s.strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */


function deflate_slow(s, flush) {
  var hash_head;
  /* head of hash chain */

  var bflush;
  /* set if current block must be flushed */

  var max_insert;
  /* Process the input block. */

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the next match, plus MIN_MATCH bytes to insert the
     * string following the next match.
     */
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);

      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* Insert the string window[strstart .. strstart+2] in the
     * dictionary, and set hash_head to the head of the hash chain:
     */


    hash_head = 0
    /*NIL*/
    ;

    if (s.lookahead >= MIN_MATCH) {
      /*** INSERT_STRING(s, s.strstart, hash_head); ***/
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
      /***/
    }
    /* Find the longest match, discarding those <= prev_length.
     */


    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH - 1;

    if (hash_head !== 0
    /*NIL*/
    && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD
    /*MAX_DIST(s)*/
    ) {
        /* To simplify the code, we prevent matches with the string
         * of window index 0 (in particular we have to avoid a match
         * of the string with itself at the start of the input file).
         */
        s.match_length = longest_match(s, hash_head);
        /* longest_match() sets match_start */

        if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096
        /*TOO_FAR*/
        )) {
          /* If prev_match is also MIN_MATCH, match_start is garbage
           * but we will ignore the current match anyway.
           */
          s.match_length = MIN_MATCH - 1;
        }
      }
    /* If there was a match at the previous step and the current
     * match is not better, output the previous match:
     */


    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH;
      /* Do not insert strings in hash table beyond this. */
      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);

      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,
                     s.prev_length - MIN_MATCH, bflush);***/

      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
      /* Insert in hash table all strings up to the end of the match.
       * strstart-1 and strstart are already inserted. If there is not
       * enough lookahead, the last two strings are not inserted in
       * the hash table.
       */

      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;

      do {
        if (++s.strstart <= max_insert) {
          /*** INSERT_STRING(s, s.strstart, hash_head); ***/
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
          /***/
        }
      } while (--s.prev_length !== 0);

      s.match_available = 0;
      s.match_length = MIN_MATCH - 1;
      s.strstart++;

      if (bflush) {
        /*** FLUSH_BLOCK(s, 0); ***/
        flush_block_only(s, false);

        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
        /***/

      }
    } else if (s.match_available) {
      /* If there was no match at the previous position, output a
       * single literal. If there was a match but the current match
       * is longer, truncate the previous match to a single literal.
       */
      //Tracevv((stderr,"%c", s->window[s->strstart-1]));

      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);

      if (bflush) {
        /*** FLUSH_BLOCK_ONLY(s, 0) ***/
        flush_block_only(s, false);
        /***/
      }

      s.strstart++;
      s.lookahead--;

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      /* There is no previous match to compare with, wait for
       * the next step to decide.
       */
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  } //Assert (flush != Z_NO_FLUSH, "no flush?");


  if (s.match_available) {
    //Tracevv((stderr,"%c", s->window[s->strstart-1]));

    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/
    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }

  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_RLE, simply look for runs of bytes, generate matches only of distance
 * one.  Do not maintain a hash table.  (It will be regenerated if this run of
 * deflate switches away from Z_RLE.)
 */


function deflate_rle(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  var prev;
  /* byte at distance one to match */

  var scan, strend;
  /* scan goes up to strend for length of run */

  var _win = s.window;

  for (;;) {
    /* Make sure that we always have enough lookahead, except
     * at the end of the input file. We need MAX_MATCH bytes
     * for the longest run, plus one for the unrolled loop.
     */
    if (s.lookahead <= MAX_MATCH) {
      fill_window(s);

      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }

      if (s.lookahead === 0) {
        break;
      }
      /* flush the current block */

    }
    /* See how many times the previous byte repeats */


    s.match_length = 0;

    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];

      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH;

        do {
          /*jshint noempty:false*/
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);

        s.match_length = MAX_MATCH - (strend - scan);

        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      } //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");

    }
    /* Emit match if have run of MIN_MATCH or longer, else emit literal */


    if (s.match_length >= MIN_MATCH) {
      //check_match(s, s.strstart, s.strstart - 1, s.match_length);

      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/
      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      /* No match, output a literal byte */
      //Tracevv((stderr,"%c", s->window[s->strstart]));

      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/
      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* ===========================================================================
 * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.
 * (It will be regenerated if this run of deflate switches away from Huffman.)
 */


function deflate_huff(s, flush) {
  var bflush;
  /* set if current block must be flushed */

  for (;;) {
    /* Make sure that we have a literal to write. */
    if (s.lookahead === 0) {
      fill_window(s);

      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }

        break;
        /* flush the current block */
      }
    }
    /* Output a literal byte */


    s.match_length = 0; //Tracevv((stderr,"%c", s->window[s->strstart]));

    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/

    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;

    if (bflush) {
      /*** FLUSH_BLOCK(s, 0); ***/
      flush_block_only(s, false);

      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
      /***/

    }
  }

  s.insert = 0;

  if (flush === Z_FINISH) {
    /*** FLUSH_BLOCK(s, 1); ***/
    flush_block_only(s, true);

    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    /***/


    return BS_FINISH_DONE;
  }

  if (s.last_lit) {
    /*** FLUSH_BLOCK(s, 0); ***/
    flush_block_only(s, false);

    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
    /***/

  }

  return BS_BLOCK_DONE;
}
/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */


function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}

var configuration_table;
configuration_table = [
/*      good lazy nice chain */
new Config(0, 0, 0, 0, deflate_stored),
/* 0 store only */
new Config(4, 4, 8, 4, deflate_fast),
/* 1 max speed, no lazy matches */
new Config(4, 5, 16, 8, deflate_fast),
/* 2 */
new Config(4, 6, 32, 32, deflate_fast),
/* 3 */
new Config(4, 4, 16, 16, deflate_slow),
/* 4 lazy matches */
new Config(8, 16, 32, 32, deflate_slow),
/* 5 */
new Config(8, 16, 128, 128, deflate_slow),
/* 6 */
new Config(8, 32, 128, 256, deflate_slow),
/* 7 */
new Config(32, 128, 258, 1024, deflate_slow),
/* 8 */
new Config(32, 258, 258, 4096, deflate_slow)
/* 9 max compression */
];
/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */

function lm_init(s) {
  s.window_size = 2 * s.w_size;
  /*** CLEAR_HASH(s); ***/

  zero(s.head); // Fill with NIL (= 0);

  /* Set the default configuration parameters:
   */

  s.max_lazy_match = configuration_table[s.level].max_lazy;
  s.good_match = configuration_table[s.level].good_length;
  s.nice_match = configuration_table[s.level].nice_length;
  s.max_chain_length = configuration_table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  s.ins_h = 0;
}

function DeflateState() {
  this.strm = null;
  /* pointer back to this zlib stream */

  this.status = 0;
  /* as the name implies */

  this.pending_buf = null;
  /* output still pending */

  this.pending_buf_size = 0;
  /* size of pending_buf */

  this.pending_out = 0;
  /* next pending byte to output to the stream */

  this.pending = 0;
  /* nb of bytes in the pending buffer */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.gzhead = null;
  /* gzip header information to write */

  this.gzindex = 0;
  /* where in extra, name, or comment */

  this.method = Z_DEFLATED;
  /* can only be DEFLATED */

  this.last_flush = -1;
  /* value of flush param for previous deflate call */

  this.w_size = 0;
  /* LZ77 window size (32K by default) */

  this.w_bits = 0;
  /* log2(w_size)  (8..16) */

  this.w_mask = 0;
  /* w_size - 1 */

  this.window = null;
  /* Sliding window. Input bytes are read into the second half of the window,
   * and move to the first half later to keep a dictionary of at least wSize
   * bytes. With this organization, matches are limited to a distance of
   * wSize-MAX_MATCH bytes, but this ensures that IO is always
   * performed with a length multiple of the block size.
   */

  this.window_size = 0;
  /* Actual size of window: 2*wSize, except when the user input buffer
   * is directly used as sliding window.
   */

  this.prev = null;
  /* Link to older string with same hash index. To limit the size of this
   * array to 64K, this link is maintained only for the last 32K strings.
   * An index in this array is thus a window index modulo 32K.
   */

  this.head = null;
  /* Heads of the hash chains or NIL. */

  this.ins_h = 0;
  /* hash index of string to be inserted */

  this.hash_size = 0;
  /* number of elements in hash table */

  this.hash_bits = 0;
  /* log2(hash_size) */

  this.hash_mask = 0;
  /* hash_size-1 */

  this.hash_shift = 0;
  /* Number of bits by which ins_h must be shifted at each input
   * step. It must be such that after MIN_MATCH steps, the oldest
   * byte no longer takes part in the hash key, that is:
   *   hash_shift * MIN_MATCH >= hash_bits
   */

  this.block_start = 0;
  /* Window position at the beginning of the current output block. Gets
   * negative when the window is moved backwards.
   */

  this.match_length = 0;
  /* length of best match */

  this.prev_match = 0;
  /* previous match */

  this.match_available = 0;
  /* set if previous match exists */

  this.strstart = 0;
  /* start of string to insert */

  this.match_start = 0;
  /* start of matching string */

  this.lookahead = 0;
  /* number of valid bytes ahead in window */

  this.prev_length = 0;
  /* Length of the best match at previous step. Matches not greater than this
   * are discarded. This is used in the lazy match evaluation.
   */

  this.max_chain_length = 0;
  /* To speed up deflation, hash chains are never searched beyond this
   * length.  A higher limit improves compression ratio but degrades the
   * speed.
   */

  this.max_lazy_match = 0;
  /* Attempt to find a better match only when the current match is strictly
   * smaller than this value. This mechanism is used only for compression
   * levels >= 4.
   */
  // That's alias to max_lazy_match, don't use directly
  //this.max_insert_length = 0;

  /* Insert new strings in the hash table only if the match length is not
   * greater than this length. This saves time but degrades compression.
   * max_insert_length is used only for compression levels <= 3.
   */

  this.level = 0;
  /* compression level (1..9) */

  this.strategy = 0;
  /* favor or force Huffman coding*/

  this.good_match = 0;
  /* Use a faster search when the previous match is longer than this */

  this.nice_match = 0;
  /* Stop searching when current match exceeds this */

  /* used by trees.c: */

  /* Didn't use ct_data typedef below to suppress compiler warning */
  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */
  // Use flat array of DOUBLE size, with interleaved fata,
  // because JS does not support effective

  this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
  this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
  this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
  zero(this.dyn_ltree);
  zero(this.dyn_dtree);
  zero(this.bl_tree);
  this.l_desc = null;
  /* desc. for literal tree */

  this.d_desc = null;
  /* desc. for distance tree */

  this.bl_desc = null;
  /* desc. for bit length tree */
  //ush bl_count[MAX_BITS+1];

  this.bl_count = new utils.Buf16(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */

  this.heap = new utils.Buf16(2 * L_CODES + 1);
  /* heap used to build the Huffman trees */

  zero(this.heap);
  this.heap_len = 0;
  /* number of elements in the heap */

  this.heap_max = 0;
  /* element of largest frequency */

  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
   * The same heap array is used to build all trees.
   */

  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];

  zero(this.depth);
  /* Depth of each subtree used as tie breaker for trees of equal frequency
   */

  this.l_buf = 0;
  /* buffer index for literals or lengths */

  this.lit_bufsize = 0;
  /* Size of match buffer for literals/lengths.  There are 4 reasons for
   * limiting lit_bufsize to 64K:
   *   - frequencies can be kept in 16 bit counters
   *   - if compression is not successful for the first block, all input
   *     data is still in the window so we can still emit a stored block even
   *     when input comes from standard input.  (This can also be done for
   *     all blocks if lit_bufsize is not greater than 32K.)
   *   - if compression is not successful for a file smaller than 64K, we can
   *     even emit a stored file instead of a stored block (saving 5 bytes).
   *     This is applicable only for zip (not gzip or zlib).
   *   - creating new Huffman trees less frequently may not provide fast
   *     adaptation to changes in the input data statistics. (Take for
   *     example a binary file with poorly compressible code followed by
   *     a highly compressible string table.) Smaller buffer sizes give
   *     fast adaptation but have of course the overhead of transmitting
   *     trees more frequently.
   *   - I can't count above 4
   */

  this.last_lit = 0;
  /* running index in l_buf */

  this.d_buf = 0;
  /* Buffer index for distances. To simplify the code, d_buf and l_buf have
   * the same number of elements. To use different lengths, an extra flag
   * array would be necessary.
   */

  this.opt_len = 0;
  /* bit length of current block with optimal trees */

  this.static_len = 0;
  /* bit length of current block with static trees */

  this.matches = 0;
  /* number of string matches in current block */

  this.insert = 0;
  /* bytes at end of window left to insert */

  this.bi_buf = 0;
  /* Output buffer. bits are inserted starting at the bottom (least
   * significant bits).
   */

  this.bi_valid = 0;
  /* Number of valid bits in bi_buf.  All bits above the last valid bit
   * are always zero.
   */
  // Used for window memory init. We safely ignore it for JS. That makes
  // sense only for pointers and memory check tools.
  //this.high_water = 0;

  /* High water mark offset in window for initialized bytes -- bytes above
   * this are set to zero in order to avoid memory check warnings when
   * longest match routines access bytes past the input.  This is then
   * updated to the new high water mark.
   */
}

function deflateResetKeep(strm) {
  var s;

  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;

  if (s.wrap < 0) {
    s.wrap = -s.wrap;
    /* was made negative by deflate(..., Z_FINISH); */
  }

  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 // crc32(0, Z_NULL, 0)
  : 1; // adler32(0, Z_NULL, 0)

  s.last_flush = Z_NO_FLUSH;

  trees._tr_init(s);

  return Z_OK;
}

function deflateReset(strm) {
  var ret = deflateResetKeep(strm);

  if (ret === Z_OK) {
    lm_init(strm.state);
  }

  return ret;
}

function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }

  strm.state.gzhead = head;
  return Z_OK;
}

function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    // === Z_NULL
    return Z_STREAM_ERROR;
  }

  var wrap = 1;

  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }

  if (windowBits < 0) {
    /* suppress zlib wrapper */
    wrap = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap = 2;
    /* write gzip wrapper instead */

    windowBits -= 16;
  }

  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }

  if (windowBits === 8) {
    windowBits = 9;
  }
  /* until 256-byte window bug fixed */


  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
  s.window = new utils.Buf8(s.w_size * 2);
  s.head = new utils.Buf16(s.hash_size);
  s.prev = new utils.Buf16(s.w_size); // Don't need mem init magic for JS.
  //s.high_water = 0;  /* nothing written to s->window yet */

  s.lit_bufsize = 1 << memLevel + 6;
  /* 16K elements by default */

  s.pending_buf_size = s.lit_bufsize * 4; //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
  //s->pending_buf = (uchf *) overlay;

  s.pending_buf = new utils.Buf8(s.pending_buf_size); // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)
  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  s.d_buf = 1 * s.lit_bufsize; //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}

function deflateInit(strm, level) {
  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
}

function deflate(strm, flush) {
  var old_flush, s;
  var beg, val; // for gzip header write only

  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }

  s = strm.state;

  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }

  s.strm = strm;
  /* just in case */

  old_flush = s.last_flush;
  s.last_flush = flush;
  /* Write the header */

  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      // GZIP header
      strm.adler = 0; //crc32(0L, Z_NULL, 0);

      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);

      if (!s.gzhead) {
        // s->gzhead == Z_NULL
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
        put_byte(s, s.gzhead.time & 0xff);
        put_byte(s, s.gzhead.time >> 8 & 0xff);
        put_byte(s, s.gzhead.time >> 16 & 0xff);
        put_byte(s, s.gzhead.time >> 24 & 0xff);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 0xff);

        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 0xff);
          put_byte(s, s.gzhead.extra.length >> 8 & 0xff);
        }

        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }

        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else // DEFLATE header
      {
        var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
        var level_flags = -1;

        if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
          level_flags = 0;
        } else if (s.level < 6) {
          level_flags = 1;
        } else if (s.level === 6) {
          level_flags = 2;
        } else {
          level_flags = 3;
        }

        header |= level_flags << 6;

        if (s.strstart !== 0) {
          header |= PRESET_DICT;
        }

        header += 31 - header % 31;
        s.status = BUSY_STATE;
        putShortMSB(s, header);
        /* Save the adler32 of the preset dictionary: */

        if (s.strstart !== 0) {
          putShortMSB(s, strm.adler >>> 16);
          putShortMSB(s, strm.adler & 0xffff);
        }

        strm.adler = 1; // adler32(0L, Z_NULL, 0);
      }
  } //#ifdef GZIP


  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */

        while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              break;
            }
          }

          put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);
          s.gzindex++;
        }

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (s.gzindex === s.gzhead.extra.length) {
          s.gzindex = 0;
          s.status = NAME_STATE;
        }
      } else {
      s.status = NAME_STATE;
    }
  }

  if (s.status === NAME_STATE) {
    if (s.gzhead.name
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.name.length) {
            val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.gzindex = 0;
          s.status = COMMENT_STATE;
        }
      } else {
      s.status = COMMENT_STATE;
    }
  }

  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment
    /* != Z_NULL*/
    ) {
        beg = s.pending;
        /* start of bytes to update crc */
        //int val;

        do {
          if (s.pending === s.pending_buf_size) {
            if (s.gzhead.hcrc && s.pending > beg) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
            }

            flush_pending(strm);
            beg = s.pending;

            if (s.pending === s.pending_buf_size) {
              val = 1;
              break;
            }
          } // JS specific: little magic to add zero terminator to end of string


          if (s.gzindex < s.gzhead.comment.length) {
            val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;
          } else {
            val = 0;
          }

          put_byte(s, val);
        } while (val !== 0);

        if (s.gzhead.hcrc && s.pending > beg) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
        }

        if (val === 0) {
          s.status = HCRC_STATE;
        }
      } else {
      s.status = HCRC_STATE;
    }
  }

  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }

      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 0xff);
        put_byte(s, strm.adler >> 8 & 0xff);
        strm.adler = 0; //crc32(0L, Z_NULL, 0);

        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  } //#endif

  /* Flush as much pending output as possible */


  if (s.pending !== 0) {
    flush_pending(strm);

    if (strm.avail_out === 0) {
      /* Since avail_out is 0, deflate will be called again with
       * more output space, but possibly with both pending and
       * avail_in equal to zero. There won't be anything to do,
       * but this is not an error situation so make sure we
       * return OK instead of BUF_ERROR at next call of deflate:
       */
      s.last_flush = -1;
      return Z_OK;
    }
    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUF_ERROR.
     */

  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  /* User must not provide more input after the first FINISH: */


  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  /* Start a new block or continue the current one.
   */


  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);

    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }

    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR next call, see above */
      }

      return Z_OK;
      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
       * of deflate should use the same flush parameter to make sure
       * that the flush is complete. So we don't have to output an
       * empty block here, this will be done at next call. This also
       * ensures that for a very small output buffer, we emit at most
       * one empty block.
       */
    }

    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        trees._tr_align(s);
      } else if (flush !== Z_BLOCK) {
        /* FULL_FLUSH or SYNC_FLUSH */
        trees._tr_stored_block(s, 0, 0, false);
        /* For a full flush, this empty block will be recognized
         * as a special marker by inflate_sync().
         */


        if (flush === Z_FULL_FLUSH) {
          /*** CLEAR_HASH(s); ***/

          /* forget history */
          zero(s.head); // Fill with NIL (= 0);

          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }

      flush_pending(strm);

      if (strm.avail_out === 0) {
        s.last_flush = -1;
        /* avoid BUF_ERROR at next call, see above */

        return Z_OK;
      }
    }
  } //Assert(strm->avail_out > 0, "bug2");
  //if (strm.avail_out <= 0) { throw new Error("bug2");}


  if (flush !== Z_FINISH) {
    return Z_OK;
  }

  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  /* Write the trailer */


  if (s.wrap === 2) {
    put_byte(s, strm.adler & 0xff);
    put_byte(s, strm.adler >> 8 & 0xff);
    put_byte(s, strm.adler >> 16 & 0xff);
    put_byte(s, strm.adler >> 24 & 0xff);
    put_byte(s, strm.total_in & 0xff);
    put_byte(s, strm.total_in >> 8 & 0xff);
    put_byte(s, strm.total_in >> 16 & 0xff);
    put_byte(s, strm.total_in >> 24 & 0xff);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 0xffff);
  }

  flush_pending(strm);
  /* If avail_out is zero, the application will call deflate again
   * to flush the rest.
   */

  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  /* write the trailer only once! */


  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}

function deflateEnd(strm) {
  var status;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  status = strm.state.status;

  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }

  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
/* =========================================================================
 * Initializes the compression dictionary from the given byte
 * sequence without producing any compressed output.
 */


function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap;
  var avail;
  var next;
  var input;
  var tmpDict;

  if (!strm
  /*== Z_NULL*/
  || !strm.state
  /*== Z_NULL*/
  ) {
      return Z_STREAM_ERROR;
    }

  s = strm.state;
  wrap = s.wrap;

  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  /* when using zlib wrappers, compute Adler-32 for provided dictionary */


  if (wrap === 1) {
    /* adler32(strm->adler, dictionary, dictLength); */
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }

  s.wrap = 0;
  /* avoid computing Adler-32 in read_buf */

  /* if dictionary would fill window, just replace the history */

  if (dictLength >= s.w_size) {
    if (wrap === 0) {
      /* already empty otherwise */

      /*** CLEAR_HASH(s); ***/
      zero(s.head); // Fill with NIL (= 0);

      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    /* use the tail */
    // dictionary = dictionary.slice(dictLength - s.w_size);


    tmpDict = new utils.Buf8(s.w_size);
    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  /* insert dictionary into window and hash */


  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);

  while (s.lookahead >= MIN_MATCH) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH - 1);

    do {
      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);

    s.strstart = str;
    s.lookahead = MIN_MATCH - 1;
    fill_window(s);
  }

  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap;
  return Z_OK;
}

exports.deflateInit = deflateInit;
exports.deflateInit2 = deflateInit2;
exports.deflateReset = deflateReset;
exports.deflateResetKeep = deflateResetKeep;
exports.deflateSetHeader = deflateSetHeader;
exports.deflate = deflate;
exports.deflateEnd = deflateEnd;
exports.deflateSetDictionary = deflateSetDictionary;
exports.deflateInfo = 'pako deflate (from Nodeca project)';
/* Not implemented
exports.deflateBound = deflateBound;
exports.deflateCopy = deflateCopy;
exports.deflateParams = deflateParams;
exports.deflatePending = deflatePending;
exports.deflatePrime = deflatePrime;
exports.deflateTune = deflateTune;
*/

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inffast.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.
// See state defs from inflate.js

var BAD = 30;
/* got a data error -- remain here until reset */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */

module.exports = function inflate_fast(strm, start) {
  var state;

  var _in;
  /* local strm.input */


  var last;
  /* have enough input while in < last */

  var _out;
  /* local strm.output */


  var beg;
  /* inflate()'s initial strm.output */

  var end;
  /* while out < end, enough space available */
  //#ifdef INFLATE_STRICT

  var dmax;
  /* maximum distance from zlib header */
  //#endif

  var wsize;
  /* window size or zero if not using window */

  var whave;
  /* valid bytes in the window */

  var wnext;
  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools

  var s_window;
  /* allocated sliding window, if wsize != 0 */

  var hold;
  /* local strm.hold */

  var bits;
  /* local strm.bits */

  var lcode;
  /* local strm.lencode */

  var dcode;
  /* local strm.distcode */

  var lmask;
  /* mask for first level of length codes */

  var dmask;
  /* mask for first level of distance codes */

  var here;
  /* retrieved table entry */

  var op;
  /* code bits, operation, extra bits, or */

  /*  window position, window bytes to copy */

  var len;
  /* match length, unused bytes */

  var dist;
  /* match distance */

  var from;
  /* where to copy match from */

  var from_source;
  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */

  state = strm.state; //here = state.here;

  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257); //#ifdef INFLATE_STRICT

  dmax = state.dmax; //#endif

  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top: do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen: for (;;) {
      // Goto emulation
      op = here >>> 24
      /*here.bits*/
      ;
      hold >>>= op;
      bits -= op;
      op = here >>> 16 & 0xff
      /*here.op*/
      ;

      if (op === 0) {
        /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff
        /*here.val*/
        ;
      } else if (op & 16) {
        /* length base */
        len = here & 0xffff
        /*here.val*/
        ;
        op &= 15;
        /* number of extra bits */

        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }

          len += hold & (1 << op) - 1;
          hold >>>= op;
          bits -= op;
        } //Tracevv((stderr, "inflate:         length %u\n", len));


        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }

        here = dcode[hold & dmask];

        dodist: for (;;) {
          // goto emulation
          op = here >>> 24
          /*here.bits*/
          ;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 0xff
          /*here.op*/
          ;

          if (op & 16) {
            /* distance base */
            dist = here & 0xffff
            /*here.val*/
            ;
            op &= 15;
            /* number of extra bits */

            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;

              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }

            dist += hold & (1 << op) - 1; //#ifdef INFLATE_STRICT

            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            } //#endif


            hold >>>= op;
            bits -= op; //Tracevv((stderr, "inflate:         distance %u\n", dist));

            op = _out - beg;
            /* max distance in output */

            if (dist > op) {
              /* see if copy from window */
              op = dist - op;
              /* distance back in window */

              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                } // (!) This block is disabled in zlib defaults,
                // don't enable it for binary compatibility
                //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
                //                if (len <= op - whave) {
                //                  do {
                //                    output[_out++] = 0;
                //                  } while (--len);
                //                  continue top;
                //                }
                //                len -= op - whave;
                //                do {
                //                  output[_out++] = 0;
                //                } while (--op > whave);
                //                if (op === 0) {
                //                  from = _out - dist;
                //                  do {
                //                    output[_out++] = output[from++];
                //                  } while (--len);
                //                  continue top;
                //                }
                //#endif

              }

              from = 0; // window index

              from_source = s_window;

              if (wnext === 0) {
                /* very common case */
                from += wsize - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              } else if (wnext < op) {
                /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;

                if (op < len) {
                  /* some from end of window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = 0;

                  if (wnext < len) {
                    /* some from start of window */
                    op = wnext;
                    len -= op;

                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);

                    from = _out - dist;
                    /* rest from output */

                    from_source = output;
                  }
                }
              } else {
                /* contiguous in window */
                from += wnext - op;

                if (op < len) {
                  /* some from window */
                  len -= op;

                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);

                  from = _out - dist;
                  /* rest from output */

                  from_source = output;
                }
              }

              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }

              if (len) {
                output[_out++] = from_source[from++];

                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            } else {
              from = _out - dist;
              /* copy direct from output */

              do {
                /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);

              if (len) {
                output[_out++] = output[from++];

                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          } else if ((op & 64) === 0) {
            /* 2nd level distance code */
            here = dcode[(here & 0xffff) + (
            /*here.val*/
            hold & (1 << op) - 1)];
            continue dodist;
          } else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      } else if ((op & 64) === 0) {
        /* 2nd level length code */
        here = lcode[(here & 0xffff) + (
        /*here.val*/
        hold & (1 << op) - 1)];
        continue dolen;
      } else if (op & 32) {
        /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      } else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);
  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */


  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  /* update state and return */

  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inflate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var adler32 = __webpack_require__("../node_modules/pako/lib/zlib/adler32.js");

var crc32 = __webpack_require__("../node_modules/pako/lib/zlib/crc32.js");

var inflate_fast = __webpack_require__("../node_modules/pako/lib/zlib/inffast.js");

var inflate_table = __webpack_require__("../node_modules/pako/lib/zlib/inftrees.js");

var CODES = 0;
var LENS = 1;
var DISTS = 2;
/* Public constants ==========================================================*/

/* ===========================================================================*/

/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;

var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_TREES = 6;
/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */

var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2; //var Z_ERRNO         = -1;

var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR = -5; //var Z_VERSION_ERROR = -6;

/* The deflate compression method */

var Z_DEFLATED = 8;
/* STATES ====================================================================*/

/* ===========================================================================*/

var HEAD = 1;
/* i: waiting for magic header */

var FLAGS = 2;
/* i: waiting for method and flags (gzip) */

var TIME = 3;
/* i: waiting for modification time (gzip) */

var OS = 4;
/* i: waiting for extra flags and operating system (gzip) */

var EXLEN = 5;
/* i: waiting for extra length (gzip) */

var EXTRA = 6;
/* i: waiting for extra bytes (gzip) */

var NAME = 7;
/* i: waiting for end of file name (gzip) */

var COMMENT = 8;
/* i: waiting for end of comment (gzip) */

var HCRC = 9;
/* i: waiting for header crc (gzip) */

var DICTID = 10;
/* i: waiting for dictionary check value */

var DICT = 11;
/* waiting for inflateSetDictionary() call */

var TYPE = 12;
/* i: waiting for type bits, including last-flag bit */

var TYPEDO = 13;
/* i: same, but skip check to exit inflate on new block */

var STORED = 14;
/* i: waiting for stored size (length and complement) */

var COPY_ = 15;
/* i/o: same as COPY below, but only first time in */

var COPY = 16;
/* i/o: waiting for input or output to copy stored block */

var TABLE = 17;
/* i: waiting for dynamic block table lengths */

var LENLENS = 18;
/* i: waiting for code length code lengths */

var CODELENS = 19;
/* i: waiting for length/lit and distance code lengths */

var LEN_ = 20;
/* i: same as LEN below, but only first time in */

var LEN = 21;
/* i: waiting for length/lit/eob code */

var LENEXT = 22;
/* i: waiting for length extra bits */

var DIST = 23;
/* i: waiting for distance code */

var DISTEXT = 24;
/* i: waiting for distance extra bits */

var MATCH = 25;
/* o: waiting for output space to copy string */

var LIT = 26;
/* o: waiting for output space to write literal */

var CHECK = 27;
/* i: waiting for 32-bit check value */

var LENGTH = 28;
/* i: waiting for 32-bit length (gzip) */

var DONE = 29;
/* finished check, done -- remain here until reset */

var BAD = 30;
/* got a data error -- remain here until reset */

var MEM = 31;
/* got an inflate() memory error -- remain here until reset */

var SYNC = 32;
/* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/

var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */

var DEF_WBITS = MAX_WBITS;

function zswap32(q) {
  return (q >>> 24 & 0xff) + (q >>> 8 & 0xff00) + ((q & 0xff00) << 8) + ((q & 0xff) << 24);
}

function InflateState() {
  this.mode = 0;
  /* current inflate mode */

  this.last = false;
  /* true if processing last block */

  this.wrap = 0;
  /* bit 0 true for zlib, bit 1 true for gzip */

  this.havedict = false;
  /* true if dictionary provided */

  this.flags = 0;
  /* gzip header method and flags (0 if zlib) */

  this.dmax = 0;
  /* zlib header max distance (INFLATE_STRICT) */

  this.check = 0;
  /* protected copy of check value */

  this.total = 0;
  /* protected copy of output count */
  // TODO: may be {}

  this.head = null;
  /* where to save gzip header information */

  /* sliding window */

  this.wbits = 0;
  /* log base 2 of requested window size */

  this.wsize = 0;
  /* window size or zero if not using window */

  this.whave = 0;
  /* valid bytes in the window */

  this.wnext = 0;
  /* window write index */

  this.window = null;
  /* allocated sliding window, if needed */

  /* bit accumulator */

  this.hold = 0;
  /* input bit accumulator */

  this.bits = 0;
  /* number of bits in "in" */

  /* for string and stored block copying */

  this.length = 0;
  /* literal or length of data to copy */

  this.offset = 0;
  /* distance back to copy string from */

  /* for table and code decoding */

  this.extra = 0;
  /* extra bits needed */

  /* fixed and dynamic code tables */

  this.lencode = null;
  /* starting table for length/literal codes */

  this.distcode = null;
  /* starting table for distance codes */

  this.lenbits = 0;
  /* index bits for lencode */

  this.distbits = 0;
  /* index bits for distcode */

  /* dynamic table building */

  this.ncode = 0;
  /* number of code length code lengths */

  this.nlen = 0;
  /* number of length code lengths */

  this.ndist = 0;
  /* number of distance code lengths */

  this.have = 0;
  /* number of code lengths in lens[] */

  this.next = null;
  /* next available space in codes[] */

  this.lens = new utils.Buf16(320);
  /* temporary storage for code lengths */

  this.work = new utils.Buf16(288);
  /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */

  this.lendyn = null;
  /* dynamic table for length/literal codes (JS specific) */

  this.distdyn = null;
  /* dynamic table for distance codes (JS specific) */

  this.sane = 0;
  /* if false, allow invalid distance too far */

  this.back = 0;
  /* bits back of last unprocessed length/lit */

  this.was = 0;
  /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = '';
  /*Z_NULL*/

  if (state.wrap) {
    /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }

  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null
  /*Z_NULL*/
  ;
  state.hold = 0;
  state.bits = 0; //state.lencode = state.distcode = state.next = state.codes;

  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
  state.sane = 1;
  state.back = -1; //Tracev((stderr, "inflate: reset\n"));

  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;
  /* get the state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  /* extract wrap request from windowBits parameter */

  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  } else {
    wrap = (windowBits >> 4) + 1;

    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  /* set number of window bits, free window if different */


  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }

  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  /* update state and reset the rest of it */


  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) {
    return Z_STREAM_ERROR;
  } //strm.msg = Z_NULL;                 /* in case we return an error */


  state = new InflateState(); //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));

  strm.state = state;
  state.window = null
  /*Z_NULL*/
  ;
  ret = inflateReset2(strm, windowBits);

  if (ret !== Z_OK) {
    strm.state = null
    /*Z_NULL*/
    ;
  }

  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}
/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */


var virgin = true;
var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;
    lenfix = new utils.Buf32(512);
    distfix = new utils.Buf32(32);
    /* literal/length table */

    sym = 0;

    while (sym < 144) {
      state.lens[sym++] = 8;
    }

    while (sym < 256) {
      state.lens[sym++] = 9;
    }

    while (sym < 280) {
      state.lens[sym++] = 7;
    }

    while (sym < 288) {
      state.lens[sym++] = 8;
    }

    inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
      bits: 9
    });
    /* distance table */

    sym = 0;

    while (sym < 32) {
      state.lens[sym++] = 5;
    }

    inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
      bits: 5
    });
    /* do this just once */

    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */


function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  /* if it hasn't been done already, allocate space for the window */

  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = new utils.Buf8(state.wsize);
  }
  /* copy state->wsize or less output bytes into the circular window */


  if (copy >= state.wsize) {
    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;

    if (dist > copy) {
      dist = copy;
    } //zmemcpy(state->window + state->wnext, end - copy, dist);


    utils.arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;

    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      utils.arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;

      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }

      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }

  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output; // input/output buffers

  var next;
  /* next input INDEX */

  var put;
  /* next output INDEX */

  var have, left;
  /* available input and output */

  var hold;
  /* bit buffer */

  var bits;
  /* bits in bit buffer */

  var _in, _out;
  /* save starting available input and output */


  var copy;
  /* number of stored or match bytes to copy */

  var from;
  /* where to copy match bytes from */

  var from_source;
  var here = 0;
  /* current decoding table entry */

  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */

  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)

  var len;
  /* length to copy for repeats, bits to drop */

  var ret;
  /* return code */

  var hbuf = new utils.Buf8(4);
  /* buffer for gzip header crc calculation */

  var opts;
  var n; // temporary var for NEED_BITS

  var order =
  /* permutation of code lengths */
  [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];

  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if (state.mode === TYPE) {
    state.mode = TYPEDO;
  }
  /* skip check */
  //--- LOAD() ---


  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits; //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
      case HEAD:
        if (state.wrap === 0) {
          state.mode = TYPEDO;
          break;
        } //=== NEEDBITS(16);


        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.wrap & 2 && hold === 0x8b1f) {
          /* gzip header */
          state.check = 0
          /*crc32(0L, Z_NULL, 0)*/
          ; //=== CRC2(state.check, hold);

          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
          //=== INITBITS();

          hold = 0;
          bits = 0; //===//

          state.mode = FLAGS;
          break;
        }

        state.flags = 0;
        /* expect zlib header */

        if (state.head) {
          state.head.done = false;
        }

        if (!(state.wrap & 1) ||
        /* check if zlib header allowed */
        (((hold & 0xff) <<
        /*BITS(8)*/
        8) + (hold >> 8)) % 31) {
          strm.msg = 'incorrect header check';
          state.mode = BAD;
          break;
        }

        if ((hold & 0x0f) !==
        /*BITS(4)*/
        Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        } //--- DROPBITS(4) ---//


        hold >>>= 4;
        bits -= 4; //---//

        len = (hold & 0x0f) +
        /*BITS(4)*/
        8;

        if (state.wbits === 0) {
          state.wbits = len;
        } else if (len > state.wbits) {
          strm.msg = 'invalid window size';
          state.mode = BAD;
          break;
        }

        state.dmax = 1 << len; //Tracev((stderr, "inflate:   zlib header ok\n"));

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = hold & 0x200 ? DICTID : TYPE; //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        break;

      case FLAGS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.flags = hold;

        if ((state.flags & 0xff) !== Z_DEFLATED) {
          strm.msg = 'unknown compression method';
          state.mode = BAD;
          break;
        }

        if (state.flags & 0xe000) {
          strm.msg = 'unknown header flags set';
          state.mode = BAD;
          break;
        }

        if (state.head) {
          state.head.text = hold >> 8 & 1;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = TIME;

      /* falls through */

      case TIME:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.time = hold;
        }

        if (state.flags & 0x0200) {
          //=== CRC4(state.check, hold)
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          hbuf[2] = hold >>> 16 & 0xff;
          hbuf[3] = hold >>> 24 & 0xff;
          state.check = crc32(state.check, hbuf, 4, 0); //===
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = OS;

      /* falls through */

      case OS:
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if (state.head) {
          state.head.xflags = hold & 0xff;
          state.head.os = hold >> 8;
        }

        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = hold >>> 8 & 0xff;
          state.check = crc32(state.check, hbuf, 2, 0); //===//
        } //=== INITBITS();


        hold = 0;
        bits = 0; //===//

        state.mode = EXLEN;

      /* falls through */

      case EXLEN:
        if (state.flags & 0x0400) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length = hold;

          if (state.head) {
            state.head.extra_len = hold;
          }

          if (state.flags & 0x0200) {
            //=== CRC2(state.check, hold);
            hbuf[0] = hold & 0xff;
            hbuf[1] = hold >>> 8 & 0xff;
            state.check = crc32(state.check, hbuf, 2, 0); //===//
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        } else if (state.head) {
          state.head.extra = null
          /*Z_NULL*/
          ;
        }

        state.mode = EXTRA;

      /* falls through */

      case EXTRA:
        if (state.flags & 0x0400) {
          copy = state.length;

          if (copy > have) {
            copy = have;
          }

          if (copy) {
            if (state.head) {
              len = state.head.extra_len - state.length;

              if (!state.head.extra) {
                // Use untyped array for more convenient processing later
                state.head.extra = new Array(state.head.extra_len);
              }

              utils.arraySet(state.head.extra, input, next, // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len); //zmemcpy(state.head.extra + len, next,
              //        len + copy > state.head.extra_max ?
              //        state.head.extra_max - len : copy);
            }

            if (state.flags & 0x0200) {
              state.check = crc32(state.check, input, copy, next);
            }

            have -= copy;
            next += copy;
            state.length -= copy;
          }

          if (state.length) {
            break inf_leave;
          }
        }

        state.length = 0;
        state.mode = NAME;

      /* falls through */

      case NAME:
        if (state.flags & 0x0800) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            // TODO: 2 or 1 bytes?
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.name_max*/
            ) {
              state.head.name += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.name = null;
        }

        state.length = 0;
        state.mode = COMMENT;

      /* falls through */

      case COMMENT:
        if (state.flags & 0x1000) {
          if (have === 0) {
            break inf_leave;
          }

          copy = 0;

          do {
            len = input[next + copy++];
            /* use constant limit because in js we should not preallocate memory */

            if (state.head && len && state.length < 65536
            /*state.head.comm_max*/
            ) {
              state.head.comment += String.fromCharCode(len);
            }
          } while (len && copy < have);

          if (state.flags & 0x0200) {
            state.check = crc32(state.check, input, copy, next);
          }

          have -= copy;
          next += copy;

          if (len) {
            break inf_leave;
          }
        } else if (state.head) {
          state.head.comment = null;
        }

        state.mode = HCRC;

      /* falls through */

      case HCRC:
        if (state.flags & 0x0200) {
          //=== NEEDBITS(16); */
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.check & 0xffff)) {
            strm.msg = 'header crc mismatch';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
        }

        if (state.head) {
          state.head.hcrc = state.flags >> 9 & 1;
          state.head.done = true;
        }

        strm.adler = state.check = 0;
        state.mode = TYPE;
        break;

      case DICTID:
        //=== NEEDBITS(32); */
        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        strm.adler = state.check = zswap32(hold); //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = DICT;

      /* falls through */

      case DICT:
        if (state.havedict === 0) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          return Z_NEED_DICT;
        }

        strm.adler = state.check = 1
        /*adler32(0L, Z_NULL, 0)*/
        ;
        state.mode = TYPE;

      /* falls through */

      case TYPE:
        if (flush === Z_BLOCK || flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case TYPEDO:
        if (state.last) {
          //--- BYTEBITS() ---//
          hold >>>= bits & 7;
          bits -= bits & 7; //---//

          state.mode = CHECK;
          break;
        } //=== NEEDBITS(3); */


        while (bits < 3) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.last = hold & 0x01
        /*BITS(1)*/
        ; //--- DROPBITS(1) ---//

        hold >>>= 1;
        bits -= 1; //---//

        switch (hold & 0x03) {
          /*BITS(2)*/
          case 0:
            /* stored block */
            //Tracev((stderr, "inflate:     stored block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = STORED;
            break;

          case 1:
            /* fixed block */
            fixedtables(state); //Tracev((stderr, "inflate:     fixed codes block%s\n",
            //        state.last ? " (last)" : ""));

            state.mode = LEN_;
            /* decode codes */

            if (flush === Z_TREES) {
              //--- DROPBITS(2) ---//
              hold >>>= 2;
              bits -= 2; //---//

              break inf_leave;
            }

            break;

          case 2:
            /* dynamic block */
            //Tracev((stderr, "inflate:     dynamic codes block%s\n",
            //        state.last ? " (last)" : ""));
            state.mode = TABLE;
            break;

          case 3:
            strm.msg = 'invalid block type';
            state.mode = BAD;
        } //--- DROPBITS(2) ---//


        hold >>>= 2;
        bits -= 2; //---//

        break;

      case STORED:
        //--- BYTEBITS() ---// /* go to byte boundary */
        hold >>>= bits & 7;
        bits -= bits & 7; //---//
        //=== NEEDBITS(32); */

        while (bits < 32) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        if ((hold & 0xffff) !== (hold >>> 16 ^ 0xffff)) {
          strm.msg = 'invalid stored block lengths';
          state.mode = BAD;
          break;
        }

        state.length = hold & 0xffff; //Tracev((stderr, "inflate:       stored length %u\n",
        //        state.length));
        //=== INITBITS();

        hold = 0;
        bits = 0; //===//

        state.mode = COPY_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case COPY_:
        state.mode = COPY;

      /* falls through */

      case COPY:
        copy = state.length;

        if (copy) {
          if (copy > have) {
            copy = have;
          }

          if (copy > left) {
            copy = left;
          }

          if (copy === 0) {
            break inf_leave;
          } //--- zmemcpy(put, next, copy); ---


          utils.arraySet(output, input, next, copy, put); //---//

          have -= copy;
          next += copy;
          left -= copy;
          put += copy;
          state.length -= copy;
          break;
        } //Tracev((stderr, "inflate:       stored end\n"));


        state.mode = TYPE;
        break;

      case TABLE:
        //=== NEEDBITS(14); */
        while (bits < 14) {
          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8;
        } //===//


        state.nlen = (hold & 0x1f) +
        /*BITS(5)*/
        257; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ndist = (hold & 0x1f) +
        /*BITS(5)*/
        1; //--- DROPBITS(5) ---//

        hold >>>= 5;
        bits -= 5; //---//

        state.ncode = (hold & 0x0f) +
        /*BITS(4)*/
        4; //--- DROPBITS(4) ---//

        hold >>>= 4;
        bits -= 4; //---//
        //#ifndef PKZIP_BUG_WORKAROUND

        if (state.nlen > 286 || state.ndist > 30) {
          strm.msg = 'too many length or distance symbols';
          state.mode = BAD;
          break;
        } //#endif
        //Tracev((stderr, "inflate:       table sizes ok\n"));


        state.have = 0;
        state.mode = LENLENS;

      /* falls through */

      case LENLENS:
        while (state.have < state.ncode) {
          //=== NEEDBITS(3);
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.lens[order[state.have++]] = hold & 0x07; //BITS(3);
          //--- DROPBITS(3) ---//

          hold >>>= 3;
          bits -= 3; //---//
        }

        while (state.have < 19) {
          state.lens[order[state.have++]] = 0;
        } // We have separate tables & no pointers. 2 commented lines below not needed.
        //state.next = state.codes;
        //state.lencode = state.next;
        // Switch to use dynamic table


        state.lencode = state.lendyn;
        state.lenbits = 7;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
        state.lenbits = opts.bits;

        if (ret) {
          strm.msg = 'invalid code lengths set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, "inflate:       code lengths ok\n"));


        state.have = 0;
        state.mode = CODELENS;

      /* falls through */

      case CODELENS:
        while (state.have < state.nlen + state.ndist) {
          for (;;) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            /*BITS(state.lenbits)*/

            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          }

          if (here_val < 16) {
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits; //---//

            state.lens[state.have++] = here_val;
          } else {
            if (here_val === 16) {
              //=== NEEDBITS(here.bits + 2);
              n = here_bits + 2;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              if (state.have === 0) {
                strm.msg = 'invalid bit length repeat';
                state.mode = BAD;
                break;
              }

              len = state.lens[state.have - 1];
              copy = 3 + (hold & 0x03); //BITS(2);
              //--- DROPBITS(2) ---//

              hold >>>= 2;
              bits -= 2; //---//
            } else if (here_val === 17) {
              //=== NEEDBITS(here.bits + 3);
              n = here_bits + 3;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 3 + (hold & 0x07); //BITS(3);
              //--- DROPBITS(3) ---//

              hold >>>= 3;
              bits -= 3; //---//
            } else {
              //=== NEEDBITS(here.bits + 7);
              n = here_bits + 7;

              while (bits < n) {
                if (have === 0) {
                  break inf_leave;
                }

                have--;
                hold += input[next++] << bits;
                bits += 8;
              } //===//
              //--- DROPBITS(here.bits) ---//


              hold >>>= here_bits;
              bits -= here_bits; //---//

              len = 0;
              copy = 11 + (hold & 0x7f); //BITS(7);
              //--- DROPBITS(7) ---//

              hold >>>= 7;
              bits -= 7; //---//
            }

            if (state.have + copy > state.nlen + state.ndist) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }

            while (copy--) {
              state.lens[state.have++] = len;
            }
          }
        }
        /* handle error breaks in while */


        if (state.mode === BAD) {
          break;
        }
        /* check for end-of-block code (better have one) */


        if (state.lens[256] === 0) {
          strm.msg = 'invalid code -- missing end-of-block';
          state.mode = BAD;
          break;
        }
        /* build code tables -- note: do not change the lenbits or distbits
           values here (9 and 6) without reading the comments in inftrees.h
           concerning the ENOUGH constants, which depend on those values */


        state.lenbits = 9;
        opts = {
          bits: state.lenbits
        };
        ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.lenbits = opts.bits; // state.lencode = state.next;

        if (ret) {
          strm.msg = 'invalid literal/lengths set';
          state.mode = BAD;
          break;
        }

        state.distbits = 6; //state.distcode.copy(state.codes);
        // Switch to use dynamic table

        state.distcode = state.distdyn;
        opts = {
          bits: state.distbits
        };
        ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts); // We have separate tables & no pointers. 2 commented lines below not needed.
        // state.next_index = opts.table_index;

        state.distbits = opts.bits; // state.distcode = state.next;

        if (ret) {
          strm.msg = 'invalid distances set';
          state.mode = BAD;
          break;
        } //Tracev((stderr, 'inflate:       codes ok\n'));


        state.mode = LEN_;

        if (flush === Z_TREES) {
          break inf_leave;
        }

      /* falls through */

      case LEN_:
        state.mode = LEN;

      /* falls through */

      case LEN:
        if (have >= 6 && left >= 258) {
          //--- RESTORE() ---
          strm.next_out = put;
          strm.avail_out = left;
          strm.next_in = next;
          strm.avail_in = have;
          state.hold = hold;
          state.bits = bits; //---

          inflate_fast(strm, _out); //--- LOAD() ---

          put = strm.next_out;
          output = strm.output;
          left = strm.avail_out;
          next = strm.next_in;
          input = strm.input;
          have = strm.avail_in;
          hold = state.hold;
          bits = state.bits; //---

          if (state.mode === TYPE) {
            state.back = -1;
          }

          break;
        }

        state.back = 0;

        for (;;) {
          here = state.lencode[hold & (1 << state.lenbits) - 1];
          /*BITS(state.lenbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if (here_op && (here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;
        state.length = here_val;

        if (here_op === 0) {
          //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
          //        "inflate:         literal '%c'\n" :
          //        "inflate:         literal 0x%02x\n", here.val));
          state.mode = LIT;
          break;
        }

        if (here_op & 32) {
          //Tracevv((stderr, "inflate:         end of block\n"));
          state.back = -1;
          state.mode = TYPE;
          break;
        }

        if (here_op & 64) {
          strm.msg = 'invalid literal/length code';
          state.mode = BAD;
          break;
        }

        state.extra = here_op & 15;
        state.mode = LENEXT;

      /* falls through */

      case LENEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.length += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //Tracevv((stderr, "inflate:         length %u\n", state.length));


        state.was = state.length;
        state.mode = DIST;

      /* falls through */

      case DIST:
        for (;;) {
          here = state.distcode[hold & (1 << state.distbits) - 1];
          /*BITS(state.distbits)*/

          here_bits = here >>> 24;
          here_op = here >>> 16 & 0xff;
          here_val = here & 0xffff;

          if (here_bits <= bits) {
            break;
          } //--- PULLBYTE() ---//


          if (have === 0) {
            break inf_leave;
          }

          have--;
          hold += input[next++] << bits;
          bits += 8; //---//
        }

        if ((here_op & 0xf0) === 0) {
          last_bits = here_bits;
          last_op = here_op;
          last_val = here_val;

          for (;;) {
            here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >>
            /*BITS(last.bits + last.op)*/
            last_bits)];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 0xff;
            here_val = here & 0xffff;

            if (last_bits + here_bits <= bits) {
              break;
            } //--- PULLBYTE() ---//


            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8; //---//
          } //--- DROPBITS(last.bits) ---//


          hold >>>= last_bits;
          bits -= last_bits; //---//

          state.back += last_bits;
        } //--- DROPBITS(here.bits) ---//


        hold >>>= here_bits;
        bits -= here_bits; //---//

        state.back += here_bits;

        if (here_op & 64) {
          strm.msg = 'invalid distance code';
          state.mode = BAD;
          break;
        }

        state.offset = here_val;
        state.extra = here_op & 15;
        state.mode = DISTEXT;

      /* falls through */

      case DISTEXT:
        if (state.extra) {
          //=== NEEDBITS(state.extra);
          n = state.extra;

          while (bits < n) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          state.offset += hold & (1 << state.extra) - 1
          /*BITS(state.extra)*/
          ; //--- DROPBITS(state.extra) ---//

          hold >>>= state.extra;
          bits -= state.extra; //---//

          state.back += state.extra;
        } //#ifdef INFLATE_STRICT


        if (state.offset > state.dmax) {
          strm.msg = 'invalid distance too far back';
          state.mode = BAD;
          break;
        } //#endif
        //Tracevv((stderr, "inflate:         distance %u\n", state.offset));


        state.mode = MATCH;

      /* falls through */

      case MATCH:
        if (left === 0) {
          break inf_leave;
        }

        copy = _out - left;

        if (state.offset > copy) {
          /* copy from window */
          copy = state.offset - copy;

          if (copy > state.whave) {
            if (state.sane) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break;
            } // (!) This block is disabled in zlib defaults,
            // don't enable it for binary compatibility
            //#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            //          Trace((stderr, "inflate.c too far\n"));
            //          copy -= state.whave;
            //          if (copy > state.length) { copy = state.length; }
            //          if (copy > left) { copy = left; }
            //          left -= copy;
            //          state.length -= copy;
            //          do {
            //            output[put++] = 0;
            //          } while (--copy);
            //          if (state.length === 0) { state.mode = LEN; }
            //          break;
            //#endif

          }

          if (copy > state.wnext) {
            copy -= state.wnext;
            from = state.wsize - copy;
          } else {
            from = state.wnext - copy;
          }

          if (copy > state.length) {
            copy = state.length;
          }

          from_source = state.window;
        } else {
          /* copy from output */
          from_source = output;
          from = put - state.offset;
          copy = state.length;
        }

        if (copy > left) {
          copy = left;
        }

        left -= copy;
        state.length -= copy;

        do {
          output[put++] = from_source[from++];
        } while (--copy);

        if (state.length === 0) {
          state.mode = LEN;
        }

        break;

      case LIT:
        if (left === 0) {
          break inf_leave;
        }

        output[put++] = state.length;
        left--;
        state.mode = LEN;
        break;

      case CHECK:
        if (state.wrap) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--; // Use '|' instead of '+' to make sure that result is signed

            hold |= input[next++] << bits;
            bits += 8;
          } //===//


          _out -= left;
          strm.total_out += _out;
          state.total += _out;

          if (_out) {
            strm.adler = state.check =
            /*UPDATE(state.check, put - _out, _out);*/
            state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
          }

          _out = left; // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too

          if ((state.flags ? hold : zswap32(hold)) !== state.check) {
            strm.msg = 'incorrect data check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   check matches trailer\n"));
        }

        state.mode = LENGTH;

      /* falls through */

      case LENGTH:
        if (state.wrap && state.flags) {
          //=== NEEDBITS(32);
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }

            have--;
            hold += input[next++] << bits;
            bits += 8;
          } //===//


          if (hold !== (state.total & 0xffffffff)) {
            strm.msg = 'incorrect length check';
            state.mode = BAD;
            break;
          } //=== INITBITS();


          hold = 0;
          bits = 0; //===//
          //Tracev((stderr, "inflate:   length matches trailer\n"));
        }

        state.mode = DONE;

      /* falls through */

      case DONE:
        ret = Z_STREAM_END;
        break inf_leave;

      case BAD:
        ret = Z_DATA_ERROR;
        break inf_leave;

      case MEM:
        return Z_MEM_ERROR;

      case SYNC:
      /* falls through */

      default:
        return Z_STREAM_ERROR;
    }
  } // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */
  //--- RESTORE() ---


  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits; //---

  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }

  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;

  if (state.wrap && _out) {
    strm.adler = state.check =
    /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }

  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);

  if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }

  return ret;
}

function inflateEnd(strm) {
  if (!strm || !strm.state
  /*|| strm->zfree == (free_func)0*/
  ) {
      return Z_STREAM_ERROR;
    }

  var state = strm.state;

  if (state.window) {
    state.window = null;
  }

  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;
  /* check state */

  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;

  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR;
  }
  /* save header structure */


  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  /* check state */

  if (!strm
  /* == Z_NULL */
  || !strm.state
  /* == Z_NULL */
  ) {
      return Z_STREAM_ERROR;
    }

  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }
  /* check for correct dictionary identifier */


  if (state.mode === DICT) {
    dictid = 1;
    /* adler32(0, null, 0)*/

    /* dictid = adler32(dictid, dictionary, dictLength); */

    dictid = adler32(dictid, dictionary, dictLength, 0);

    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */


  ret = updatewindow(strm, dictionary, dictLength, dictLength);

  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }

  state.havedict = 1; // Tracev((stderr, "inflate:   dictionary set\n"));

  return Z_OK;
}

exports.inflateReset = inflateReset;
exports.inflateReset2 = inflateReset2;
exports.inflateResetKeep = inflateResetKeep;
exports.inflateInit = inflateInit;
exports.inflateInit2 = inflateInit2;
exports.inflate = inflate;
exports.inflateEnd = inflateEnd;
exports.inflateGetHeader = inflateGetHeader;
exports.inflateSetDictionary = inflateSetDictionary;
exports.inflateInfo = 'pako inflate (from Nodeca project)';
/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/

/***/ }),

/***/ "../node_modules/pako/lib/zlib/inftrees.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");

var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592; //var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
/* Length codes 257..285 base */
3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0];
var lext = [
/* Length codes 257..285 extra */
16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78];
var dbase = [
/* Distance codes 0..29 base */
1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0];
var dext = [
/* Distance codes 0..29 extra */
16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];

module.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits; //here = opts.here; /* table entry for duplication */

  var len = 0;
  /* a code's length in bits */

  var sym = 0;
  /* index of code symbols */

  var min = 0,
      max = 0;
  /* minimum and maximum code lengths */

  var root = 0;
  /* number of index bits for root table */

  var curr = 0;
  /* number of index bits for current table */

  var drop = 0;
  /* code bits to drop for sub-table */

  var left = 0;
  /* number of prefix codes available */

  var used = 0;
  /* code entries in table used */

  var huff = 0;
  /* Huffman code */

  var incr;
  /* for incrementing code, index */

  var fill;
  /* index for replicating entries */

  var low;
  /* low bits for current root entry */

  var mask;
  /* mask for low root bits */

  var next;
  /* next available space in table */

  var base = null;
  /* base value table to use */

  var base_index = 0; //  var shoextra;    /* extra bits table to use */

  var end;
  /* use base and extra for symbol > end */

  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */

  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */

  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.
    This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.
    The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.
    The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */

  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }

  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  /* bound code lengths, force root to be within code lengths */


  root = bits;

  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) {
      break;
    }
  }

  if (root > max) {
    root = max;
  }

  if (max === 0) {
    /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0; //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;

    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
    /* no symbols, but wait for decoding to report error */
  }

  for (min = 1; min < max; min++) {
    if (count[min] !== 0) {
      break;
    }
  }

  if (root < min) {
    root = min;
  }
  /* check for an over-subscribed or incomplete set of lengths */


  left = 1;

  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];

    if (left < 0) {
      return -1;
    }
    /* over-subscribed */

  }

  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;
    /* incomplete set */
  }
  /* generate offsets into symbol table for each length for sorting */


  offs[1] = 0;

  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  /* sort symbols by length, by symbol order within each length */


  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.
    root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.
    When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.
    used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.
    sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8


  if (type === CODES) {
    base = extra = work;
    /* dummy value--not used */

    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }
  /* initialize opts for loop */


  huff = 0;
  /* starting code */

  sym = 0;
  /* starting code symbol */

  len = min;
  /* starting code length */

  next = table_index;
  /* current table to fill in */

  curr = root;
  /* current table index bits */

  drop = 0;
  /* current bits to drop from code for index */

  low = -1;
  /* trigger new sub-table when len > root */

  used = 1 << root;
  /* use root table entries */

  mask = used - 1;
  /* mask for comparing low */

  /* check available table space */

  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  /* process all codes and make table entries */


  for (;;) {
    /* create table entry */
    here_bits = len - drop;

    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      /* end of block */

      here_val = 0;
    }
    /* replicate for those indices with low len bits equal to huff */


    incr = 1 << len - drop;
    fill = 1 << curr;
    min = fill;
    /* save offset to next table */

    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    /* backwards increment the len-bit code huff */


    incr = 1 << len - 1;

    while (huff & incr) {
      incr >>= 1;
    }

    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    /* go to next symbol, update count, len */


    sym++;

    if (--count[len] === 0) {
      if (len === max) {
        break;
      }

      len = lens[lens_index + work[sym]];
    }
    /* create new sub-table if needed */


    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }
      /* increment past last table */


      next += min;
      /* here min is 1 << curr */

      /* determine length of next table */

      curr = len - drop;
      left = 1 << curr;

      while (curr + drop < max) {
        left -= count[curr + drop];

        if (left <= 0) {
          break;
        }

        curr++;
        left <<= 1;
      }
      /* check for enough space */


      used += 1 << curr;

      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      /* point entry in root table to sub-table */


      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/

      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */


  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  /* set return parameters */
  //opts.table_index += used;


  opts.bits = root;
  return 0;
};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/messages.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

module.exports = {
  2: 'need dictionary',

  /* Z_NEED_DICT       2  */
  1: 'stream end',

  /* Z_STREAM_END      1  */
  0: '',

  /* Z_OK              0  */
  '-1': 'file error',

  /* Z_ERRNO         (-1) */
  '-2': 'stream error',

  /* Z_STREAM_ERROR  (-2) */
  '-3': 'data error',

  /* Z_DATA_ERROR    (-3) */
  '-4': 'insufficient memory',

  /* Z_MEM_ERROR     (-4) */
  '-5': 'buffer error',

  /* Z_BUF_ERROR     (-5) */
  '-6': 'incompatible version'
  /* Z_VERSION_ERROR (-6) */

};

/***/ }),

/***/ "../node_modules/pako/lib/zlib/trees.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

/* eslint-disable space-unary-ops */

var utils = __webpack_require__("../node_modules/pako/lib/utils/common.js");
/* Public constants ==========================================================*/

/* ===========================================================================*/
//var Z_FILTERED          = 1;
//var Z_HUFFMAN_ONLY      = 2;
//var Z_RLE               = 3;


var Z_FIXED = 4; //var Z_DEFAULT_STRATEGY  = 0;

/* Possible values of the data_type field (though see inflate()) */

var Z_BINARY = 0;
var Z_TEXT = 1; //var Z_ASCII             = 1; // = Z_TEXT

var Z_UNKNOWN = 2;
/*============================================================================*/

function zero(buf) {
  var len = buf.length;

  while (--len >= 0) {
    buf[len] = 0;
  }
} // From zutil.h


var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
/* The three kinds of block type */

var MIN_MATCH = 3;
var MAX_MATCH = 258;
/* The minimum and maximum match lengths */
// From deflate.h

/* ===========================================================================
 * Internal compression state.
 */

var LENGTH_CODES = 29;
/* number of length codes, not counting the special END_BLOCK code */

var LITERALS = 256;
/* number of literal bytes 0..255 */

var L_CODES = LITERALS + 1 + LENGTH_CODES;
/* number of Literal or Length codes, including the END_BLOCK code */

var D_CODES = 30;
/* number of distance codes */

var BL_CODES = 19;
/* number of codes used to transfer the bit lengths */

var HEAP_SIZE = 2 * L_CODES + 1;
/* maximum heap size */

var MAX_BITS = 15;
/* All codes must not exceed MAX_BITS bits */

var Buf_size = 16;
/* size of bit buffer in bi_buf */

/* ===========================================================================
 * Constants
 */

var MAX_BL_BITS = 7;
/* Bit length codes must not exceed MAX_BL_BITS bits */

var END_BLOCK = 256;
/* end of block literal code */

var REP_3_6 = 16;
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

var REPZ_3_10 = 17;
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

var REPZ_11_138 = 18;
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

/* eslint-disable comma-spacing,array-bracket-spacing */

var extra_lbits =
/* extra bits for each length code */
[0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
var extra_dbits =
/* extra bits for each distance code */
[0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
var extra_blbits =
/* extra bits for each bit length code */
[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
/* eslint-enable comma-spacing,array-bracket-spacing */

/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */
// We pre-fill arrays with 0 to avoid uninitialized gaps

var DIST_CODE_LEN = 512;
/* see definition of array dist_code below */
// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1

var static_ltree = new Array((L_CODES + 2) * 2);
zero(static_ltree);
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

var static_dtree = new Array(D_CODES * 2);
zero(static_dtree);
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

var _dist_code = new Array(DIST_CODE_LEN);

zero(_dist_code);
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);

zero(_length_code);
/* length code for each normalized match length (0 == MIN_MATCH) */

var base_length = new Array(LENGTH_CODES);
zero(base_length);
/* First normalized length for each code (0 = MIN_MATCH) */

var base_dist = new Array(D_CODES);
zero(base_dist);
/* First normalized distance for each code (0 = distance of 1) */

function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  /* static tree or NULL */

  this.extra_bits = extra_bits;
  /* extra bits for each code or NULL */

  this.extra_base = extra_base;
  /* base index for extra_bits */

  this.elems = elems;
  /* max number of elements in the tree */

  this.max_length = max_length;
  /* max bit length for the codes */
  // show if `static_tree` has data or dummy - needed for monomorphic objects

  this.has_stree = static_tree && static_tree.length;
}

var static_l_desc;
var static_d_desc;
var static_bl_desc;

function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  /* the dynamic tree */

  this.max_code = 0;
  /* largest code with non zero frequency */

  this.stat_desc = stat_desc;
  /* the corresponding static tree */
}

function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */


function put_short(s, w) {
  //    put_byte(s, (uch)((w) & 0xff));
  //    put_byte(s, (uch)((ush)(w) >> 8));
  s.pending_buf[s.pending++] = w & 0xff;
  s.pending_buf[s.pending++] = w >>> 8 & 0xff;
}
/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */


function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 0xffff;
    s.bi_valid += length;
  }
}

function send_code(s, c, tree) {
  send_bits(s, tree[c * 2]
  /*.Code*/
  , tree[c * 2 + 1]
  /*.Len*/
  );
}
/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */


function bi_reverse(code, len) {
  var res = 0;

  do {
    res |= code & 1;
    code >>>= 1;
    res <<= 1;
  } while (--len > 0);

  return res >>> 1;
}
/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */


function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 0xff;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */


function gen_bitlen(s, desc) //    deflate_state *s;
//    tree_desc *desc;    /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  /* heap index */

  var n, m;
  /* iterate over the tree elements */

  var bits;
  /* bit length */

  var xbits;
  /* extra bits */

  var f;
  /* frequency */

  var overflow = 0;
  /* number of elements with bit length too large */

  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  /* In a first pass, compute the optimal bit lengths (which may
   * overflow in the case of the bit length tree).
   */


  tree[s.heap[s.heap_max] * 2 + 1]
  /*.Len*/
  = 0;
  /* root of the heap */

  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1]
    /*.Dad*/
    * 2 + 1]
    /*.Len*/
    + 1;

    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }

    tree[n * 2 + 1]
    /*.Len*/
    = bits;
    /* We overwrite tree[n].Dad which is no longer needed */

    if (n > max_code) {
      continue;
    }
    /* not a leaf node */


    s.bl_count[bits]++;
    xbits = 0;

    if (n >= base) {
      xbits = extra[n - base];
    }

    f = tree[n * 2]
    /*.Freq*/
    ;
    s.opt_len += f * (bits + xbits);

    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1]
      /*.Len*/
      + xbits);
    }
  }

  if (overflow === 0) {
    return;
  } // Trace((stderr,"\nbit length overflow\n"));

  /* This happens for example on obj2 and pic of the Calgary corpus */

  /* Find the first bit length which could increase: */


  do {
    bits = max_length - 1;

    while (s.bl_count[bits] === 0) {
      bits--;
    }

    s.bl_count[bits]--;
    /* move one leaf down the tree */

    s.bl_count[bits + 1] += 2;
    /* move one overflow item as its brother */

    s.bl_count[max_length]--;
    /* The brother of the overflow item also moves one step up,
     * but this does not affect bl_count[max_length]
     */

    overflow -= 2;
  } while (overflow > 0);
  /* Now recompute all bit lengths, scanning in increasing frequency.
   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
   * lengths instead of fixing only the wrong ones. This idea is taken
   * from 'ar' written by Haruhiko Okumura.)
   */


  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];

    while (n !== 0) {
      m = s.heap[--h];

      if (m > max_code) {
        continue;
      }

      if (tree[m * 2 + 1]
      /*.Len*/
      !== bits) {
        // Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
        s.opt_len += (bits - tree[m * 2 + 1]
        /*.Len*/
        ) * tree[m * 2]
        /*.Freq*/
        ;
        tree[m * 2 + 1]
        /*.Len*/
        = bits;
      }

      n--;
    }
  }
}
/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */


function gen_codes(tree, max_code, bl_count) //    ct_data *tree;             /* the tree to decorate */
//    int max_code;              /* largest code with non zero frequency */
//    ushf *bl_count;            /* number of codes at each bit length */
{
  var next_code = new Array(MAX_BITS + 1);
  /* next code value for each bit length */

  var code = 0;
  /* running code value */

  var bits;
  /* bit index */

  var n;
  /* code index */

  /* The distribution counts are first used to generate the code values
   * without bit reversal.
   */

  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code = code + bl_count[bits - 1] << 1;
  }
  /* Check that the bit counts in bl_count are consistent. The last code
   * must be all ones.
   */
  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
  //        "inconsistent bit counts");
  //Tracev((stderr,"\ngen_codes: max_code %d ", max_code));


  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1]
    /*.Len*/
    ;

    if (len === 0) {
      continue;
    }
    /* Now reverse the bits */


    tree[n * 2]
    /*.Code*/
    = bi_reverse(next_code[len]++, len); //Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
  }
}
/* ===========================================================================
 * Initialize the various 'constant' tables.
 */


function tr_static_init() {
  var n;
  /* iterates over tree elements */

  var bits;
  /* bit counter */

  var length;
  /* length value */

  var code;
  /* code value */

  var dist;
  /* distance index */

  var bl_count = new Array(MAX_BITS + 1);
  /* number of codes at each bit length for an optimal tree */
  // do check in _tr_init()
  //if (static_init_done) return;

  /* For some embedded targets, global variables are not initialized: */

  /*#ifdef NO_INIT_GLOBAL_POINTERS
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;
  #endif*/

  /* Initialize the mapping length (0..255) -> length code (0..28) */

  length = 0;

  for (code = 0; code < LENGTH_CODES - 1; code++) {
    base_length[code] = length;

    for (n = 0; n < 1 << extra_lbits[code]; n++) {
      _length_code[length++] = code;
    }
  } //Assert (length == 256, "tr_static_init: length != 256");

  /* Note that the length 255 (match length 258) can be represented
   * in two different ways: code 284 + 5 bits or code 285, so we
   * overwrite length_code[255] to use the best encoding:
   */


  _length_code[length - 1] = code;
  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */

  dist = 0;

  for (code = 0; code < 16; code++) {
    base_dist[code] = dist;

    for (n = 0; n < 1 << extra_dbits[code]; n++) {
      _dist_code[dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: dist != 256");


  dist >>= 7;
  /* from now on, all distances are divided by 128 */

  for (; code < D_CODES; code++) {
    base_dist[code] = dist << 7;

    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
      _dist_code[256 + dist++] = code;
    }
  } //Assert (dist == 256, "tr_static_init: 256+dist != 512");

  /* Construct the codes of the static literal tree */


  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }

  n = 0;

  while (n <= 143) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }

  while (n <= 255) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 9;
    n++;
    bl_count[9]++;
  }

  while (n <= 279) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 7;
    n++;
    bl_count[7]++;
  }

  while (n <= 287) {
    static_ltree[n * 2 + 1]
    /*.Len*/
    = 8;
    n++;
    bl_count[8]++;
  }
  /* Codes 286 and 287 do not exist, but we must include them in the
   * tree construction to get a canonical Huffman tree (longest code
   * all ones)
   */


  gen_codes(static_ltree, L_CODES + 1, bl_count);
  /* The static distance tree is trivial: */

  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1]
    /*.Len*/
    = 5;
    static_dtree[n * 2]
    /*.Code*/
    = bi_reverse(n, 5);
  } // Now data ready and we can init static trees


  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS); //static_init_done = true;
}
/* ===========================================================================
 * Initialize a new block.
 */


function init_block(s) {
  var n;
  /* iterates over tree elements */

  /* Initialize the trees. */

  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2]
    /*.Freq*/
    = 0;
  }

  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2]
    /*.Freq*/
    = 0;
  }

  s.dyn_ltree[END_BLOCK * 2]
  /*.Freq*/
  = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */


function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    //put_byte(s, (Byte)s->bi_buf);
    s.pending_buf[s.pending++] = s.bi_buf;
  }

  s.bi_buf = 0;
  s.bi_valid = 0;
}
/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */


function copy_block(s, buf, len, header) //DeflateState *s;
//charf    *buf;    /* the input data */
//unsigned len;     /* its length */
//int      header;  /* true if block header must be written */
{
  bi_windup(s);
  /* align on byte boundary */

  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  } //  while (len--) {
  //    put_byte(s, *buf++);
  //  }


  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */


function smaller(tree, n, m, depth) {
  var _n2 = n * 2;

  var _m2 = m * 2;

  return tree[_n2]
  /*.Freq*/
  < tree[_m2]
  /*.Freq*/
  || tree[_n2]
  /*.Freq*/
  === tree[_m2]
  /*.Freq*/
  && depth[n] <= depth[m];
}
/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */


function pqdownheap(s, tree, k) //    deflate_state *s;
//    ct_data *tree;  /* the tree to restore */
//    int k;               /* node to move down */
{
  var v = s.heap[k];
  var j = k << 1;
  /* left son of k */

  while (j <= s.heap_len) {
    /* Set j to the smallest of the two sons: */
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    /* Exit if v is smaller than both sons */


    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    /* Exchange v with the smallest son */


    s.heap[k] = s.heap[j];
    k = j;
    /* And continue down the tree, setting j to the left son of k */

    j <<= 1;
  }

  s.heap[k] = v;
} // inlined manually
// var SMALLEST = 1;

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */


function compress_block(s, ltree, dtree) //    deflate_state *s;
//    const ct_data *ltree; /* literal tree */
//    const ct_data *dtree; /* distance tree */
{
  var dist;
  /* distance of matched string */

  var lc;
  /* match length or unmatched char (if dist == 0) */

  var lx = 0;
  /* running index in l_buf */

  var code;
  /* the code to send */

  var extra;
  /* number of extra bits to send */

  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;

      if (dist === 0) {
        send_code(s, lc, ltree);
        /* send a literal byte */
        //Tracecv(isgraph(lc), (stderr," '%c' ", lc));
      } else {
        /* Here, lc is the match length - MIN_MATCH */
        code = _length_code[lc];
        send_code(s, code + LITERALS + 1, ltree);
        /* send the length code */

        extra = extra_lbits[code];

        if (extra !== 0) {
          lc -= base_length[code];
          send_bits(s, lc, extra);
          /* send the extra length bits */
        }

        dist--;
        /* dist is now the match distance - 1 */

        code = d_code(dist); //Assert (code < D_CODES, "bad d_code");

        send_code(s, code, dtree);
        /* send the distance code */

        extra = extra_dbits[code];

        if (extra !== 0) {
          dist -= base_dist[code];
          send_bits(s, dist, extra);
          /* send the extra distance bits */
        }
      }
      /* literal or match pair ? */

      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,
      //       "pendingBuf overflow");

    } while (lx < s.last_lit);
  }

  send_code(s, END_BLOCK, ltree);
}
/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */


function build_tree(s, desc) //    deflate_state *s;
//    tree_desc *desc; /* the tree descriptor */
{
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  /* iterate over heap elements */

  var max_code = -1;
  /* largest code with non zero frequency */

  var node;
  /* new node being created */

  /* Construct the initial heap, with least frequent element in
   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
   * heap[0] is not used.
   */

  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;

  for (n = 0; n < elems; n++) {
    if (tree[n * 2]
    /*.Freq*/
    !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1]
      /*.Len*/
      = 0;
    }
  }
  /* The pkzip format requires that at least one distance code exists,
   * and that at least one bit should be sent even if there is only one
   * possible code. So to avoid special checks later on we force at least
   * two codes of non zero frequency.
   */


  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2]
    /*.Freq*/
    = 1;
    s.depth[node] = 0;
    s.opt_len--;

    if (has_stree) {
      s.static_len -= stree[node * 2 + 1]
      /*.Len*/
      ;
    }
    /* node is 0 or 1 so it does not have extra bits */

  }

  desc.max_code = max_code;
  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
   * establish sub-heaps of increasing lengths:
   */

  for (n = s.heap_len >> 1
  /*int /2*/
  ; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  /* Construct the Huffman tree by repeatedly combining the least two
   * frequent nodes.
   */


  node = elems;
  /* next internal node of the tree */

  do {
    //pqremove(s, tree, n);  /* n = node of least frequency */

    /*** pqremove ***/
    n = s.heap[1
    /*SMALLEST*/
    ];
    s.heap[1
    /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
    /***/

    m = s.heap[1
    /*SMALLEST*/
    ];
    /* m = node of next least frequency */

    s.heap[--s.heap_max] = n;
    /* keep the nodes sorted by frequency */

    s.heap[--s.heap_max] = m;
    /* Create a new node father of n and m */

    tree[node * 2]
    /*.Freq*/
    = tree[n * 2]
    /*.Freq*/
    + tree[m * 2]
    /*.Freq*/
    ;
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1]
    /*.Dad*/
    = tree[m * 2 + 1]
    /*.Dad*/
    = node;
    /* and insert the new node in the heap */

    s.heap[1
    /*SMALLEST*/
    ] = node++;
    pqdownheap(s, tree, 1
    /*SMALLEST*/
    );
  } while (s.heap_len >= 2);

  s.heap[--s.heap_max] = s.heap[1
  /*SMALLEST*/
  ];
  /* At this point, the fields freq and dad are set. We can now
   * generate the bit lengths.
   */

  gen_bitlen(s, desc);
  /* The field len is now set, we can generate the bit codes */

  gen_codes(tree, max_code, s.bl_count);
}
/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */


function scan_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree;   /* the tree to be scanned */
//    int max_code;    /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  tree[(max_code + 1) * 2 + 1]
  /*.Len*/
  = 0xffff;
  /* guard */

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2]
      /*.Freq*/
      += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2] /*.Freq*/++;
      }

      s.bl_tree[REP_3_6 * 2] /*.Freq*/++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++;
    } else {
      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++;
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */


function send_tree(s, tree, max_code) //    deflate_state *s;
//    ct_data *tree; /* the tree to be scanned */
//    int max_code;       /* and its largest code of non zero frequency */
{
  var n;
  /* iterates over all tree elements */

  var prevlen = -1;
  /* last emitted length */

  var curlen;
  /* length of current code */

  var nextlen = tree[0 * 2 + 1]
  /*.Len*/
  ;
  /* length of next code */

  var count = 0;
  /* repeat count of the current code */

  var max_count = 7;
  /* max repeat count */

  var min_count = 4;
  /* min repeat count */

  /* tree[max_code+1].Len = -1; */

  /* guard already set */

  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }

  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1]
    /*.Len*/
    ;

    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      } //Assert(count >= 3 && count <= 6, " 3_6?");


      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }

    count = 0;
    prevlen = curlen;

    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */


function build_bl_tree(s) {
  var max_blindex;
  /* index of last bit length code of non zero freq */

  /* Determine the bit length frequencies for literal and distance trees */

  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  /* Build the bit length tree: */

  build_tree(s, s.bl_desc);
  /* opt_len now includes the length of the tree representations, except
   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
   */

  /* Determine the number of bit length codes to send. The pkzip format
   * requires that at least 4 bit length codes be sent. (appnote.txt says
   * 3 but the actual value used is 4.)
   */

  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]
    /*.Len*/
    !== 0) {
      break;
    }
  }
  /* Update opt_len to include the bit length tree and counts */


  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4; //Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
  //        s->opt_len, s->static_len));

  return max_blindex;
}
/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */


function send_all_trees(s, lcodes, dcodes, blcodes) //    deflate_state *s;
//    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
  var rank;
  /* index in bl_order */
  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
  //        "too many codes");
  //Tracev((stderr, "\nbl counts: "));

  send_bits(s, lcodes - 257, 5);
  /* not +255 as stated in appnote.txt */

  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  /* not -3 as stated in appnote.txt */

  for (rank = 0; rank < blcodes; rank++) {
    //Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]
    /*.Len*/
    , 3);
  } //Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));


  send_tree(s, s.dyn_ltree, lcodes - 1);
  /* literal tree */
  //Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

  send_tree(s, s.dyn_dtree, dcodes - 1);
  /* distance tree */
  //Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}
/* ===========================================================================
 * Check if the data type is TEXT or BINARY, using the following algorithm:
 * - TEXT if the two conditions below are satisfied:
 *    a) There are no non-portable control characters belonging to the
 *       "black list" (0..6, 14..25, 28..31).
 *    b) There is at least one printable character belonging to the
 *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).
 * - BINARY otherwise.
 * - The following partially-portable control characters form a
 *   "gray list" that is ignored in this detection algorithm:
 *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).
 * IN assertion: the fields Freq of dyn_ltree are set.
 */


function detect_data_type(s) {
  /* black_mask is the bit mask of black-listed bytes
   * set bits 0..6, 14..25, and 28..31
   * 0xf3ffc07f = binary 11110011111111111100000001111111
   */
  var black_mask = 0xf3ffc07f;
  var n;
  /* Check for non-textual ("black-listed") bytes. */

  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_BINARY;
    }
  }
  /* Check for textual ("white-listed") bytes. */


  if (s.dyn_ltree[9 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[10 * 2]
  /*.Freq*/
  !== 0 || s.dyn_ltree[13 * 2]
  /*.Freq*/
  !== 0) {
    return Z_TEXT;
  }

  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2]
    /*.Freq*/
    !== 0) {
      return Z_TEXT;
    }
  }
  /* There are no "black-listed" or "white-listed" bytes:
   * this stream either is empty or has tolerated ("gray-listed") bytes only.
   */


  return Z_BINARY;
}

var static_init_done = false;
/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */

function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }

  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  /* Initialize the first block of the first file: */

  init_block(s);
}
/* ===========================================================================
 * Send a stored block
 */


function _tr_stored_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);
  /* send block type */

  copy_block(s, buf, stored_len, true);
  /* with header */
}
/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 */


function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */


function _tr_flush_block(s, buf, stored_len, last) //DeflateState *s;
//charf *buf;       /* input block, or NULL if too old */
//ulg stored_len;   /* length of input block */
//int last;         /* one if this is the last block for a file */
{
  var opt_lenb, static_lenb;
  /* opt_len and static_len in bytes */

  var max_blindex = 0;
  /* index of last bit length code of non zero freq */

  /* Build the Huffman trees unless a stored block is forced */

  if (s.level > 0) {
    /* Check if the file is binary or text */
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    /* Construct the literal and distance trees */


    build_tree(s, s.l_desc); // Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    build_tree(s, s.d_desc); // Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
    //        s->static_len));

    /* At this point, opt_len and static_len are the total bit lengths of
     * the compressed block data, excluding the tree representations.
     */

    /* Build the bit length tree for the above two trees, and get the index
     * in bl_order of the last bit length code to send.
     */

    max_blindex = build_bl_tree(s);
    /* Determine the best encoding. Compute the block lengths in bytes. */

    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3; // Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
    //        s->last_lit));

    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    // Assert(buf != (char*)0, "lost buf");
    opt_lenb = static_lenb = stored_len + 5;
    /* force a stored block */
  }

  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    /* 4: two words for the lengths */

    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
     * Otherwise we can't have processed more than WSIZE input bytes since
     * the last block flush, because compression would have been
     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
     * transform a block into a stored block.
     */
    _tr_stored_block(s, buf, stored_len, last);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  } // Assert (s->compressed_len == s->bits_sent, "bad compressed size");

  /* The above check is made mod 2^32, for files larger than 512 MB
   * and uLong implemented on 32 bits.
   */


  init_block(s);

  if (last) {
    bi_windup(s);
  } // Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
  //       s->compressed_len-7*last));

}
/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */


function _tr_tally(s, dist, lc) //    deflate_state *s;
//    unsigned dist;  /* distance of matched string */
//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
  //var out_length, in_length, dcode;
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 0xff;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;
  s.last_lit++;

  if (dist === 0) {
    /* lc is the unmatched char */
    s.dyn_ltree[lc * 2] /*.Freq*/++;
  } else {
    s.matches++;
    /* Here, lc is the match length - MIN_MATCH */

    dist--;
    /* dist = match distance - 1 */
    //Assert((ush)dist < (ush)MAX_DIST(s) &&
    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++;
    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++;
  } // (!) This block is disabled in zlib defaults,
  // don't enable it for binary compatibility
  //#ifdef TRUNCATE_BLOCK
  //  /* Try to guess if it is profitable to stop the current block here */
  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {
  //    /* Compute an upper bound for the compressed length */
  //    out_length = s.last_lit*8;
  //    in_length = s.strstart - s.block_start;
  //
  //    for (dcode = 0; dcode < D_CODES; dcode++) {
  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);
  //    }
  //    out_length >>>= 3;
  //    //Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
  //    //       s->last_lit, in_length, out_length,
  //    //       100L - out_length*100L/in_length));
  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {
  //      return true;
  //    }
  //  }
  //#endif


  return s.last_lit === s.lit_bufsize - 1;
  /* We avoid equality with lit_bufsize because of wraparound at 64K
   * on 16 bit machines and because stored blocks are restricted to
   * 64K-1 bytes.
   */
}

exports._tr_init = _tr_init;
exports._tr_stored_block = _tr_stored_block;
exports._tr_flush_block = _tr_flush_block;
exports._tr_tally = _tr_tally;
exports._tr_align = _tr_align;

/***/ }),

/***/ "../node_modules/pako/lib/zlib/zstream.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // (C) 1995-2013 Jean-loup Gailly and Mark Adler
// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin
//
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//   claim that you wrote the original software. If you use this software
//   in a product, an acknowledgment in the product documentation would be
//   appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//   misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers

  this.next_in = 0;
  /* number of bytes available at input */

  this.avail_in = 0;
  /* total number of input bytes read so far */

  this.total_in = 0;
  /* next output byte should be put there */

  this.output = null; // JS specific, because we have no pointers

  this.next_out = 0;
  /* remaining free space at output */

  this.avail_out = 0;
  /* total number of bytes output so far */

  this.total_out = 0;
  /* last error message, NULL if no error */

  this.msg = ''
  /*Z_NULL*/
  ;
  /* not visible by applications */

  this.state = null;
  /* best guess about the data type: binary or text */

  this.data_type = 2
  /*Z_UNKNOWN*/
  ;
  /* adler32 value of the uncompressed data */

  this.adler = 0;
}

module.exports = ZStream;

/***/ }),

/***/ "../node_modules/process-nextick-args/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


if (typeof global.process === 'undefined' || !global.process.version || global.process.version.indexOf('v0.') === 0 || global.process.version.indexOf('v1.') === 0 && global.process.version.indexOf('v1.8.') !== 0) {
  module.exports = {
    nextTick: nextTick
  };
} else {
  module.exports = global.process;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }

  var len = arguments.length;
  var args, i;

  switch (len) {
    case 0:
    case 1:
      return global.process.nextTick(fn);

    case 2:
      return global.process.nextTick(function afterTickOne() {
        fn.call(null, arg1);
      });

    case 3:
      return global.process.nextTick(function afterTickTwo() {
        fn.call(null, arg1, arg2);
      });

    case 4:
      return global.process.nextTick(function afterTickThree() {
        fn.call(null, arg1, arg2, arg3);
      });

    default:
      args = new Array(len - 1);
      i = 0;

      while (i < args.length) {
        args[i++] = arguments[i];
      }

      return global.process.nextTick(function afterTick() {
        fn.apply(null, args);
      });
  }
}

/***/ }),

/***/ "../node_modules/punycode/punycode.js":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports =  true && exports && !exports.nodeType && exports;
  var freeModule =  true && module && !module.nodeType && module;
  var freeGlobal = typeof global == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (;
    /* no initialization */
    delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;)
    /* no final expression */
    {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;;
      /* no condition */
      k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;;
          /* no condition */
          k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/webpack/buildin/module.js")(module), __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/querystring-es3/decode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

/***/ }),

/***/ "../node_modules/querystring-es3/encode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (isArray(obj[k])) {
        return map(obj[k], function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map(xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];

  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }

  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }

  return res;
};

/***/ }),

/***/ "../node_modules/querystring-es3/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__("../node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__("../node_modules/querystring-es3/encode.js");

/***/ }),

/***/ "../node_modules/readable-stream/duplex.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/readable.js").Duplex;

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_duplex.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var pna = __webpack_require__("../node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/


var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;
/*<replacement>*/

var util = Object.create(__webpack_require__("../node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

var Readable = __webpack_require__("../node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);
{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  if (options && options.readable === false) this.readable = false;
  if (options && options.writable === false) this.writable = false;
  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // the no-half-open enforcer

function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();
  pna.nextTick(cb, err);
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_passthrough.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__("../node_modules/readable-stream/lib/_stream_transform.js");
/*<replacement>*/


var util = Object.create(__webpack_require__("../node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_readable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var pna = __webpack_require__("../node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Readable;
/*<replacement>*/

var isArray = __webpack_require__("../node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/


var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = __webpack_require__("../node_modules/events/events.js").EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__("../node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__("../node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/


var util = Object.create(__webpack_require__("../node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/

var debugUtil = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

var debug = void 0;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__("../node_modules/readable-stream/lib/internal/streams/BufferList.js");

var destroyImpl = __webpack_require__("../node_modules/readable-stream/lib/internal/streams/destroy.js");

var StringDecoder;
util.inherits(Readable, Stream);
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__("../node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options);
  this._readableState = new ReadableState(options, this); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  return er;
} // if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.


function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__("../node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
}; // Don't raise the hwm > 8MB


var MAX_HWM = 0x800000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true; // emit 'readable' now to make sure it gets picked up.

  emitReadable(stream);
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;

  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;else len = state.length;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== global.process.stdout && dest !== global.process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  } // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.


  var increasedAwaitDrain = false;
  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);

    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;

    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;

      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }

  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {}
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList; // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }
  return ret;
} // Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function fromListPartial(n, list, hasStrings) {
  var ret;

  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }

  return ret;
} // Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;

  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;

    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
} // Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.


function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;

  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;

    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }

      break;
    }

    ++c;
  }

  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState; // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.

  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_transform.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
/*<replacement>*/


var util = Object.create(__webpack_require__("../node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);

    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
  return stream.push(null);
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/_stream_writable.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

/*<replacement>*/

var pna = __webpack_require__("../node_modules/process-nextick-args/index.js");
/*</replacement>*/


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var asyncWrite = !global.process.browser && ['v0.10', 'v0.9.'].indexOf(global.process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/

var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var util = Object.create(__webpack_require__("../node_modules/core-util-is/lib/util.js"));
util.inherits = __webpack_require__("../node_modules/inherits/inherits.js");
/*</replacement>*/

/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__("../node_modules/util-deprecate/node.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__("../node_modules/readable-stream/lib/internal/streams/stream.js");
/*</replacement>*/

/*<replacement>*/


var Buffer = __webpack_require__("../node_modules/safe-buffer/index.js").Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/


var destroyImpl = __webpack_require__("../node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  var isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm; // cast to ints.

  this.highWaterMark = Math.floor(this.highWaterMark); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.

  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end'); // TODO: defer error events consistently everywhere, not just the cb

  stream.emit('error', er);
  pna.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }

  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }

  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;
  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      stream.emit('error', err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }

  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("../node_modules/nativescript-dev-webpack/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/BufferList.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

var Buffer = __webpack_require__("../node_modules/safe-buffer/index.js").Buffer;

var util = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js");

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = {
      data: v,
      next: null
    };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = {
      data: v,
      next: this.head
    };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;

    while (p = p.next) {
      ret += s + p.data;
    }

    return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;

    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }

    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({
      length: this.length
    });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/destroy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*<replacement>*/

var pna = __webpack_require__("../node_modules/process-nextick-args/index.js");
/*</replacement>*/
// undocumented cb() API, needed for core, not for public API


function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);

      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "../node_modules/readable-stream/lib/internal/streams/stream.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/stream-browserify/index.js");

/***/ }),

/***/ "../node_modules/readable-stream/passthrough.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/readable.js").PassThrough;

/***/ }),

/***/ "../node_modules/readable-stream/readable.js":
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__("../node_modules/stream-browserify/index.js");

if (global.process.env.READABLE_STREAM === 'disable' && Stream) {
  module.exports = Stream;
  exports = module.exports = Stream.Readable;
  exports.Readable = Stream.Readable;
  exports.Writable = Stream.Writable;
  exports.Duplex = Stream.Duplex;
  exports.Transform = Stream.Transform;
  exports.PassThrough = Stream.PassThrough;
  exports.Stream = Stream;
} else {
  exports = module.exports = __webpack_require__("../node_modules/readable-stream/lib/_stream_readable.js");
  exports.Stream = Stream || exports;
  exports.Readable = exports;
  exports.Writable = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");
  exports.Duplex = __webpack_require__("../node_modules/readable-stream/lib/_stream_duplex.js");
  exports.Transform = __webpack_require__("../node_modules/readable-stream/lib/_stream_transform.js");
  exports.PassThrough = __webpack_require__("../node_modules/readable-stream/lib/_stream_passthrough.js");
}

/***/ }),

/***/ "../node_modules/readable-stream/transform.js":
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__("../node_modules/readable-stream/readable.js").Transform;

/***/ }),

/***/ "../node_modules/readable-stream/writable.js":
/***/ (function(module, exports, __webpack_require__) {

var Stream = __webpack_require__("../node_modules/stream-browserify/index.js");

var Writable = __webpack_require__("../node_modules/readable-stream/lib/_stream_writable.js");

if (global.process.env.READABLE_STREAM === 'disable') {
  module.exports = Stream && Stream.Writable || Writable;
} else {
  module.exports = Writable;
}

/***/ }),

/***/ "../node_modules/safe-buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__("../node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
} // Copy static methods from Buffer


copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "../node_modules/stream-browserify/index.js":
/***/ (function(module, exports, __webpack_require__) {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
module.exports = Stream;

var EE = __webpack_require__("../node_modules/events/events.js").EventEmitter;

var inherits = __webpack_require__("../node_modules/inherits/inherits.js");

inherits(Stream, EE);
Stream.Readable = __webpack_require__("../node_modules/readable-stream/readable.js");
Stream.Writable = __webpack_require__("../node_modules/readable-stream/writable.js");
Stream.Duplex = __webpack_require__("../node_modules/readable-stream/duplex.js");
Stream.Transform = __webpack_require__("../node_modules/readable-stream/transform.js");
Stream.PassThrough = __webpack_require__("../node_modules/readable-stream/passthrough.js"); // Backwards-compat with node 0.4.x

Stream.Stream = Stream; // old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function (dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain); // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.

  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;

  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;
    dest.end();
  }

  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;
    if (typeof dest.destroy === 'function') dest.destroy();
  } // don't leave dangling pipes when there are errors.


  function onerror(er) {
    cleanup();

    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror); // remove all the event listeners that were added.

  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);
    source.removeListener('end', onend);
    source.removeListener('close', onclose);
    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);
    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);
    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);
  dest.on('close', cleanup);
  dest.emit('pipe', source); // Allow for unix-like usage: A.pipe(B).pipe(C)

  return dest;
};

/***/ }),

/***/ "../node_modules/string_decoder/lib/string_decoder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = __webpack_require__("../node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "../node_modules/supports-color/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var os = __webpack_require__("../node_modules/os-browserify/browser.js");

var hasFlag = __webpack_require__("../node_modules/has-flag/index.js");

var env = process.env;
var forceColor;

if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
  forceColor = false;
} else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
  forceColor = true;
}

if ('FORCE_COLOR' in env) {
  forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
}

function translateLevel(level) {
  if (level === 0) {
    return false;
  }

  return {
    level,
    hasBasic: true,
    has256: level >= 2,
    has16m: level >= 3
  };
}

function supportsColor(stream) {
  if (forceColor === false) {
    return 0;
  }

  if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
    return 3;
  }

  if (hasFlag('color=256')) {
    return 2;
  }

  if (stream && !stream.isTTY && forceColor !== true) {
    return 0;
  }

  var min = forceColor ? 1 : 0;

  if (global.process.platform === 'win32') {
    // Node.js 7.5.0 is the first version of Node.js to include a patch to
    // libuv that enables 256 color output on Windows. Anything earlier and it
    // won't work. However, here we target Node.js 8 at minimum as it is an LTS
    // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
    // release that supports 256 colors. Windows 10 build 14931 is the first release
    // that supports 16m/TrueColor.
    var osRelease = os.release().split('.');

    if (Number(global.process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
      return Number(osRelease[2]) >= 14931 ? 3 : 2;
    }

    return 1;
  }

  if ('CI' in env) {
    if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
      return 1;
    }

    return min;
  }

  if ('TEAMCITY_VERSION' in env) {
    return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
  }

  if (env.COLORTERM === 'truecolor') {
    return 3;
  }

  if ('TERM_PROGRAM' in env) {
    var version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

    switch (env.TERM_PROGRAM) {
      case 'iTerm.app':
        return version >= 3 ? 3 : 2;

      case 'Apple_Terminal':
        return 2;
      // No default
    }
  }

  if (/-256(color)?$/i.test(env.TERM)) {
    return 2;
  }

  if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
    return 1;
  }

  if ('COLORTERM' in env) {
    return 1;
  }

  if (env.TERM === 'dumb') {
    return min;
  }

  return min;
}

function getSupportLevel(stream) {
  var level = supportsColor(stream);
  return translateLevel(level);
}

module.exports = {
  supportsColor: getSupportLevel,
  stdout: getSupportLevel(global.process.stdout),
  stderr: getSupportLevel(global.process.stderr)
};

/***/ }),

/***/ "../node_modules/tty-browserify/index.js":
/***/ (function(module, exports) {

exports.isatty = function () {
  return false;
};

function ReadStream() {
  throw new Error('tty.ReadStream is not implemented');
}

exports.ReadStream = ReadStream;

function WriteStream() {
  throw new Error('tty.ReadStream is not implemented');
}

exports.WriteStream = WriteStream;

/***/ }),

/***/ "../node_modules/url/url.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


var punycode = __webpack_require__("../node_modules/punycode/punycode.js");

var util = __webpack_require__("../node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__("../node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "../node_modules/url/util.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return typeof arg === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "../node_modules/util-deprecate/node.js":
/***/ (function(module, exports, __webpack_require__) {

/**
 * For Node.js, simply re-export the core `util.deprecate` function.
 */
module.exports = __webpack_require__("../node_modules/node-libs-browser/node_modules/util/util.js").deprecate;

/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ })

})
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2Fzc2VydC9hc3NlcnQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy9odHRwLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL2xpYi9iaW5kaW5nLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS16bGliL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2NvcmUtdXRpbC1pcy9saWIvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9ub2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2ZvbGxvdy1yZWRpcmVjdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9oYXMtZmxhZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL2h0dHBzLWJyb3dzZXJpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvbm9kZS1saWJzLWJyb3dzZXIvbm9kZV9tb2R1bGVzL3V0aWwvc3VwcG9ydC9pc0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL25vZGUtbGlicy1icm93c2VyL25vZGVfbW9kdWxlcy91dGlsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9vcy1icm93c2VyaWZ5L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2FkbGVyMzIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2RlZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmZhc3QuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZmxhdGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcGFrby9saWIvemxpYi9tZXNzYWdlcy5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3Bha28vbGliL3psaWIvdHJlZXMuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wYWtvL2xpYi96bGliL3pzdHJlYW0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L2luZGV4LmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc3RyaW5nX2RlY29kZXIvbGliL3N0cmluZ19kZWNvZGVyLmpzIiwid2VicGFjazovLy8uLi9ub2RlX21vZHVsZXMvc3VwcG9ydHMtY29sb3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy90dHktYnJvd3NlcmlmeS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi4vbm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL25vZGUuanMiLCJ3ZWJwYWNrOi8vLy4uL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vbW9kdWxlLmpzIl0sIm5hbWVzIjpbImNvbXBhcmUiLCJhIiwiYiIsIngiLCJsZW5ndGgiLCJ5IiwiaSIsImxlbiIsIk1hdGgiLCJtaW4iLCJpc0J1ZmZlciIsImdsb2JhbCIsIkJ1ZmZlciIsIl9pc0J1ZmZlciIsInV0aWwiLCJyZXF1aXJlIiwiaGFzT3duIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwU2xpY2UiLCJBcnJheSIsInNsaWNlIiwiZnVuY3Rpb25zSGF2ZU5hbWVzIiwiZm9vIiwibmFtZSIsInBUb1N0cmluZyIsIm9iaiIsInRvU3RyaW5nIiwiY2FsbCIsImlzVmlldyIsImFycmJ1ZiIsIkFycmF5QnVmZmVyIiwiRGF0YVZpZXciLCJidWZmZXIiLCJhc3NlcnQiLCJtb2R1bGUiLCJleHBvcnRzIiwib2siLCJyZWdleCIsImdldE5hbWUiLCJmdW5jIiwiaXNGdW5jdGlvbiIsInN0ciIsIm1hdGNoIiwiQXNzZXJ0aW9uRXJyb3IiLCJvcHRpb25zIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcGVyYXRvciIsIm1lc3NhZ2UiLCJnZW5lcmF0ZWRNZXNzYWdlIiwiZ2V0TWVzc2FnZSIsInN0YWNrU3RhcnRGdW5jdGlvbiIsImZhaWwiLCJFcnJvciIsImNhcHR1cmVTdGFja1RyYWNlIiwiZXJyIiwic3RhY2siLCJvdXQiLCJmbl9uYW1lIiwiaWR4IiwiaW5kZXhPZiIsIm5leHRfbGluZSIsInN1YnN0cmluZyIsImluaGVyaXRzIiwidHJ1bmNhdGUiLCJzIiwibiIsImluc3BlY3QiLCJzb21ldGhpbmciLCJyYXduYW1lIiwic2VsZiIsInZhbHVlIiwiZXF1YWwiLCJub3RFcXVhbCIsImRlZXBFcXVhbCIsIl9kZWVwRXF1YWwiLCJkZWVwU3RyaWN0RXF1YWwiLCJzdHJpY3QiLCJtZW1vcyIsImlzRGF0ZSIsImdldFRpbWUiLCJpc1JlZ0V4cCIsInNvdXJjZSIsIm11bHRpbGluZSIsImxhc3RJbmRleCIsImlnbm9yZUNhc2UiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJVaW50OEFycmF5IiwiYWN0dWFsSW5kZXgiLCJwdXNoIiwib2JqRXF1aXYiLCJpc0FyZ3VtZW50cyIsIm9iamVjdCIsImFjdHVhbFZpc2l0ZWRPYmplY3RzIiwidW5kZWZpbmVkIiwiaXNQcmltaXRpdmUiLCJnZXRQcm90b3R5cGVPZiIsImFJc0FyZ3MiLCJiSXNBcmdzIiwia2EiLCJvYmplY3RLZXlzIiwia2IiLCJrZXkiLCJzb3J0Iiwibm90RGVlcEVxdWFsIiwibm90RGVlcFN0cmljdEVxdWFsIiwic3RyaWN0RXF1YWwiLCJub3RTdHJpY3RFcXVhbCIsImV4cGVjdGVkRXhjZXB0aW9uIiwidGVzdCIsImUiLCJpc1Byb3RvdHlwZU9mIiwiX3RyeUJsb2NrIiwiYmxvY2siLCJlcnJvciIsIl90aHJvd3MiLCJzaG91bGRUaHJvdyIsIlR5cGVFcnJvciIsInVzZXJQcm92aWRlZE1lc3NhZ2UiLCJpc1Vud2FudGVkRXhjZXB0aW9uIiwiaXNFcnJvciIsImlzVW5leHBlY3RlZEV4Y2VwdGlvbiIsInRocm93cyIsImRvZXNOb3RUaHJvdyIsImlmRXJyb3IiLCJrZXlzIiwidXRpbHMiLCJzZXR0bGUiLCJidWlsZEZ1bGxQYXRoIiwiYnVpbGRVUkwiLCJodHRwIiwiaHR0cHMiLCJodHRwRm9sbG93IiwiaHR0cHNGb2xsb3ciLCJ1cmwiLCJ6bGliIiwicGtnIiwiY3JlYXRlRXJyb3IiLCJlbmhhbmNlRXJyb3IiLCJpc0h0dHBzIiwiaHR0cEFkYXB0ZXIiLCJjb25maWciLCJQcm9taXNlIiwiZGlzcGF0Y2hIdHRwUmVxdWVzdCIsInJlc29sdmVQcm9taXNlIiwicmVqZWN0UHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJkYXRhIiwiaGVhZGVycyIsInZlcnNpb24iLCJpc1N0cmVhbSIsImlzQXJyYXlCdWZmZXIiLCJmcm9tIiwiaXNTdHJpbmciLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImZ1bGxQYXRoIiwiYmFzZVVSTCIsInBhcnNlZCIsInBhcnNlIiwicHJvdG9jb2wiLCJ1cmxBdXRoIiwic3BsaXQiLCJ1cmxVc2VybmFtZSIsInVybFBhc3N3b3JkIiwiQXV0aG9yaXphdGlvbiIsImlzSHR0cHNSZXF1ZXN0IiwiYWdlbnQiLCJodHRwc0FnZW50IiwiaHR0cEFnZW50IiwicGF0aCIsInBhcmFtcyIsInBhcmFtc1NlcmlhbGl6ZXIiLCJyZXBsYWNlIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJhZ2VudHMiLCJzb2NrZXRQYXRoIiwiaG9zdG5hbWUiLCJwb3J0IiwicHJveHkiLCJwcm94eUVudiIsInByb3h5VXJsIiwicHJvY2VzcyIsImVudiIsInBhcnNlZFByb3h5VXJsIiwibm9Qcm94eUVudiIsIm5vX3Byb3h5IiwiTk9fUFJPWFkiLCJzaG91bGRQcm94eSIsIm5vUHJveHkiLCJtYXAiLCJ0cmltIiwic29tZSIsInByb3h5TWF0Y2giLCJwcm94eUVsZW1lbnQiLCJzdWJzdHIiLCJob3N0IiwicHJveHlVcmxBdXRoIiwiYmFzZTY0IiwidHJhbnNwb3J0IiwiaXNIdHRwc1Byb3h5IiwibWF4UmVkaXJlY3RzIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJyZXEiLCJyZXF1ZXN0IiwiaGFuZGxlUmVzcG9uc2UiLCJyZXMiLCJhYm9ydGVkIiwic3RyZWFtIiwic3RhdHVzQ29kZSIsInBpcGUiLCJjcmVhdGVVbnppcCIsImxhc3RSZXF1ZXN0IiwicmVzcG9uc2UiLCJzdGF0dXMiLCJzdGF0dXNUZXh0Iiwic3RhdHVzTWVzc2FnZSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlQnVmZmVyIiwib24iLCJoYW5kbGVTdHJlYW1EYXRhIiwiY2h1bmsiLCJjb25jYXQiLCJkZXN0cm95IiwiaGFuZGxlU3RyZWFtRXJyb3IiLCJoYW5kbGVTdHJlYW1FbmQiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZUVuY29kaW5nIiwiaGFuZGxlUmVxdWVzdEVycm9yIiwidGltZW91dCIsInNldFRpbWVvdXQiLCJoYW5kbGVSZXF1ZXN0VGltZW91dCIsImFib3J0IiwiY2FuY2VsVG9rZW4iLCJwcm9taXNlIiwidGhlbiIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJlbmQiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJ4aHJBZGFwdGVyIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsImlzRm9ybURhdGEiLCJYTUxIdHRwUmVxdWVzdCIsImJ0b2EiLCJvcGVuIiwib25yZWFkeXN0YXRlY2hhbmdlIiwiaGFuZGxlTG9hZCIsInJlYWR5U3RhdGUiLCJyZXNwb25zZVVSTCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlVGV4dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJjb29raWVzIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwieHNyZkNvb2tpZU5hbWUiLCJyZWFkIiwieHNyZkhlYWRlck5hbWUiLCJmb3JFYWNoIiwic2V0UmVxdWVzdEhlYWRlciIsInZhbCIsInRvTG93ZXJDYXNlIiwiaXNVbmRlZmluZWQiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsInNlbmQiLCJiaW5kIiwiQXhpb3MiLCJtZXJnZUNvbmZpZyIsImRlZmF1bHRzIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiY29udGV4dCIsImluc3RhbmNlIiwiZXh0ZW5kIiwiYXhpb3MiLCJjcmVhdGUiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImRlZmF1bHQiLCJfX0NBTkNFTF9fIiwiZXhlY3V0b3IiLCJwcm9taXNlRXhlY3V0b3IiLCJ0b2tlbiIsInJlYXNvbiIsInRocm93SWZSZXF1ZXN0ZWQiLCJjIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwiaW50ZXJjZXB0b3JzIiwiYXJndW1lbnRzIiwiY2hhaW4iLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwidW5zaGlmdCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwic2hpZnQiLCJnZXRVcmkiLCJmb3JFYWNoTWV0aG9kTm9EYXRhIiwibWVyZ2UiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJoYW5kbGVycyIsInVzZSIsImVqZWN0IiwiaWQiLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsInJlcXVlc3RlZFVSTCIsImNvZGUiLCJ0cmFuc2Zvcm1EYXRhIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsInRyYW5zZm9ybVJlcXVlc3QiLCJjb21tb24iLCJjbGVhbkhlYWRlckNvbmZpZyIsImFkYXB0ZXIiLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJpc0F4aW9zRXJyb3IiLCJ0b0pTT04iLCJkZXNjcmlwdGlvbiIsIm51bWJlciIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsImNvbmZpZzEiLCJjb25maWcyIiwidmFsdWVGcm9tQ29uZmlnMktleXMiLCJtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyIsImRlZmF1bHRUb0NvbmZpZzJLZXlzIiwidmFsdWVGcm9tQ29uZmlnMiIsInByb3AiLCJtZXJnZURlZXBQcm9wZXJ0aWVzIiwiaXNPYmplY3QiLCJkZWVwTWVyZ2UiLCJkZWZhdWx0VG9Db25maWcyIiwiYXhpb3NLZXlzIiwib3RoZXJLZXlzIiwiZmlsdGVyIiwiZmlsdGVyQXhpb3NLZXlzIiwib3RoZXJLZXlzRGVmYXVsdFRvQ29uZmlnMiIsInZhbGlkYXRlU3RhdHVzIiwiZm5zIiwidHJhbnNmb3JtIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwiZ2V0RGVmYXVsdEFkYXB0ZXIiLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0FycmF5QnVmZmVyVmlldyIsImlzVVJMU2VhcmNoUGFyYW1zIiwiSlNPTiIsInN0cmluZ2lmeSIsInRoaXNBcmciLCJ3cmFwIiwiYXJncyIsImFwcGx5IiwiZW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50Iiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnRzIiwic2VyaWFsaXplIiwiaXNBcnJheSIsInBhcnNlVmFsdWUiLCJ2IiwidG9JU09TdHJpbmciLCJqb2luIiwiaGFzaG1hcmtJbmRleCIsInJlbGF0aXZlVVJMIiwic3RhbmRhcmRCcm93c2VyRW52Iiwid3JpdGUiLCJleHBpcmVzIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwiaXNOdW1iZXIiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJkb2N1bWVudCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXJzaW5nTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInNldEF0dHJpYnV0ZSIsInNlYXJjaCIsImhhc2giLCJwYXRobmFtZSIsImNoYXJBdCIsIndpbmRvdyIsImxvY2F0aW9uIiwicmVxdWVzdFVSTCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VyIiwibGluZSIsImNhbGxiYWNrIiwiYXJyIiwiY29uc3RydWN0b3IiLCJGb3JtRGF0YSIsInJlc3VsdCIsIlVSTFNlYXJjaFBhcmFtcyIsInByb2R1Y3QiLCJsIiwiYXNzaWduVmFsdWUiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwiY2hhckNvZGVBdCIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiWnN0cmVhbSIsInpsaWJfZGVmbGF0ZSIsInpsaWJfaW5mbGF0ZSIsImNvbnN0YW50cyIsIk5PTkUiLCJERUZMQVRFIiwiSU5GTEFURSIsIkdaSVAiLCJHVU5aSVAiLCJERUZMQVRFUkFXIiwiSU5GTEFURVJBVyIsIlVOWklQIiwiR1pJUF9IRUFERVJfSUQxIiwiR1pJUF9IRUFERVJfSUQyIiwiWmxpYiIsIm1vZGUiLCJkaWN0aW9uYXJ5IiwiZmx1c2giLCJpbml0X2RvbmUiLCJsZXZlbCIsIm1lbUxldmVsIiwic3RyYXRlZ3kiLCJ3aW5kb3dCaXRzIiwid3JpdGVfaW5fcHJvZ3Jlc3MiLCJwZW5kaW5nX2Nsb3NlIiwiZ3ppcF9pZF9ieXRlc19yZWFkIiwiY2xvc2UiLCJkZWZsYXRlRW5kIiwic3RybSIsImluZmxhdGVFbmQiLCJpbnB1dCIsImluX29mZiIsImluX2xlbiIsIm91dF9vZmYiLCJvdXRfbGVuIiwiX3dyaXRlIiwid3JpdGVTeW5jIiwiYXN5bmMiLCJaX05PX0ZMVVNIIiwiWl9QQVJUSUFMX0ZMVVNIIiwiWl9TWU5DX0ZMVVNIIiwiWl9GVUxMX0ZMVVNIIiwiWl9GSU5JU0giLCJaX0JMT0NLIiwiYWxsb2MiLCJhdmFpbF9pbiIsIm5leHRfaW4iLCJhdmFpbF9vdXQiLCJuZXh0X291dCIsIl9wcm9jZXNzIiwiX2NoZWNrRXJyb3IiLCJfYWZ0ZXJTeW5jIiwibmV4dFRpY2siLCJfYWZ0ZXIiLCJuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlIiwiZGVmbGF0ZSIsImluZmxhdGUiLCJaX05FRURfRElDVCIsImluZmxhdGVTZXREaWN0aW9uYXJ5IiwiWl9PSyIsIlpfREFUQV9FUlJPUiIsIlpfU1RSRUFNX0VORCIsInJlc2V0IiwiWl9CVUZfRVJST1IiLCJfZXJyb3IiLCJtc2ciLCJpbml0IiwiWl9GSUxURVJFRCIsIlpfSFVGRk1BTl9PTkxZIiwiWl9STEUiLCJaX0ZJWEVEIiwiWl9ERUZBVUxUX1NUUkFURUdZIiwiX2luaXQiLCJfc2V0RGljdGlvbmFyeSIsIl9yZXNldCIsImRlZmxhdGVJbml0MiIsIlpfREVGTEFURUQiLCJpbmZsYXRlSW5pdDIiLCJkZWZsYXRlU2V0RGljdGlvbmFyeSIsImRlZmxhdGVSZXNldCIsImluZmxhdGVSZXNldCIsIlRyYW5zZm9ybSIsImJpbmRpbmciLCJrTWF4TGVuZ3RoIiwia1JhbmdlRXJyb3JNZXNzYWdlIiwiWl9NSU5fV0lORE9XQklUUyIsIlpfTUFYX1dJTkRPV0JJVFMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsIlpfTUlOX0NIVU5LIiwiWl9NQVhfQ0hVTksiLCJJbmZpbml0eSIsIlpfREVGQVVMVF9DSFVOSyIsIlpfTUlOX01FTUxFVkVMIiwiWl9NQVhfTUVNTEVWRUwiLCJaX0RFRkFVTFRfTUVNTEVWRUwiLCJaX01JTl9MRVZFTCIsIlpfTUFYX0xFVkVMIiwiWl9ERUZBVUxUX0xFVkVMIiwiWl9ERUZBVUxUX0NPTVBSRVNTSU9OIiwiYmtleXMiLCJiayIsImJrZXkiLCJkZWZpbmVQcm9wZXJ0eSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImNvZGVzIiwiWl9FUlJOTyIsIlpfU1RSRUFNX0VSUk9SIiwiWl9NRU1fRVJST1IiLCJaX1ZFUlNJT05fRVJST1IiLCJja2V5cyIsImNrIiwiY2tleSIsImZyZWV6ZSIsIkRlZmxhdGUiLCJJbmZsYXRlIiwiR3ppcCIsIkd1bnppcCIsIkRlZmxhdGVSYXciLCJJbmZsYXRlUmF3IiwiVW56aXAiLCJjcmVhdGVEZWZsYXRlIiwibyIsImNyZWF0ZUluZmxhdGUiLCJjcmVhdGVEZWZsYXRlUmF3IiwiY3JlYXRlSW5mbGF0ZVJhdyIsImNyZWF0ZUd6aXAiLCJjcmVhdGVHdW56aXAiLCJvcHRzIiwiemxpYkJ1ZmZlciIsImRlZmxhdGVTeW5jIiwiemxpYkJ1ZmZlclN5bmMiLCJnemlwIiwiZ3ppcFN5bmMiLCJkZWZsYXRlUmF3IiwiZGVmbGF0ZVJhd1N5bmMiLCJ1bnppcCIsInVuemlwU3luYyIsImluZmxhdGVTeW5jIiwiZ3VuemlwIiwiZ3VuemlwU3luYyIsImluZmxhdGVSYXciLCJpbmZsYXRlUmF3U3luYyIsImVuZ2luZSIsImJ1ZmZlcnMiLCJucmVhZCIsIm9uRXJyb3IiLCJvbkVuZCIsImZsb3ciLCJvbmNlIiwicmVtb3ZlTGlzdGVuZXIiLCJidWYiLCJSYW5nZUVycm9yIiwiZmx1c2hGbGFnIiwiX2ZpbmlzaEZsdXNoRmxhZyIsIl9wcm9jZXNzQ2h1bmsiLCJpc1ZhbGlkRmx1c2hGbGFnIiwiZmxhZyIsIl90aGlzIiwiX29wdHMiLCJfY2h1bmtTaXplIiwiY2h1bmtTaXplIiwiZmluaXNoRmx1c2giLCJfZmx1c2hGbGFnIiwiX2hhbmRsZSIsIl9oYWRFcnJvciIsImVycm5vIiwiX2Nsb3NlIiwiZW1pdCIsIl9idWZmZXIiLCJhbGxvY1Vuc2FmZSIsIl9vZmZzZXQiLCJfbGV2ZWwiLCJfc3RyYXRlZ3kiLCJnZXQiLCJjb25maWd1cmFibGUiLCJfZmx1c2giLCJfdHJhbnNmb3JtIiwia2luZCIsIl90aGlzMiIsIndzIiwiX3dyaXRhYmxlU3RhdGUiLCJlbmRlZCIsImVuZGluZyIsIm5lZWREcmFpbiIsImVtaXRDbG9zZU5UIiwiZW5jb2RpbmciLCJjYiIsImxhc3QiLCJhdmFpbEluQmVmb3JlIiwiYXZhaWxPdXRCZWZvcmUiLCJpbk9mZiIsImVyIiwiYXZhaWxJbkFmdGVyIiwiYXZhaWxPdXRBZnRlciIsImhhdmUiLCJuZXdSZXEiLCJpZWVlNzU0IiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwiX19wcm90b19fIiwic3ViYXJyYXkiLCJjcmVhdGVCdWZmZXIiLCJ0aGF0IiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsInBvb2xTaXplIiwiX2F1Z21lbnQiLCJmcm9tQXJyYXlCdWZmZXIiLCJmcm9tU3RyaW5nIiwiZnJvbU9iamVjdCIsIlN5bWJvbCIsInNwZWNpZXMiLCJhc3NlcnRTaXplIiwic2l6ZSIsImZpbGwiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImJ5dGVPZmZzZXQiLCJjb3B5IiwiaXNuYW4iLCJ0eXBlIiwiU3RyaW5nIiwibGlzdCIsInBvcyIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwiaGV4U2xpY2UiLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJtIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwiZXF1YWxzIiwibWF4IiwidGFyZ2V0IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiaXNOYU4iLCJhcnJheUluZGV4T2YiLCJsYXN0SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwib2Zmc2V0IiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwicGFyc2VJbnQiLCJ1dGY4V3JpdGUiLCJibGl0QnVmZmVyIiwiYXNjaWlXcml0ZSIsImFzY2lpVG9CeXRlcyIsImxhdGluMVdyaXRlIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiX2FyciIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJ0b0hleCIsImJ5dGVzIiwibmV3QnVmIiwic2xpY2VMZW4iLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVSW50TEUiLCJub0Fzc2VydCIsIm11bCIsInJlYWRVSW50QkUiLCJyZWFkVUludDgiLCJyZWFkVUludDE2TEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVUludDMyQkUiLCJyZWFkSW50TEUiLCJwb3ciLCJyZWFkSW50QkUiLCJyZWFkSW50OCIsInJlYWRJbnQxNkxFIiwicmVhZEludDE2QkUiLCJyZWFkSW50MzJMRSIsInJlYWRJbnQzMkJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVSW50TEUiLCJtYXhCeXRlcyIsIndyaXRlVUludEJFIiwid3JpdGVVSW50OCIsImZsb29yIiwib2JqZWN0V3JpdGVVSW50MTYiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZVVJbnQxNkxFIiwid3JpdGVVSW50MTZCRSIsIm9iamVjdFdyaXRlVUludDMyIiwid3JpdGVVSW50MzJMRSIsIndyaXRlVUludDMyQkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsInNldCIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJzdHJpbmd0cmltIiwidW5pdHMiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5IiwiaGkiLCJsbyIsInNyYyIsImRzdCIsIm9iamVjdFRvU3RyaW5nIiwiaXNCb29sZWFuIiwiaXNOdWxsIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJpc1N5bWJvbCIsInJlIiwiZCIsIl90eXBlb2YiLCJpdGVyYXRvciIsImxvZyIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJjb2xvcnMiLCJfX253anMiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJjb25zb2xlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsInRhYmxlIiwiJDEiLCJuYW1lc3BhY2UiLCJodW1hbml6ZSIsImRpZmYiLCJjb2xvciIsInNwbGljZSIsImluZGV4IiwibGFzdEMiLCJfY29uc29sZSIsIm5hbWVzcGFjZXMiLCJzZXRJdGVtIiwicmVtb3ZlSXRlbSIsInIiLCJnZXRJdGVtIiwiREVCVUciLCJsb2NhbFN0b3JhZ2UiLCJmb3JtYXR0ZXJzIiwic2V0dXAiLCJjcmVhdGVEZWJ1ZyIsImRlYnVnIiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJpbnN0YW5jZXMiLCJuYW1lcyIsInNraXBzIiwic2VsZWN0Q29sb3IiLCJhYnMiLCJwcmV2VGltZSIsIl9sZW4iLCJfa2V5IiwiY3VyciIsIm1zIiwicHJldiIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwiZGVsaW1pdGVyIiwiYnJvd3NlciIsInR0eSIsInN1cHBvcnRzQ29sb3IiLCJzdGRlcnIiLCJpbnNwZWN0T3B0cyIsInJlZHVjZSIsIl8iLCJrIiwiQm9vbGVhbiIsImlzYXR0eSIsImZkIiwiY29sb3JDb2RlIiwicHJlZml4IiwiZ2V0RGF0ZSIsImhpZGVEYXRlIiwiTyIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJGdW5jdGlvbiIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwid2FybiIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwic2V0TWF4TGlzdGVuZXJzIiwiJGdldE1heExpc3RlbmVycyIsImdldE1heExpc3RlbmVycyIsImRvRXJyb3IiLCJldmVudHMiLCJoYW5kbGVyIiwibGlzdGVuZXJzIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsImxpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ3YXJuZWQiLCJ3IiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJwb3AiLCJXcml0YWJsZSIsIlNBRkVfTUVUSE9EUyIsIkdFVCIsIkhFQUQiLCJPUFRJT05TIiwiVFJBQ0UiLCJldmVudEhhbmRsZXJzIiwiZXZlbnQiLCJfcmVkaXJlY3RhYmxlIiwiUmVkaXJlY3RhYmxlUmVxdWVzdCIsInJlc3BvbnNlQ2FsbGJhY2siLCJfb3B0aW9ucyIsIl9yZWRpcmVjdENvdW50IiwiX3JlZGlyZWN0cyIsIl9yZXF1ZXN0Qm9keUxlbmd0aCIsIl9yZXF1ZXN0Qm9keUJ1ZmZlcnMiLCJfb25OYXRpdmVSZXNwb25zZSIsIl9wcm9jZXNzUmVzcG9uc2UiLCJzZWFyY2hQb3MiLCJfcGVyZm9ybVJlcXVlc3QiLCJfY3VycmVudFJlcXVlc3QiLCJjdXJyZW50UmVxdWVzdCIsInNldEhlYWRlciIsInJlbW92ZUhlYWRlciIsInByb3BlcnR5IiwibmF0aXZlUHJvdG9jb2wiLCJuYXRpdmVQcm90b2NvbHMiLCJzY2hlbWUiLCJfY3VycmVudFVybCIsIl9pc1JlZGlyZWN0Iiwid3JpdGVOZXh0IiwidHJhY2tSZWRpcmVjdHMiLCJmb2xsb3dSZWRpcmVjdHMiLCJoZWFkZXIiLCJyZWRpcmVjdFVybCIsImFzc2lnbiIsInJlc3BvbnNlVXJsIiwicmVkaXJlY3RzIiwicHJvdG9jb2xzIiwid3JhcHBlZFByb3RvY29sIiwiYXJndiIsInN0YXJ0c1dpdGgiLCJ0ZXJtaW5hdG9yUG9zIiwidmFsaWRhdGVQYXJhbXMiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiTE4yIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwibG9uZyIsImZtdExvbmciLCJmbXRTaG9ydCIsImV4ZWMiLCJwYXJzZUZsb2F0IiwibXNBYnMiLCJyb3VuZCIsInBsdXJhbCIsImlzUGx1cmFsIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZm9ybWF0UmVnRXhwIiwiZiIsIm9iamVjdHMiLCJkZXByZWNhdGUiLCJub0RlcHJlY2F0aW9uIiwiZGVwcmVjYXRlZCIsInRocm93RGVwcmVjYXRpb24iLCJ0cmFjZURlcHJlY2F0aW9uIiwidHJhY2UiLCJkZWJ1Z3MiLCJkZWJ1Z0Vudmlyb24iLCJkZWJ1Z2xvZyIsIk5PREVfREVCVUciLCJwaWQiLCJjdHgiLCJzZWVuIiwic3R5bGl6ZSIsInN0eWxpemVOb0NvbG9yIiwiZGVwdGgiLCJzaG93SGlkZGVuIiwiX2V4dGVuZCIsImN1c3RvbUluc3BlY3QiLCJzdHlsaXplV2l0aENvbG9yIiwiZm9ybWF0VmFsdWUiLCJzdHlsZXMiLCJzdHlsZVR5cGUiLCJhcnJheVRvSGFzaCIsInJlY3Vyc2VUaW1lcyIsInByaW1pdGl2ZSIsImZvcm1hdFByaW1pdGl2ZSIsInZpc2libGVLZXlzIiwiZm9ybWF0RXJyb3IiLCJiYXNlIiwiYnJhY2VzIiwidG9VVENTdHJpbmciLCJmb3JtYXRBcnJheSIsImZvcm1hdFByb3BlcnR5IiwicmVkdWNlVG9TaW5nbGVTdHJpbmciLCJzaW1wbGUiLCJkZXNjIiwibnVtTGluZXNFc3QiLCJjdXIiLCJhciIsInBhZCIsIm1vbnRocyIsInRpbWVzdGFtcCIsInRpbWUiLCJnZXRIb3VycyIsImdldE1pbnV0ZXMiLCJnZXRTZWNvbmRzIiwiZ2V0TW9udGgiLCJvcmlnaW4iLCJhZGQiLCJrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wiLCJwcm9taXNpZnkiLCJvcmlnaW5hbCIsInByb21pc2VSZXNvbHZlIiwicHJvbWlzZVJlamVjdCIsInNldFByb3RvdHlwZU9mIiwiZGVmaW5lUHJvcGVydGllcyIsImN1c3RvbSIsImNhbGxiYWNraWZ5T25SZWplY3RlZCIsIm5ld1JlYXNvbiIsImNhbGxiYWNraWZ5IiwiY2FsbGJhY2tpZmllZCIsIm1heWJlQ2IiLCJyZWoiLCJlbmRpYW5uZXNzIiwibG9hZGF2ZyIsInVwdGltZSIsImZyZWVtZW0iLCJNQVhfVkFMVUUiLCJ0b3RhbG1lbSIsImNwdXMiLCJyZWxlYXNlIiwiYXBwVmVyc2lvbiIsIm5ldHdvcmtJbnRlcmZhY2VzIiwiZ2V0TmV0d29ya0ludGVyZmFjZXMiLCJhcmNoIiwicGxhdGZvcm0iLCJ0bXBkaXIiLCJ0bXBEaXIiLCJFT0wiLCJob21lZGlyIiwiVFlQRURfT0siLCJVaW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJfaGFzIiwic291cmNlcyIsInAiLCJzaHJpbmtCdWYiLCJmblR5cGVkIiwiYXJyYXlTZXQiLCJkZXN0Iiwic3JjX29mZnMiLCJkZXN0X29mZnMiLCJmbGF0dGVuQ2h1bmtzIiwiY2h1bmtzIiwiZm5VbnR5cGVkIiwic2V0VHlwZWQiLCJCdWY4IiwiQnVmMTYiLCJCdWYzMiIsImFkbGVyMzIiLCJhZGxlciIsInMxIiwiczIiLCJaX1RSRUVTIiwiWl9OT19DT01QUkVTU0lPTiIsIlpfQkVTVF9TUEVFRCIsIlpfQkVTVF9DT01QUkVTU0lPTiIsIlpfQklOQVJZIiwiWl9URVhUIiwiWl9VTktOT1dOIiwibWFrZVRhYmxlIiwiY3JjVGFibGUiLCJjcmMzMiIsImNyYyIsInQiLCJ0cmVlcyIsIk1BWF9NRU1fTEVWRUwiLCJNQVhfV0JJVFMiLCJERUZfTUVNX0xFVkVMIiwiTEVOR1RIX0NPREVTIiwiTElURVJBTFMiLCJMX0NPREVTIiwiRF9DT0RFUyIsIkJMX0NPREVTIiwiSEVBUF9TSVpFIiwiTUFYX0JJVFMiLCJNSU5fTUFUQ0giLCJNQVhfTUFUQ0giLCJNSU5fTE9PS0FIRUFEIiwiUFJFU0VUX0RJQ1QiLCJJTklUX1NUQVRFIiwiRVhUUkFfU1RBVEUiLCJOQU1FX1NUQVRFIiwiQ09NTUVOVF9TVEFURSIsIkhDUkNfU1RBVEUiLCJCVVNZX1NUQVRFIiwiRklOSVNIX1NUQVRFIiwiQlNfTkVFRF9NT1JFIiwiQlNfQkxPQ0tfRE9ORSIsIkJTX0ZJTklTSF9TVEFSVEVEIiwiQlNfRklOSVNIX0RPTkUiLCJPU19DT0RFIiwiZXJyb3JDb2RlIiwicmFuayIsInplcm8iLCJmbHVzaF9wZW5kaW5nIiwicGVuZGluZyIsInBlbmRpbmdfYnVmIiwicGVuZGluZ19vdXQiLCJ0b3RhbF9vdXQiLCJmbHVzaF9ibG9ja19vbmx5IiwiX3RyX2ZsdXNoX2Jsb2NrIiwiYmxvY2tfc3RhcnQiLCJzdHJzdGFydCIsInB1dF9ieXRlIiwicHV0U2hvcnRNU0IiLCJyZWFkX2J1ZiIsInRvdGFsX2luIiwibG9uZ2VzdF9tYXRjaCIsImN1cl9tYXRjaCIsImNoYWluX2xlbmd0aCIsIm1heF9jaGFpbl9sZW5ndGgiLCJzY2FuIiwiYmVzdF9sZW4iLCJwcmV2X2xlbmd0aCIsIm5pY2VfbWF0Y2giLCJ3X3NpemUiLCJfd2luIiwid21hc2siLCJ3X21hc2siLCJzdHJlbmQiLCJzY2FuX2VuZDEiLCJzY2FuX2VuZCIsImdvb2RfbWF0Y2giLCJsb29rYWhlYWQiLCJtYXRjaF9zdGFydCIsImZpbGxfd2luZG93IiwiX3dfc2l6ZSIsIm1vcmUiLCJ3aW5kb3dfc2l6ZSIsImhhc2hfc2l6ZSIsImhlYWQiLCJpbnNlcnQiLCJpbnNfaCIsImhhc2hfc2hpZnQiLCJoYXNoX21hc2siLCJkZWZsYXRlX3N0b3JlZCIsIm1heF9ibG9ja19zaXplIiwicGVuZGluZ19idWZfc2l6ZSIsIm1heF9zdGFydCIsImRlZmxhdGVfZmFzdCIsImhhc2hfaGVhZCIsImJmbHVzaCIsIm1hdGNoX2xlbmd0aCIsIl90cl90YWxseSIsIm1heF9sYXp5X21hdGNoIiwibGFzdF9saXQiLCJkZWZsYXRlX3Nsb3ciLCJtYXhfaW5zZXJ0IiwicHJldl9tYXRjaCIsIm1hdGNoX2F2YWlsYWJsZSIsImRlZmxhdGVfcmxlIiwiZGVmbGF0ZV9odWZmIiwiQ29uZmlnIiwiZ29vZF9sZW5ndGgiLCJtYXhfbGF6eSIsIm5pY2VfbGVuZ3RoIiwibWF4X2NoYWluIiwiY29uZmlndXJhdGlvbl90YWJsZSIsImxtX2luaXQiLCJEZWZsYXRlU3RhdGUiLCJnemhlYWQiLCJnemluZGV4IiwibGFzdF9mbHVzaCIsIndfYml0cyIsImhhc2hfYml0cyIsImR5bl9sdHJlZSIsImR5bl9kdHJlZSIsImJsX3RyZWUiLCJsX2Rlc2MiLCJkX2Rlc2MiLCJibF9kZXNjIiwiYmxfY291bnQiLCJoZWFwIiwiaGVhcF9sZW4iLCJoZWFwX21heCIsImxfYnVmIiwibGl0X2J1ZnNpemUiLCJkX2J1ZiIsIm9wdF9sZW4iLCJzdGF0aWNfbGVuIiwibWF0Y2hlcyIsImJpX2J1ZiIsImJpX3ZhbGlkIiwiZGVmbGF0ZVJlc2V0S2VlcCIsImRhdGFfdHlwZSIsIl90cl9pbml0IiwiZGVmbGF0ZVNldEhlYWRlciIsImRlZmxhdGVJbml0Iiwib2xkX2ZsdXNoIiwiYmVnIiwidGV4dCIsImhjcmMiLCJleHRyYSIsImNvbW1lbnQiLCJvcyIsImxldmVsX2ZsYWdzIiwiYnN0YXRlIiwiX3RyX2FsaWduIiwiX3RyX3N0b3JlZF9ibG9jayIsImRpY3RMZW5ndGgiLCJhdmFpbCIsIm5leHQiLCJ0bXBEaWN0IiwiZGVmbGF0ZUluZm8iLCJCQUQiLCJUWVBFIiwiaW5mbGF0ZV9mYXN0IiwiX2luIiwiX291dCIsImRtYXgiLCJ3c2l6ZSIsIndoYXZlIiwid25leHQiLCJzX3dpbmRvdyIsImhvbGQiLCJiaXRzIiwibGNvZGUiLCJkY29kZSIsImxtYXNrIiwiZG1hc2siLCJoZXJlIiwib3AiLCJkaXN0IiwiZnJvbV9zb3VyY2UiLCJsZW5jb2RlIiwiZGlzdGNvZGUiLCJsZW5iaXRzIiwiZGlzdGJpdHMiLCJ0b3AiLCJkb2xlbiIsImRvZGlzdCIsInNhbmUiLCJpbmZsYXRlX3RhYmxlIiwiQ09ERVMiLCJMRU5TIiwiRElTVFMiLCJGTEFHUyIsIlRJTUUiLCJPUyIsIkVYTEVOIiwiRVhUUkEiLCJOQU1FIiwiQ09NTUVOVCIsIkhDUkMiLCJESUNUSUQiLCJESUNUIiwiVFlQRURPIiwiU1RPUkVEIiwiQ09QWV8iLCJDT1BZIiwiVEFCTEUiLCJMRU5MRU5TIiwiQ09ERUxFTlMiLCJMRU5fIiwiTEVOIiwiTEVORVhUIiwiRElTVCIsIkRJU1RFWFQiLCJNQVRDSCIsIkxJVCIsIkNIRUNLIiwiTEVOR1RIIiwiRE9ORSIsIk1FTSIsIlNZTkMiLCJFTk9VR0hfTEVOUyIsIkVOT1VHSF9ESVNUUyIsIkRFRl9XQklUUyIsInpzd2FwMzIiLCJxIiwiSW5mbGF0ZVN0YXRlIiwiaGF2ZWRpY3QiLCJmbGFncyIsImNoZWNrIiwidG90YWwiLCJ3Yml0cyIsIm5jb2RlIiwibmxlbiIsIm5kaXN0Iiwid29yayIsImxlbmR5biIsImRpc3RkeW4iLCJiYWNrIiwid2FzIiwiaW5mbGF0ZVJlc2V0S2VlcCIsImluZmxhdGVSZXNldDIiLCJpbmZsYXRlSW5pdCIsInZpcmdpbiIsImxlbmZpeCIsImRpc3RmaXgiLCJmaXhlZHRhYmxlcyIsInN5bSIsInVwZGF0ZXdpbmRvdyIsInB1dCIsImxlZnQiLCJoZXJlX2JpdHMiLCJoZXJlX29wIiwiaGVyZV92YWwiLCJsYXN0X2JpdHMiLCJsYXN0X29wIiwibGFzdF92YWwiLCJoYnVmIiwib3JkZXIiLCJpbmZfbGVhdmUiLCJkb25lIiwieGZsYWdzIiwiZXh0cmFfbGVuIiwiaW5mbGF0ZUdldEhlYWRlciIsImRpY3RpZCIsImluZmxhdGVJbmZvIiwiTUFYQklUUyIsImxiYXNlIiwibGV4dCIsImRiYXNlIiwiZGV4dCIsImxlbnNfaW5kZXgiLCJ0YWJsZV9pbmRleCIsInJvb3QiLCJkcm9wIiwidXNlZCIsImh1ZmYiLCJpbmNyIiwibG93IiwibWFzayIsImJhc2VfaW5kZXgiLCJvZmZzIiwiZXh0cmFfaW5kZXgiLCJTVE9SRURfQkxPQ0siLCJTVEFUSUNfVFJFRVMiLCJEWU5fVFJFRVMiLCJCdWZfc2l6ZSIsIk1BWF9CTF9CSVRTIiwiRU5EX0JMT0NLIiwiUkVQXzNfNiIsIlJFUFpfM18xMCIsIlJFUFpfMTFfMTM4IiwiZXh0cmFfbGJpdHMiLCJleHRyYV9kYml0cyIsImV4dHJhX2JsYml0cyIsImJsX29yZGVyIiwiRElTVF9DT0RFX0xFTiIsInN0YXRpY19sdHJlZSIsInN0YXRpY19kdHJlZSIsIl9kaXN0X2NvZGUiLCJfbGVuZ3RoX2NvZGUiLCJiYXNlX2xlbmd0aCIsImJhc2VfZGlzdCIsIlN0YXRpY1RyZWVEZXNjIiwic3RhdGljX3RyZWUiLCJleHRyYV9iaXRzIiwiZXh0cmFfYmFzZSIsImVsZW1zIiwibWF4X2xlbmd0aCIsImhhc19zdHJlZSIsInN0YXRpY19sX2Rlc2MiLCJzdGF0aWNfZF9kZXNjIiwic3RhdGljX2JsX2Rlc2MiLCJUcmVlRGVzYyIsImR5bl90cmVlIiwic3RhdF9kZXNjIiwibWF4X2NvZGUiLCJkX2NvZGUiLCJwdXRfc2hvcnQiLCJzZW5kX2JpdHMiLCJzZW5kX2NvZGUiLCJ0cmVlIiwiYmlfcmV2ZXJzZSIsImJpX2ZsdXNoIiwiZ2VuX2JpdGxlbiIsInN0cmVlIiwieGJpdHMiLCJvdmVyZmxvdyIsImdlbl9jb2RlcyIsIm5leHRfY29kZSIsInRyX3N0YXRpY19pbml0IiwiaW5pdF9ibG9jayIsImJpX3dpbmR1cCIsImNvcHlfYmxvY2siLCJzbWFsbGVyIiwiX24yIiwiX20yIiwicHFkb3duaGVhcCIsImNvbXByZXNzX2Jsb2NrIiwibHRyZWUiLCJkdHJlZSIsImxjIiwibHgiLCJidWlsZF90cmVlIiwibm9kZSIsInNjYW5fdHJlZSIsInByZXZsZW4iLCJjdXJsZW4iLCJuZXh0bGVuIiwibWF4X2NvdW50IiwibWluX2NvdW50Iiwic2VuZF90cmVlIiwiYnVpbGRfYmxfdHJlZSIsIm1heF9ibGluZGV4Iiwic2VuZF9hbGxfdHJlZXMiLCJsY29kZXMiLCJkY29kZXMiLCJibGNvZGVzIiwiZGV0ZWN0X2RhdGFfdHlwZSIsImJsYWNrX21hc2siLCJzdGF0aWNfaW5pdF9kb25lIiwic3RvcmVkX2xlbiIsIm9wdF9sZW5iIiwic3RhdGljX2xlbmIiLCJaU3RyZWFtIiwiYXJnMSIsImFyZzIiLCJhcmczIiwiYWZ0ZXJUaWNrT25lIiwiYWZ0ZXJUaWNrVHdvIiwiYWZ0ZXJUaWNrVGhyZWUiLCJhZnRlclRpY2siLCJmcmVlRXhwb3J0cyIsIm5vZGVUeXBlIiwiZnJlZU1vZHVsZSIsImZyZWVHbG9iYWwiLCJwdW55Y29kZSIsIm1heEludCIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJlcnJvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwidWNzMmVuY29kZSIsImJhc2ljVG9EaWdpdCIsImRpZ2l0VG9CYXNpYyIsImRpZ2l0IiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImRlY29kZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJkZWZpbmUiLCJxcyIsInNlcCIsImVxIiwicmVnZXhwIiwibWF4S2V5cyIsImtzdHIiLCJ2c3RyIiwieHMiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsIkR1cGxleCIsInBuYSIsIlJlYWRhYmxlIiwicmVhZGFibGUiLCJhbGxvd0hhbGZPcGVuIiwib25lbmQiLCJoaWdoV2F0ZXJNYXJrIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiX2Rlc3Ryb3kiLCJQYXNzVGhyb3VnaCIsIlJlYWRhYmxlU3RhdGUiLCJFRSIsIkVFbGlzdGVuZXJDb3VudCIsIlN0cmVhbSIsIk91clVpbnQ4QXJyYXkiLCJfdWludDhBcnJheVRvQnVmZmVyIiwiX2lzVWludDhBcnJheSIsImRlYnVnVXRpbCIsIkJ1ZmZlckxpc3QiLCJkZXN0cm95SW1wbCIsIlN0cmluZ0RlY29kZXIiLCJrUHJveHlFdmVudHMiLCJpc0R1cGxleCIsIm9iamVjdE1vZGUiLCJyZWFkYWJsZU9iamVjdE1vZGUiLCJod20iLCJyZWFkYWJsZUh3bSIsInJlYWRhYmxlSGlnaFdhdGVyTWFyayIsImRlZmF1bHRId20iLCJwaXBlcyIsInBpcGVzQ291bnQiLCJmbG93aW5nIiwiZW5kRW1pdHRlZCIsInJlYWRpbmciLCJzeW5jIiwibmVlZFJlYWRhYmxlIiwiZW1pdHRlZFJlYWRhYmxlIiwicmVhZGFibGVMaXN0ZW5pbmciLCJyZXN1bWVTY2hlZHVsZWQiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiX3JlYWQiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJuZWVkTW9yZURhdGEiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwiZW5jIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJtYXliZVJlYWRNb3JlXyIsInBpcGVPcHRzIiwiZG9FbmQiLCJzdGRvdXQiLCJlbmRGbiIsInVucGlwZSIsIm9udW5waXBlIiwidW5waXBlSW5mbyIsImhhc1VucGlwZWQiLCJjbGVhbnVwIiwib25kcmFpbiIsInBpcGVPbkRyYWluIiwiY2xlYW5lZFVwIiwib25jbG9zZSIsIm9uZmluaXNoIiwib25kYXRhIiwiaW5jcmVhc2VkQXdhaXREcmFpbiIsInBhdXNlIiwicmVzdW1lIiwiZGVzdHMiLCJldiIsIm5SZWFkaW5nTmV4dFRpY2siLCJyZXN1bWVfIiwicGF1c2VkIiwiX2Zyb21MaXN0IiwiY2xlYXIiLCJmcm9tTGlzdFBhcnRpYWwiLCJoYXNTdHJpbmdzIiwiY29weUZyb21CdWZmZXJTdHJpbmciLCJjb3B5RnJvbUJ1ZmZlciIsIm5iIiwidGFpbCIsImVuZFJlYWRhYmxlTlQiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjYiIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwicHJlZmluaXNoIiwiZXJyMiIsIldyaXRlUmVxIiwiQ29ya2VkUmVxdWVzdCIsImVudHJ5IiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJhc3luY1dyaXRlIiwic2V0SW1tZWRpYXRlIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsIm5vcCIsIndyaXRhYmxlT2JqZWN0TW9kZSIsIndyaXRhYmxlSHdtIiwid3JpdGFibGVIaWdoV2F0ZXJNYXJrIiwiZmluYWxDYWxsZWQiLCJmaW5pc2hlZCIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRpbmciLCJjb3JrZWQiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJnZXRCdWZmZXIiLCJjdXJyZW50IiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiZmluYWwiLCJfZmluYWwiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsInZhbGlkIiwiaXNCdWYiLCJ3cml0ZU9yQnVmZmVyIiwiY29yayIsInVuY29yayIsImNsZWFyQnVmZmVyIiwic2V0RGVmYXVsdEVuY29kaW5nIiwiZGVjb2RlQ2h1bmsiLCJuZXdDaHVuayIsImRvV3JpdGUiLCJvbndyaXRlRXJyb3IiLCJmaW5pc2hNYXliZSIsIm9ud3JpdGVTdGF0ZVVwZGF0ZSIsIm5lZWRGaW5pc2giLCJhZnRlcldyaXRlIiwib253cml0ZURyYWluIiwiaG9sZGVyIiwiYWxsQnVmZmVycyIsImVuZFdyaXRhYmxlIiwiY2FsbEZpbmFsIiwibmVlZCIsImNvcmtSZXEiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsImNvcHlCdWZmZXIiLCJyZWFkYWJsZURlc3Ryb3llZCIsIndyaXRhYmxlRGVzdHJveWVkIiwiZW1pdEVycm9yTlQiLCJSRUFEQUJMRV9TVFJFQU0iLCJjb3B5UHJvcHMiLCJTYWZlQnVmZmVyIiwiX2lzU3RkaW8iLCJkaWRPbkVuZCIsIl9ub3JtYWxpemVFbmNvZGluZyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJ1dGYxNlRleHQiLCJ1dGYxNkVuZCIsImZpbGxMYXN0IiwidXRmOEZpbGxMYXN0IiwiYmFzZTY0VGV4dCIsImJhc2U2NEVuZCIsInNpbXBsZVdyaXRlIiwic2ltcGxlRW5kIiwibGFzdE5lZWQiLCJsYXN0VG90YWwiLCJsYXN0Q2hhciIsInV0ZjhFbmQiLCJ1dGY4VGV4dCIsInV0ZjhDaGVja0J5dGUiLCJieXRlIiwidXRmOENoZWNrSW5jb21wbGV0ZSIsInV0ZjhDaGVja0V4dHJhQnl0ZXMiLCJoYXNGbGFnIiwiZm9yY2VDb2xvciIsIkZPUkNFX0NPTE9SIiwidHJhbnNsYXRlTGV2ZWwiLCJoYXNCYXNpYyIsImhhczI1NiIsImhhczE2bSIsImlzVFRZIiwib3NSZWxlYXNlIiwidmVyc2lvbnMiLCJzaWduIiwiQ0lfTkFNRSIsIlRFQU1DSVRZX1ZFUlNJT04iLCJDT0xPUlRFUk0iLCJURVJNX1BST0dSQU1fVkVSU0lPTiIsIlRFUk1fUFJPR1JBTSIsIlRFUk0iLCJnZXRTdXBwb3J0TGV2ZWwiLCJSZWFkU3RyZWFtIiwiV3JpdGVTdHJlYW0iLCJ1cmxQYXJzZSIsInVybFJlc29sdmUiLCJyZXNvbHZlT2JqZWN0IiwidXJsUmVzb2x2ZU9iamVjdCIsInVybEZvcm1hdCIsIlVybCIsInNsYXNoZXMiLCJxdWVyeSIsInByb3RvY29sUGF0dGVybiIsInBvcnRQYXR0ZXJuIiwic2ltcGxlUGF0aFBhdHRlcm4iLCJkZWxpbXMiLCJ1bndpc2UiLCJhdXRvRXNjYXBlIiwibm9uSG9zdENoYXJzIiwiaG9zdEVuZGluZ0NoYXJzIiwiaG9zdG5hbWVNYXhMZW4iLCJob3N0bmFtZVBhcnRQYXR0ZXJuIiwiaG9zdG5hbWVQYXJ0U3RhcnQiLCJ1bnNhZmVQcm90b2NvbCIsImhvc3RsZXNzUHJvdG9jb2wiLCJzbGFzaGVkUHJvdG9jb2wiLCJxdWVyeXN0cmluZyIsInBhcnNlUXVlcnlTdHJpbmciLCJzbGFzaGVzRGVub3RlSG9zdCIsInUiLCJxdWVyeUluZGV4Iiwic3BsaXR0ZXIiLCJ1U3BsaXQiLCJzbGFzaFJlZ2V4IiwicmVzdCIsInNpbXBsZVBhdGgiLCJwcm90byIsImxvd2VyUHJvdG8iLCJob3N0RW5kIiwiaGVjIiwiYXRTaWduIiwicGFyc2VIb3N0IiwiaXB2Nkhvc3RuYW1lIiwiaG9zdHBhcnRzIiwicGFydCIsIm5ld3BhcnQiLCJ2YWxpZFBhcnRzIiwibm90SG9zdCIsImJpdCIsImFlIiwiZXNjIiwiZXNjYXBlIiwicW0iLCJyZWxhdGl2ZSIsInJlbCIsInRrZXlzIiwidGsiLCJ0a2V5IiwicmtleXMiLCJyayIsInJrZXkiLCJyZWxQYXRoIiwiaXNTb3VyY2VBYnMiLCJpc1JlbEFicyIsIm11c3RFbmRBYnMiLCJyZW1vdmVBbGxEb3RzIiwic3JjUGF0aCIsInBzeWNob3RpYyIsImF1dGhJbkhvc3QiLCJoYXNUcmFpbGluZ1Ns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LEVBQThCLFFBQTlCLEVBQXdDO0FBQ3ZDeWhCLGdCQUFVLEVBQUUsSUFEMkI7QUFFdkN1RSxTQUFHLEVBQUUsZUFBVztBQUNmLGVBQU9obUIsTUFBTSxDQUFDd1osQ0FBZDtBQUNBO0FBSnNDLEtBQXhDO0FBTUEzYSxVQUFNLENBQUMyaUIsY0FBUCxDQUFzQnhoQixNQUF0QixFQUE4QixJQUE5QixFQUFvQztBQUNuQ3loQixnQkFBVSxFQUFFLElBRHVCO0FBRW5DdUUsU0FBRyxFQUFFLGVBQVc7QUFDZixlQUFPaG1CLE1BQU0sQ0FBQzlCLENBQWQ7QUFDQTtBQUprQyxLQUFwQztBQU1BOEIsVUFBTSxDQUFDNnhELGVBQVAsR0FBeUIsQ0FBekI7QUFDQTs7QUFDRCxTQUFPN3hELE1BQVA7QUFDQSxDQXJCRCxDIiwiZmlsZSI6InZlbmRvci5lNmI5M2M4YTg3MTI3MmUwZTg4ZC5ob3QtdXBkYXRlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBjb21wYXJlIGFuZCBpc0J1ZmZlciB0YWtlbiBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2Jsb2IvNjgwZTllNWU0ODhmMjJhYWMyNzU5OWE1N2RjODQ0YTYzMTU5MjhkZC9pbmRleC5qc1xuLy8gb3JpZ2luYWwgbm90aWNlOlxuXG4vKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxmZXJvc3NAZmVyb3NzLm9yZz4gPGh0dHA6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5mdW5jdGlvbiBjb21wYXJlKGEsIGIpIHtcbiAgaWYgKGEgPT09IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHZhciB4ID0gYS5sZW5ndGg7XG4gIHZhciB5ID0gYi5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV07XG4gICAgICB5ID0gYltpXTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuICBpZiAoeSA8IHgpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlzQnVmZmVyKGIpIHtcbiAgaWYgKGdsb2JhbC5CdWZmZXIgJiYgdHlwZW9mIGdsb2JhbC5CdWZmZXIuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZ2xvYmFsLkJ1ZmZlci5pc0J1ZmZlcihiKTtcbiAgfVxuICByZXR1cm4gISEoYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyKTtcbn1cblxuLy8gYmFzZWQgb24gbm9kZSBhc3NlcnQsIG9yaWdpbmFsIG5vdGljZTpcblxuLy8gaHR0cDovL3dpa2kuY29tbW9uanMub3JnL3dpa2kvVW5pdF9UZXN0aW5nLzEuMFxuLy9cbi8vIFRISVMgSVMgTk9UIFRFU1RFRCBOT1IgTElLRUxZIFRPIFdPUksgT1VUU0lERSBWOCFcbi8vXG4vLyBPcmlnaW5hbGx5IGZyb20gbmFyd2hhbC5qcyAoaHR0cDovL25hcndoYWxqcy5vcmcpXG4vLyBDb3B5cmlnaHQgKGMpIDIwMDkgVGhvbWFzIFJvYmluc29uIDwyODBub3J0aC5jb20+XG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuLy8gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgJ1NvZnR3YXJlJyksIHRvXG4vLyBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZVxuLy8gcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4vLyBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuLy8gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuLy8gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEICdBUyBJUycsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1Jcbi8vIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuLy8gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4vLyBBVVRIT1JTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTlxuLy8gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTlxuLy8gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbnZhciB1dGlsID0gcmVxdWlyZSgndXRpbC8nKTtcbnZhciBoYXNPd24gPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBmdW5jdGlvbnNIYXZlTmFtZXMgPSAoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZnVuY3Rpb24gZm9vKCkge30ubmFtZSA9PT0gJ2Zvbyc7XG59KCkpO1xuZnVuY3Rpb24gcFRvU3RyaW5nIChvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopO1xufVxuZnVuY3Rpb24gaXNWaWV3KGFycmJ1Zikge1xuICBpZiAoaXNCdWZmZXIoYXJyYnVmKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIGdsb2JhbC5BcnJheUJ1ZmZlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJyYnVmKTtcbiAgfVxuICBpZiAoIWFycmJ1Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoYXJyYnVmIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoYXJyYnVmLmJ1ZmZlciAmJiBhcnJidWYuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG4vLyAxLiBUaGUgYXNzZXJ0IG1vZHVsZSBwcm92aWRlcyBmdW5jdGlvbnMgdGhhdCB0aHJvd1xuLy8gQXNzZXJ0aW9uRXJyb3IncyB3aGVuIHBhcnRpY3VsYXIgY29uZGl0aW9ucyBhcmUgbm90IG1ldC4gVGhlXG4vLyBhc3NlcnQgbW9kdWxlIG11c3QgY29uZm9ybSB0byB0aGUgZm9sbG93aW5nIGludGVyZmFjZS5cblxudmFyIGFzc2VydCA9IG1vZHVsZS5leHBvcnRzID0gb2s7XG5cbi8vIDIuIFRoZSBBc3NlcnRpb25FcnJvciBpcyBkZWZpbmVkIGluIGFzc2VydC5cbi8vIG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IoeyBtZXNzYWdlOiBtZXNzYWdlLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogYWN0dWFsLFxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZCB9KVxuXG52YXIgcmVnZXggPSAvXFxzKmZ1bmN0aW9uXFxzKyhbXlxcKFxcc10qKVxccyovO1xuLy8gYmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9mdW5jdGlvbi5wcm90b3R5cGUubmFtZS9ibG9iL2FkZWVlZWM4YmZjYzYwNjhiMTg3ZDdkOWZiM2Q1YmIxZDNhMzA4OTkvaW1wbGVtZW50YXRpb24uanNcbmZ1bmN0aW9uIGdldE5hbWUoZnVuYykge1xuICBpZiAoIXV0aWwuaXNGdW5jdGlvbihmdW5jKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzKSB7XG4gICAgcmV0dXJuIGZ1bmMubmFtZTtcbiAgfVxuICB2YXIgc3RyID0gZnVuYy50b1N0cmluZygpO1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2gocmVnZXgpO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2hbMV07XG59XG5hc3NlcnQuQXNzZXJ0aW9uRXJyb3IgPSBmdW5jdGlvbiBBc3NlcnRpb25FcnJvcihvcHRpb25zKSB7XG4gIHRoaXMubmFtZSA9ICdBc3NlcnRpb25FcnJvcic7XG4gIHRoaXMuYWN0dWFsID0gb3B0aW9ucy5hY3R1YWw7XG4gIHRoaXMuZXhwZWN0ZWQgPSBvcHRpb25zLmV4cGVjdGVkO1xuICB0aGlzLm9wZXJhdG9yID0gb3B0aW9ucy5vcGVyYXRvcjtcbiAgaWYgKG9wdGlvbnMubWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG9wdGlvbnMubWVzc2FnZTtcbiAgICB0aGlzLmdlbmVyYXRlZE1lc3NhZ2UgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBnZXRNZXNzYWdlKHRoaXMpO1xuICAgIHRoaXMuZ2VuZXJhdGVkTWVzc2FnZSA9IHRydWU7XG4gIH1cbiAgdmFyIHN0YWNrU3RhcnRGdW5jdGlvbiA9IG9wdGlvbnMuc3RhY2tTdGFydEZ1bmN0aW9uIHx8IGZhaWw7XG4gIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHN0YWNrU3RhcnRGdW5jdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gbm9uIHY4IGJyb3dzZXJzIHNvIHdlIGNhbiBoYXZlIGEgc3RhY2t0cmFjZVxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgICBpZiAoZXJyLnN0YWNrKSB7XG4gICAgICB2YXIgb3V0ID0gZXJyLnN0YWNrO1xuXG4gICAgICAvLyB0cnkgdG8gc3RyaXAgdXNlbGVzcyBmcmFtZXNcbiAgICAgIHZhciBmbl9uYW1lID0gZ2V0TmFtZShzdGFja1N0YXJ0RnVuY3Rpb24pO1xuICAgICAgdmFyIGlkeCA9IG91dC5pbmRleE9mKCdcXG4nICsgZm5fbmFtZSk7XG4gICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgLy8gb25jZSB3ZSBoYXZlIGxvY2F0ZWQgdGhlIGZ1bmN0aW9uIGZyYW1lXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gc3RyaXAgb3V0IGV2ZXJ5dGhpbmcgYmVmb3JlIGl0IChhbmQgaXRzIGxpbmUpXG4gICAgICAgIHZhciBuZXh0X2xpbmUgPSBvdXQuaW5kZXhPZignXFxuJywgaWR4ICsgMSk7XG4gICAgICAgIG91dCA9IG91dC5zdWJzdHJpbmcobmV4dF9saW5lICsgMSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3RhY2sgPSBvdXQ7XG4gICAgfVxuICB9XG59O1xuXG4vLyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3IgaW5zdGFuY2VvZiBFcnJvclxudXRpbC5pbmhlcml0cyhhc3NlcnQuQXNzZXJ0aW9uRXJyb3IsIEVycm9yKTtcblxuZnVuY3Rpb24gdHJ1bmNhdGUocywgbikge1xuICBpZiAodHlwZW9mIHMgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHMubGVuZ3RoIDwgbiA/IHMgOiBzLnNsaWNlKDAsIG4pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5mdW5jdGlvbiBpbnNwZWN0KHNvbWV0aGluZykge1xuICBpZiAoZnVuY3Rpb25zSGF2ZU5hbWVzIHx8ICF1dGlsLmlzRnVuY3Rpb24oc29tZXRoaW5nKSkge1xuICAgIHJldHVybiB1dGlsLmluc3BlY3Qoc29tZXRoaW5nKTtcbiAgfVxuICB2YXIgcmF3bmFtZSA9IGdldE5hbWUoc29tZXRoaW5nKTtcbiAgdmFyIG5hbWUgPSByYXduYW1lID8gJzogJyArIHJhd25hbWUgOiAnJztcbiAgcmV0dXJuICdbRnVuY3Rpb24nICsgIG5hbWUgKyAnXSc7XG59XG5mdW5jdGlvbiBnZXRNZXNzYWdlKHNlbGYpIHtcbiAgcmV0dXJuIHRydW5jYXRlKGluc3BlY3Qoc2VsZi5hY3R1YWwpLCAxMjgpICsgJyAnICtcbiAgICAgICAgIHNlbGYub3BlcmF0b3IgKyAnICcgK1xuICAgICAgICAgdHJ1bmNhdGUoaW5zcGVjdChzZWxmLmV4cGVjdGVkKSwgMTI4KTtcbn1cblxuLy8gQXQgcHJlc2VudCBvbmx5IHRoZSB0aHJlZSBrZXlzIG1lbnRpb25lZCBhYm92ZSBhcmUgdXNlZCBhbmRcbi8vIHVuZGVyc3Rvb2QgYnkgdGhlIHNwZWMuIEltcGxlbWVudGF0aW9ucyBvciBzdWIgbW9kdWxlcyBjYW4gcGFzc1xuLy8gb3RoZXIga2V5cyB0byB0aGUgQXNzZXJ0aW9uRXJyb3IncyBjb25zdHJ1Y3RvciAtIHRoZXkgd2lsbCBiZVxuLy8gaWdub3JlZC5cblxuLy8gMy4gQWxsIG9mIHRoZSBmb2xsb3dpbmcgZnVuY3Rpb25zIG11c3QgdGhyb3cgYW4gQXNzZXJ0aW9uRXJyb3Jcbi8vIHdoZW4gYSBjb3JyZXNwb25kaW5nIGNvbmRpdGlvbiBpcyBub3QgbWV0LCB3aXRoIGEgbWVzc2FnZSB0aGF0XG4vLyBtYXkgYmUgdW5kZWZpbmVkIGlmIG5vdCBwcm92aWRlZC4gIEFsbCBhc3NlcnRpb24gbWV0aG9kcyBwcm92aWRlXG4vLyBib3RoIHRoZSBhY3R1YWwgYW5kIGV4cGVjdGVkIHZhbHVlcyB0byB0aGUgYXNzZXJ0aW9uIGVycm9yIGZvclxuLy8gZGlzcGxheSBwdXJwb3Nlcy5cblxuZnVuY3Rpb24gZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCBvcGVyYXRvciwgc3RhY2tTdGFydEZ1bmN0aW9uKSB7XG4gIHRocm93IG5ldyBhc3NlcnQuQXNzZXJ0aW9uRXJyb3Ioe1xuICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgYWN0dWFsOiBhY3R1YWwsXG4gICAgZXhwZWN0ZWQ6IGV4cGVjdGVkLFxuICAgIG9wZXJhdG9yOiBvcGVyYXRvcixcbiAgICBzdGFja1N0YXJ0RnVuY3Rpb246IHN0YWNrU3RhcnRGdW5jdGlvblxuICB9KTtcbn1cblxuLy8gRVhURU5TSU9OISBhbGxvd3MgZm9yIHdlbGwgYmVoYXZlZCBlcnJvcnMgZGVmaW5lZCBlbHNld2hlcmUuXG5hc3NlcnQuZmFpbCA9IGZhaWw7XG5cbi8vIDQuIFB1cmUgYXNzZXJ0aW9uIHRlc3RzIHdoZXRoZXIgYSB2YWx1ZSBpcyB0cnV0aHksIGFzIGRldGVybWluZWRcbi8vIGJ5ICEhZ3VhcmQuXG4vLyBhc3NlcnQub2soZ3VhcmQsIG1lc3NhZ2Vfb3B0KTtcbi8vIFRoaXMgc3RhdGVtZW50IGlzIGVxdWl2YWxlbnQgdG8gYXNzZXJ0LmVxdWFsKHRydWUsICEhZ3VhcmQsXG4vLyBtZXNzYWdlX29wdCk7LiBUbyB0ZXN0IHN0cmljdGx5IGZvciB0aGUgdmFsdWUgdHJ1ZSwgdXNlXG4vLyBhc3NlcnQuc3RyaWN0RXF1YWwodHJ1ZSwgZ3VhcmQsIG1lc3NhZ2Vfb3B0KTsuXG5cbmZ1bmN0aW9uIG9rKHZhbHVlLCBtZXNzYWdlKSB7XG4gIGlmICghdmFsdWUpIGZhaWwodmFsdWUsIHRydWUsIG1lc3NhZ2UsICc9PScsIGFzc2VydC5vayk7XG59XG5hc3NlcnQub2sgPSBvaztcblxuLy8gNS4gVGhlIGVxdWFsaXR5IGFzc2VydGlvbiB0ZXN0cyBzaGFsbG93LCBjb2VyY2l2ZSBlcXVhbGl0eSB3aXRoXG4vLyA9PS5cbi8vIGFzc2VydC5lcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPSBleHBlY3RlZCkgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnPT0nLCBhc3NlcnQuZXF1YWwpO1xufTtcblxuLy8gNi4gVGhlIG5vbi1lcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgZm9yIHdoZXRoZXIgdHdvIG9iamVjdHMgYXJlIG5vdCBlcXVhbFxuLy8gd2l0aCAhPSBhc3NlcnQubm90RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZV9vcHQpO1xuXG5hc3NlcnQubm90RXF1YWwgPSBmdW5jdGlvbiBub3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChhY3R1YWwgPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICchPScsIGFzc2VydC5ub3RFcXVhbCk7XG4gIH1cbn07XG5cbi8vIDcuIFRoZSBlcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgYSBkZWVwIGVxdWFsaXR5IHJlbGF0aW9uLlxuLy8gYXNzZXJ0LmRlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5kZWVwRXF1YWwgPSBmdW5jdGlvbiBkZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgZmFsc2UpKSB7XG4gICAgZmFpbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlLCAnZGVlcEVxdWFsJywgYXNzZXJ0LmRlZXBFcXVhbCk7XG4gIH1cbn07XG5cbmFzc2VydC5kZWVwU3RyaWN0RXF1YWwgPSBmdW5jdGlvbiBkZWVwU3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoIV9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdkZWVwU3RyaWN0RXF1YWwnLCBhc3NlcnQuZGVlcFN0cmljdEVxdWFsKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX2RlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBzdHJpY3QsIG1lbW9zKSB7XG4gIC8vIDcuMS4gQWxsIGlkZW50aWNhbCB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGFzIGRldGVybWluZWQgYnkgPT09LlxuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgJiYgaXNCdWZmZXIoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGNvbXBhcmUoYWN0dWFsLCBleHBlY3RlZCkgPT09IDA7XG5cbiAgLy8gNy4yLiBJZiB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMgYSBEYXRlIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBEYXRlIG9iamVjdCB0aGF0IHJlZmVycyB0byB0aGUgc2FtZSB0aW1lLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNEYXRlKGFjdHVhbCkgJiYgdXRpbC5pc0RhdGUoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMgSWYgdGhlIGV4cGVjdGVkIHZhbHVlIGlzIGEgUmVnRXhwIG9iamVjdCwgdGhlIGFjdHVhbCB2YWx1ZSBpc1xuICAvLyBlcXVpdmFsZW50IGlmIGl0IGlzIGFsc28gYSBSZWdFeHAgb2JqZWN0IHdpdGggdGhlIHNhbWUgc291cmNlIGFuZFxuICAvLyBwcm9wZXJ0aWVzIChgZ2xvYmFsYCwgYG11bHRpbGluZWAsIGBsYXN0SW5kZXhgLCBgaWdub3JlQ2FzZWApLlxuICB9IGVsc2UgaWYgKHV0aWwuaXNSZWdFeHAoYWN0dWFsKSAmJiB1dGlsLmlzUmVnRXhwKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBhY3R1YWwuc291cmNlID09PSBleHBlY3RlZC5zb3VyY2UgJiZcbiAgICAgICAgICAgYWN0dWFsLmdsb2JhbCA9PT0gZXhwZWN0ZWQuZ2xvYmFsICYmXG4gICAgICAgICAgIGFjdHVhbC5tdWx0aWxpbmUgPT09IGV4cGVjdGVkLm11bHRpbGluZSAmJlxuICAgICAgICAgICBhY3R1YWwubGFzdEluZGV4ID09PSBleHBlY3RlZC5sYXN0SW5kZXggJiZcbiAgICAgICAgICAgYWN0dWFsLmlnbm9yZUNhc2UgPT09IGV4cGVjdGVkLmlnbm9yZUNhc2U7XG5cbiAgLy8gNy40LiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKChhY3R1YWwgPT09IG51bGwgfHwgdHlwZW9mIGFjdHVhbCAhPT0gJ29iamVjdCcpICYmXG4gICAgICAgICAgICAgKGV4cGVjdGVkID09PSBudWxsIHx8IHR5cGVvZiBleHBlY3RlZCAhPT0gJ29iamVjdCcpKSB7XG4gICAgcmV0dXJuIHN0cmljdCA/IGFjdHVhbCA9PT0gZXhwZWN0ZWQgOiBhY3R1YWwgPT0gZXhwZWN0ZWQ7XG5cbiAgLy8gSWYgYm90aCB2YWx1ZXMgYXJlIGluc3RhbmNlcyBvZiB0eXBlZCBhcnJheXMsIHdyYXAgdGhlaXIgdW5kZXJseWluZ1xuICAvLyBBcnJheUJ1ZmZlcnMgaW4gYSBCdWZmZXIgZWFjaCB0byBpbmNyZWFzZSBwZXJmb3JtYW5jZVxuICAvLyBUaGlzIG9wdGltaXphdGlvbiByZXF1aXJlcyB0aGUgYXJyYXlzIHRvIGhhdmUgdGhlIHNhbWUgdHlwZSBhcyBjaGVja2VkIGJ5XG4gIC8vIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgKGFrYSBwVG9TdHJpbmcpLiBOZXZlciBwZXJmb3JtIGJpbmFyeVxuICAvLyBjb21wYXJpc29ucyBmb3IgRmxvYXQqQXJyYXlzLCB0aG91Z2gsIHNpbmNlIGUuZy4gKzAgPT09IC0wIGJ1dCB0aGVpclxuICAvLyBiaXQgcGF0dGVybnMgYXJlIG5vdCBpZGVudGljYWwuXG4gIH0gZWxzZSBpZiAoaXNWaWV3KGFjdHVhbCkgJiYgaXNWaWV3KGV4cGVjdGVkKSAmJlxuICAgICAgICAgICAgIHBUb1N0cmluZyhhY3R1YWwpID09PSBwVG9TdHJpbmcoZXhwZWN0ZWQpICYmXG4gICAgICAgICAgICAgIShhY3R1YWwgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcbiAgICAgICAgICAgICAgIGFjdHVhbCBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheSkpIHtcbiAgICByZXR1cm4gY29tcGFyZShuZXcgVWludDhBcnJheShhY3R1YWwuYnVmZmVyKSxcbiAgICAgICAgICAgICAgICAgICBuZXcgVWludDhBcnJheShleHBlY3RlZC5idWZmZXIpKSA9PT0gMDtcblxuICAvLyA3LjUgRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2UgaWYgKGlzQnVmZmVyKGFjdHVhbCkgIT09IGlzQnVmZmVyKGV4cGVjdGVkKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICBtZW1vcyA9IG1lbW9zIHx8IHthY3R1YWw6IFtdLCBleHBlY3RlZDogW119O1xuXG4gICAgdmFyIGFjdHVhbEluZGV4ID0gbWVtb3MuYWN0dWFsLmluZGV4T2YoYWN0dWFsKTtcbiAgICBpZiAoYWN0dWFsSW5kZXggIT09IC0xKSB7XG4gICAgICBpZiAoYWN0dWFsSW5kZXggPT09IG1lbW9zLmV4cGVjdGVkLmluZGV4T2YoZXhwZWN0ZWQpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG1lbW9zLmFjdHVhbC5wdXNoKGFjdHVhbCk7XG4gICAgbWVtb3MuZXhwZWN0ZWQucHVzaChleHBlY3RlZCk7XG5cbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgc3RyaWN0LCBtZW1vcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBcmd1bWVudHMob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgc3RyaWN0LCBhY3R1YWxWaXNpdGVkT2JqZWN0cykge1xuICBpZiAoYSA9PT0gbnVsbCB8fCBhID09PSB1bmRlZmluZWQgfHwgYiA9PT0gbnVsbCB8fCBiID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBpZiBvbmUgaXMgYSBwcmltaXRpdmUsIHRoZSBvdGhlciBtdXN0IGJlIHNhbWVcbiAgaWYgKHV0aWwuaXNQcmltaXRpdmUoYSkgfHwgdXRpbC5pc1ByaW1pdGl2ZShiKSlcbiAgICByZXR1cm4gYSA9PT0gYjtcbiAgaWYgKHN0cmljdCAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoYSkgIT09IE9iamVjdC5nZXRQcm90b3R5cGVPZihiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIHZhciBhSXNBcmdzID0gaXNBcmd1bWVudHMoYSk7XG4gIHZhciBiSXNBcmdzID0gaXNBcmd1bWVudHMoYik7XG4gIGlmICgoYUlzQXJncyAmJiAhYklzQXJncykgfHwgKCFhSXNBcmdzICYmIGJJc0FyZ3MpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKGFJc0FyZ3MpIHtcbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBfZGVlcEVxdWFsKGEsIGIsIHN0cmljdCk7XG4gIH1cbiAgdmFyIGthID0gb2JqZWN0S2V5cyhhKTtcbiAgdmFyIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgdmFyIGtleSwgaTtcbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPT0ga2IubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgLy90aGUgc2FtZSBzZXQgb2Yga2V5cyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSxcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIC8vfn5+Y2hlYXAga2V5IHRlc3RcbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoa2FbaV0gIT09IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFfZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBzdHJpY3QsIGFjdHVhbFZpc2l0ZWRPYmplY3RzKSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gOC4gVGhlIG5vbi1lcXVpdmFsZW5jZSBhc3NlcnRpb24gdGVzdHMgZm9yIGFueSBkZWVwIGluZXF1YWxpdHkuXG4vLyBhc3NlcnQubm90RGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdERlZXBFcXVhbCA9IGZ1bmN0aW9uIG5vdERlZXBFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlKSB7XG4gIGlmIChfZGVlcEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIGZhbHNlKSkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJ25vdERlZXBFcXVhbCcsIGFzc2VydC5ub3REZWVwRXF1YWwpO1xuICB9XG59O1xuXG5hc3NlcnQubm90RGVlcFN0cmljdEVxdWFsID0gbm90RGVlcFN0cmljdEVxdWFsO1xuZnVuY3Rpb24gbm90RGVlcFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKF9kZWVwRXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgdHJ1ZSkpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICdub3REZWVwU3RyaWN0RXF1YWwnLCBub3REZWVwU3RyaWN0RXF1YWwpO1xuICB9XG59XG5cblxuLy8gOS4gVGhlIHN0cmljdCBlcXVhbGl0eSBhc3NlcnRpb24gdGVzdHMgc3RyaWN0IGVxdWFsaXR5LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbi8vIGFzc2VydC5zdHJpY3RFcXVhbChhY3R1YWwsIGV4cGVjdGVkLCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC5zdHJpY3RFcXVhbCA9IGZ1bmN0aW9uIHN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UpIHtcbiAgaWYgKGFjdHVhbCAhPT0gZXhwZWN0ZWQpIHtcbiAgICBmYWlsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2UsICc9PT0nLCBhc3NlcnQuc3RyaWN0RXF1YWwpO1xuICB9XG59O1xuXG4vLyAxMC4gVGhlIHN0cmljdCBub24tZXF1YWxpdHkgYXNzZXJ0aW9uIHRlc3RzIGZvciBzdHJpY3QgaW5lcXVhbGl0eSwgYXNcbi8vIGRldGVybWluZWQgYnkgIT09LiAgYXNzZXJ0Lm5vdFN0cmljdEVxdWFsKGFjdHVhbCwgZXhwZWN0ZWQsIG1lc3NhZ2Vfb3B0KTtcblxuYXNzZXJ0Lm5vdFN0cmljdEVxdWFsID0gZnVuY3Rpb24gbm90U3RyaWN0RXF1YWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICBpZiAoYWN0dWFsID09PSBleHBlY3RlZCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgbWVzc2FnZSwgJyE9PScsIGFzc2VydC5ub3RTdHJpY3RFcXVhbCk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpIHtcbiAgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChleHBlY3RlZCkgPT0gJ1tvYmplY3QgUmVnRXhwXScpIHtcbiAgICByZXR1cm4gZXhwZWN0ZWQudGVzdChhY3R1YWwpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoYWN0dWFsIGluc3RhbmNlb2YgZXhwZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIElnbm9yZS4gIFRoZSBpbnN0YW5jZW9mIGNoZWNrIGRvZXNuJ3Qgd29yayBmb3IgYXJyb3cgZnVuY3Rpb25zLlxuICB9XG5cbiAgaWYgKEVycm9yLmlzUHJvdG90eXBlT2YoZXhwZWN0ZWQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGV4cGVjdGVkLmNhbGwoe30sIGFjdHVhbCkgPT09IHRydWU7XG59XG5cbmZ1bmN0aW9uIF90cnlCbG9jayhibG9jaykge1xuICB2YXIgZXJyb3I7XG4gIHRyeSB7XG4gICAgYmxvY2soKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGVycm9yID0gZTtcbiAgfVxuICByZXR1cm4gZXJyb3I7XG59XG5cbmZ1bmN0aW9uIF90aHJvd3Moc2hvdWxkVGhyb3csIGJsb2NrLCBleHBlY3RlZCwgbWVzc2FnZSkge1xuICB2YXIgYWN0dWFsO1xuXG4gIGlmICh0eXBlb2YgYmxvY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJsb2NrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICBpZiAodHlwZW9mIGV4cGVjdGVkID09PSAnc3RyaW5nJykge1xuICAgIG1lc3NhZ2UgPSBleHBlY3RlZDtcbiAgICBleHBlY3RlZCA9IG51bGw7XG4gIH1cblxuICBhY3R1YWwgPSBfdHJ5QmxvY2soYmxvY2spO1xuXG4gIG1lc3NhZ2UgPSAoZXhwZWN0ZWQgJiYgZXhwZWN0ZWQubmFtZSA/ICcgKCcgKyBleHBlY3RlZC5uYW1lICsgJykuJyA6ICcuJykgK1xuICAgICAgICAgICAgKG1lc3NhZ2UgPyAnICcgKyBtZXNzYWdlIDogJy4nKTtcblxuICBpZiAoc2hvdWxkVGhyb3cgJiYgIWFjdHVhbCkge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ01pc3NpbmcgZXhwZWN0ZWQgZXhjZXB0aW9uJyArIG1lc3NhZ2UpO1xuICB9XG5cbiAgdmFyIHVzZXJQcm92aWRlZE1lc3NhZ2UgPSB0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZyc7XG4gIHZhciBpc1Vud2FudGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIHV0aWwuaXNFcnJvcihhY3R1YWwpO1xuICB2YXIgaXNVbmV4cGVjdGVkRXhjZXB0aW9uID0gIXNob3VsZFRocm93ICYmIGFjdHVhbCAmJiAhZXhwZWN0ZWQ7XG5cbiAgaWYgKChpc1Vud2FudGVkRXhjZXB0aW9uICYmXG4gICAgICB1c2VyUHJvdmlkZWRNZXNzYWdlICYmXG4gICAgICBleHBlY3RlZEV4Y2VwdGlvbihhY3R1YWwsIGV4cGVjdGVkKSkgfHxcbiAgICAgIGlzVW5leHBlY3RlZEV4Y2VwdGlvbikge1xuICAgIGZhaWwoYWN0dWFsLCBleHBlY3RlZCwgJ0dvdCB1bndhbnRlZCBleGNlcHRpb24nICsgbWVzc2FnZSk7XG4gIH1cblxuICBpZiAoKHNob3VsZFRocm93ICYmIGFjdHVhbCAmJiBleHBlY3RlZCAmJlxuICAgICAgIWV4cGVjdGVkRXhjZXB0aW9uKGFjdHVhbCwgZXhwZWN0ZWQpKSB8fCAoIXNob3VsZFRocm93ICYmIGFjdHVhbCkpIHtcbiAgICB0aHJvdyBhY3R1YWw7XG4gIH1cbn1cblxuLy8gMTEuIEV4cGVjdGVkIHRvIHRocm93IGFuIGVycm9yOlxuLy8gYXNzZXJ0LnRocm93cyhibG9jaywgRXJyb3Jfb3B0LCBtZXNzYWdlX29wdCk7XG5cbmFzc2VydC50aHJvd3MgPSBmdW5jdGlvbihibG9jaywgLypvcHRpb25hbCovZXJyb3IsIC8qb3B0aW9uYWwqL21lc3NhZ2UpIHtcbiAgX3Rocm93cyh0cnVlLCBibG9jaywgZXJyb3IsIG1lc3NhZ2UpO1xufTtcblxuLy8gRVhURU5TSU9OISBUaGlzIGlzIGFubm95aW5nIHRvIHdyaXRlIG91dHNpZGUgdGhpcyBtb2R1bGUuXG5hc3NlcnQuZG9lc05vdFRocm93ID0gZnVuY3Rpb24oYmxvY2ssIC8qb3B0aW9uYWwqL2Vycm9yLCAvKm9wdGlvbmFsKi9tZXNzYWdlKSB7XG4gIF90aHJvd3MoZmFsc2UsIGJsb2NrLCBlcnJvciwgbWVzc2FnZSk7XG59O1xuXG5hc3NlcnQuaWZFcnJvciA9IGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyKSB0aHJvdyBlcnI7IH07XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKGhhc093bi5jYWxsKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9heGlvcycpOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xudmFyIGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbnZhciBodHRwRm9sbG93ID0gcmVxdWlyZSgnZm9sbG93LXJlZGlyZWN0cycpLmh0dHA7XG52YXIgaHR0cHNGb2xsb3cgPSByZXF1aXJlKCdmb2xsb3ctcmVkaXJlY3RzJykuaHR0cHM7XG52YXIgdXJsID0gcmVxdWlyZSgndXJsJyk7XG52YXIgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbnZhciBwa2cgPSByZXF1aXJlKCcuLy4uLy4uL3BhY2thZ2UuanNvbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBpc0h0dHBzID0gL2h0dHBzOj8vO1xuXG4vKmVzbGludCBjb25zaXN0ZW50LXJldHVybjowKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaHR0cEFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaEh0dHBSZXF1ZXN0KHJlc29sdmVQcm9taXNlLCByZWplY3RQcm9taXNlKSB7XG4gICAgdmFyIHJlc29sdmUgPSBmdW5jdGlvbiByZXNvbHZlKHZhbHVlKSB7XG4gICAgICByZXNvbHZlUHJvbWlzZSh2YWx1ZSk7XG4gICAgfTtcbiAgICB2YXIgcmVqZWN0ID0gZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7XG4gICAgICByZWplY3RQcm9taXNlKHZhbHVlKTtcbiAgICB9O1xuICAgIHZhciBkYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIGhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIC8vIFNldCBVc2VyLUFnZW50IChyZXF1aXJlZCBieSBzb21lIHNlcnZlcnMpXG4gICAgLy8gT25seSBzZXQgaGVhZGVyIGlmIGl0IGhhc24ndCBiZWVuIHNldCBpbiBjb25maWdcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy82OVxuICAgIGlmICghaGVhZGVyc1snVXNlci1BZ2VudCddICYmICFoZWFkZXJzWyd1c2VyLWFnZW50J10pIHtcbiAgICAgIGhlYWRlcnNbJ1VzZXItQWdlbnQnXSA9ICdheGlvcy8nICsgcGtnLnZlcnNpb247XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgIXV0aWxzLmlzU3RyZWFtKGRhdGEpKSB7XG4gICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gZG8uLi5cbiAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkoZGF0YSkpO1xuICAgICAgfSBlbHNlIGlmICh1dGlscy5pc1N0cmluZyhkYXRhKSkge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSwgJ3V0Zi04Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICAgICdEYXRhIGFmdGVyIHRyYW5zZm9ybWF0aW9uIG11c3QgYmUgYSBzdHJpbmcsIGFuIEFycmF5QnVmZmVyLCBhIEJ1ZmZlciwgb3IgYSBTdHJlYW0nLFxuICAgICAgICAgIGNvbmZpZ1xuICAgICAgICApKTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIENvbnRlbnQtTGVuZ3RoIGhlYWRlciBpZiBkYXRhIGV4aXN0c1xuICAgICAgaGVhZGVyc1snQ29udGVudC1MZW5ndGgnXSA9IGRhdGEubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICB2YXIgYXV0aCA9IHVuZGVmaW5lZDtcbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICBhdXRoID0gdXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZDtcbiAgICB9XG5cbiAgICAvLyBQYXJzZSB1cmxcbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICB2YXIgcGFyc2VkID0gdXJsLnBhcnNlKGZ1bGxQYXRoKTtcbiAgICB2YXIgcHJvdG9jb2wgPSBwYXJzZWQucHJvdG9jb2wgfHwgJ2h0dHA6JztcblxuICAgIGlmICghYXV0aCAmJiBwYXJzZWQuYXV0aCkge1xuICAgICAgdmFyIHVybEF1dGggPSBwYXJzZWQuYXV0aC5zcGxpdCgnOicpO1xuICAgICAgdmFyIHVybFVzZXJuYW1lID0gdXJsQXV0aFswXSB8fCAnJztcbiAgICAgIHZhciB1cmxQYXNzd29yZCA9IHVybEF1dGhbMV0gfHwgJyc7XG4gICAgICBhdXRoID0gdXJsVXNlcm5hbWUgKyAnOicgKyB1cmxQYXNzd29yZDtcbiAgICB9XG5cbiAgICBpZiAoYXV0aCkge1xuICAgICAgZGVsZXRlIGhlYWRlcnMuQXV0aG9yaXphdGlvbjtcbiAgICB9XG5cbiAgICB2YXIgaXNIdHRwc1JlcXVlc3QgPSBpc0h0dHBzLnRlc3QocHJvdG9jb2wpO1xuICAgIHZhciBhZ2VudCA9IGlzSHR0cHNSZXF1ZXN0ID8gY29uZmlnLmh0dHBzQWdlbnQgOiBjb25maWcuaHR0cEFnZW50O1xuXG4gICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICBwYXRoOiBidWlsZFVSTChwYXJzZWQucGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyksXG4gICAgICBtZXRob2Q6IGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhZ2VudDogYWdlbnQsXG4gICAgICBhZ2VudHM6IHsgaHR0cDogY29uZmlnLmh0dHBBZ2VudCwgaHR0cHM6IGNvbmZpZy5odHRwc0FnZW50IH0sXG4gICAgICBhdXRoOiBhdXRoXG4gICAgfTtcblxuICAgIGlmIChjb25maWcuc29ja2V0UGF0aCkge1xuICAgICAgb3B0aW9ucy5zb2NrZXRQYXRoID0gY29uZmlnLnNvY2tldFBhdGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnMuaG9zdG5hbWUgPSBwYXJzZWQuaG9zdG5hbWU7XG4gICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZWQucG9ydDtcbiAgICB9XG5cbiAgICB2YXIgcHJveHkgPSBjb25maWcucHJveHk7XG4gICAgaWYgKCFwcm94eSAmJiBwcm94eSAhPT0gZmFsc2UpIHtcbiAgICAgIHZhciBwcm94eUVudiA9IHByb3RvY29sLnNsaWNlKDAsIC0xKSArICdfcHJveHknO1xuICAgICAgdmFyIHByb3h5VXJsID0gcHJvY2Vzcy5lbnZbcHJveHlFbnZdIHx8IHByb2Nlc3MuZW52W3Byb3h5RW52LnRvVXBwZXJDYXNlKCldO1xuICAgICAgaWYgKHByb3h5VXJsKSB7XG4gICAgICAgIHZhciBwYXJzZWRQcm94eVVybCA9IHVybC5wYXJzZShwcm94eVVybCk7XG4gICAgICAgIHZhciBub1Byb3h5RW52ID0gcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgcHJvY2Vzcy5lbnYuTk9fUFJPWFk7XG4gICAgICAgIHZhciBzaG91bGRQcm94eSA9IHRydWU7XG5cbiAgICAgICAgaWYgKG5vUHJveHlFbnYpIHtcbiAgICAgICAgICB2YXIgbm9Qcm94eSA9IG5vUHJveHlFbnYuc3BsaXQoJywnKS5tYXAoZnVuY3Rpb24gdHJpbShzKSB7XG4gICAgICAgICAgICByZXR1cm4gcy50cmltKCk7XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBzaG91bGRQcm94eSA9ICFub1Byb3h5LnNvbWUoZnVuY3Rpb24gcHJveHlNYXRjaChwcm94eUVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmICghcHJveHlFbGVtZW50KSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm94eUVsZW1lbnQgPT09ICcqJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwcm94eUVsZW1lbnRbMF0gPT09ICcuJyAmJlxuICAgICAgICAgICAgICAgIHBhcnNlZC5ob3N0bmFtZS5zdWJzdHIocGFyc2VkLmhvc3RuYW1lLmxlbmd0aCAtIHByb3h5RWxlbWVudC5sZW5ndGgpID09PSBwcm94eUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBwYXJzZWQuaG9zdG5hbWUgPT09IHByb3h5RWxlbWVudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG5cbiAgICAgICAgaWYgKHNob3VsZFByb3h5KSB7XG4gICAgICAgICAgcHJveHkgPSB7XG4gICAgICAgICAgICBob3N0OiBwYXJzZWRQcm94eVVybC5ob3N0bmFtZSxcbiAgICAgICAgICAgIHBvcnQ6IHBhcnNlZFByb3h5VXJsLnBvcnRcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHBhcnNlZFByb3h5VXJsLmF1dGgpIHtcbiAgICAgICAgICAgIHZhciBwcm94eVVybEF1dGggPSBwYXJzZWRQcm94eVVybC5hdXRoLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBwcm94eS5hdXRoID0ge1xuICAgICAgICAgICAgICB1c2VybmFtZTogcHJveHlVcmxBdXRoWzBdLFxuICAgICAgICAgICAgICBwYXNzd29yZDogcHJveHlVcmxBdXRoWzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcm94eSkge1xuICAgICAgb3B0aW9ucy5ob3N0bmFtZSA9IHByb3h5Lmhvc3Q7XG4gICAgICBvcHRpb25zLmhvc3QgPSBwcm94eS5ob3N0O1xuICAgICAgb3B0aW9ucy5oZWFkZXJzLmhvc3QgPSBwYXJzZWQuaG9zdG5hbWUgKyAocGFyc2VkLnBvcnQgPyAnOicgKyBwYXJzZWQucG9ydCA6ICcnKTtcbiAgICAgIG9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQ7XG4gICAgICBvcHRpb25zLnBhdGggPSBwcm90b2NvbCArICcvLycgKyBwYXJzZWQuaG9zdG5hbWUgKyAocGFyc2VkLnBvcnQgPyAnOicgKyBwYXJzZWQucG9ydCA6ICcnKSArIG9wdGlvbnMucGF0aDtcblxuICAgICAgLy8gQmFzaWMgcHJveHkgYXV0aG9yaXphdGlvblxuICAgICAgaWYgKHByb3h5LmF1dGgpIHtcbiAgICAgICAgdmFyIGJhc2U2NCA9IEJ1ZmZlci5mcm9tKHByb3h5LmF1dGgudXNlcm5hbWUgKyAnOicgKyBwcm94eS5hdXRoLnBhc3N3b3JkLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgICAgb3B0aW9ucy5oZWFkZXJzWydQcm94eS1BdXRob3JpemF0aW9uJ10gPSAnQmFzaWMgJyArIGJhc2U2NDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgdHJhbnNwb3J0O1xuICAgIHZhciBpc0h0dHBzUHJveHkgPSBpc0h0dHBzUmVxdWVzdCAmJiAocHJveHkgPyBpc0h0dHBzLnRlc3QocHJveHkucHJvdG9jb2wpIDogdHJ1ZSk7XG4gICAgaWYgKGNvbmZpZy50cmFuc3BvcnQpIHtcbiAgICAgIHRyYW5zcG9ydCA9IGNvbmZpZy50cmFuc3BvcnQ7XG4gICAgfSBlbHNlIGlmIChjb25maWcubWF4UmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0cmFuc3BvcnQgPSBpc0h0dHBzUHJveHkgPyBodHRwcyA6IGh0dHA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjb25maWcubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gY29uZmlnLm1heFJlZGlyZWN0cztcbiAgICAgIH1cbiAgICAgIHRyYW5zcG9ydCA9IGlzSHR0cHNQcm94eSA/IGh0dHBzRm9sbG93IDogaHR0cEZvbGxvdztcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLm1heENvbnRlbnRMZW5ndGggJiYgY29uZmlnLm1heENvbnRlbnRMZW5ndGggPiAtMSkge1xuICAgICAgb3B0aW9ucy5tYXhCb2R5TGVuZ3RoID0gY29uZmlnLm1heENvbnRlbnRMZW5ndGg7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIHRoZSByZXF1ZXN0XG4gICAgdmFyIHJlcSA9IHRyYW5zcG9ydC5yZXF1ZXN0KG9wdGlvbnMsIGZ1bmN0aW9uIGhhbmRsZVJlc3BvbnNlKHJlcykge1xuICAgICAgaWYgKHJlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICAgIC8vIHVuY29tcHJlc3MgdGhlIHJlc3BvbnNlIGJvZHkgdHJhbnNwYXJlbnRseSBpZiByZXF1aXJlZFxuICAgICAgdmFyIHN0cmVhbSA9IHJlcztcbiAgICAgIHN3aXRjaCAocmVzLmhlYWRlcnNbJ2NvbnRlbnQtZW5jb2RpbmcnXSkge1xuICAgICAgLyplc2xpbnQgZGVmYXVsdC1jYXNlOjAqL1xuICAgICAgY2FzZSAnZ3ppcCc6XG4gICAgICBjYXNlICdjb21wcmVzcyc6XG4gICAgICBjYXNlICdkZWZsYXRlJzpcbiAgICAgICAgLy8gYWRkIHRoZSB1bnppcHBlciB0byB0aGUgYm9keSBzdHJlYW0gcHJvY2Vzc2luZyBwaXBlbGluZVxuICAgICAgICBzdHJlYW0gPSAocmVzLnN0YXR1c0NvZGUgPT09IDIwNCkgPyBzdHJlYW0gOiBzdHJlYW0ucGlwZSh6bGliLmNyZWF0ZVVuemlwKCkpO1xuXG4gICAgICAgIC8vIHJlbW92ZSB0aGUgY29udGVudC1lbmNvZGluZyBpbiBvcmRlciB0byBub3QgY29uZnVzZSBkb3duc3RyZWFtIG9wZXJhdGlvbnNcbiAgICAgICAgZGVsZXRlIHJlcy5oZWFkZXJzWydjb250ZW50LWVuY29kaW5nJ107XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyByZXR1cm4gdGhlIGxhc3QgcmVxdWVzdCBpbiBjYXNlIG9mIHJlZGlyZWN0c1xuICAgICAgdmFyIGxhc3RSZXF1ZXN0ID0gcmVzLnJlcSB8fCByZXE7XG5cbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgc3RhdHVzOiByZXMuc3RhdHVzQ29kZSxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVzLnN0YXR1c01lc3NhZ2UsXG4gICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogbGFzdFJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlID09PSAnc3RyZWFtJykge1xuICAgICAgICByZXNwb25zZS5kYXRhID0gc3RyZWFtO1xuICAgICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzcG9uc2VCdWZmZXIgPSBbXTtcbiAgICAgICAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRGF0YShjaHVuaykge1xuICAgICAgICAgIHJlc3BvbnNlQnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBjb250ZW50IGxlbmd0aCBpcyBub3Qgb3ZlciB0aGUgbWF4Q29udGVudExlbmd0aCBpZiBzcGVjaWZpZWRcbiAgICAgICAgICBpZiAoY29uZmlnLm1heENvbnRlbnRMZW5ndGggPiAtMSAmJiBCdWZmZXIuY29uY2F0KHJlc3BvbnNlQnVmZmVyKS5sZW5ndGggPiBjb25maWcubWF4Q29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlamVjdChjcmVhdGVFcnJvcignbWF4Q29udGVudExlbmd0aCBzaXplIG9mICcgKyBjb25maWcubWF4Q29udGVudExlbmd0aCArICcgZXhjZWVkZWQnLFxuICAgICAgICAgICAgICBjb25maWcsIG51bGwsIGxhc3RSZXF1ZXN0KSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRXJyb3IoZXJyKSB7XG4gICAgICAgICAgaWYgKHJlcS5hYm9ydGVkKSByZXR1cm47XG4gICAgICAgICAgcmVqZWN0KGVuaGFuY2VFcnJvcihlcnIsIGNvbmZpZywgbnVsbCwgbGFzdFJlcXVlc3QpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiBoYW5kbGVTdHJlYW1FbmQoKSB7XG4gICAgICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9IEJ1ZmZlci5jb25jYXQocmVzcG9uc2VCdWZmZXIpO1xuICAgICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgICAgICByZXNwb25zZURhdGEgPSByZXNwb25zZURhdGEudG9TdHJpbmcoY29uZmlnLnJlc3BvbnNlRW5jb2RpbmcpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3BvbnNlLmRhdGEgPSByZXNwb25zZURhdGE7XG4gICAgICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSBlcnJvcnNcbiAgICByZXEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdEVycm9yKGVycikge1xuICAgICAgaWYgKHJlcS5hYm9ydGVkKSByZXR1cm47XG4gICAgICByZWplY3QoZW5oYW5jZUVycm9yKGVyciwgY29uZmlnLCBudWxsLCByZXEpKTtcbiAgICB9KTtcblxuICAgIC8vIEhhbmRsZSByZXF1ZXN0IHRpbWVvdXRcbiAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgIC8vIFNvbWV0aW1lLCB0aGUgcmVzcG9uc2Ugd2lsbCBiZSB2ZXJ5IHNsb3csIGFuZCBkb2VzIG5vdCByZXNwb25kLCB0aGUgY29ubmVjdCBldmVudCB3aWxsIGJlIGJsb2NrIGJ5IGV2ZW50IGxvb3Agc3lzdGVtLlxuICAgICAgLy8gQW5kIHRpbWVyIGNhbGxiYWNrIHdpbGwgYmUgZmlyZWQsIGFuZCBhYm9ydCgpIHdpbGwgYmUgaW52b2tlZCBiZWZvcmUgY29ubmVjdGlvbiwgdGhlbiBnZXQgXCJzb2NrZXQgaGFuZyB1cFwiIGFuZCBjb2RlIEVDT05OUkVTRVQuXG4gICAgICAvLyBBdCB0aGlzIHRpbWUsIGlmIHdlIGhhdmUgYSBsYXJnZSBudW1iZXIgb2YgcmVxdWVzdCwgbm9kZWpzIHdpbGwgaGFuZyB1cCBzb21lIHNvY2tldCBvbiBiYWNrZ3JvdW5kLiBhbmQgdGhlIG51bWJlciB3aWxsIHVwIGFuZCB1cC5cbiAgICAgIC8vIEFuZCB0aGVuIHRoZXNlIHNvY2tldCB3aGljaCBiZSBoYW5nIHVwIHdpbGwgZGV2b3JpbmcgQ1BVIGxpdHRsZSBieSBsaXR0bGUuXG4gICAgICAvLyBDbGllbnRSZXF1ZXN0LnNldFRpbWVvdXQgd2lsbCBiZSBmaXJlZCBvbiB0aGUgc3BlY2lmeSBtaWxsaXNlY29uZHMsIGFuZCBjYW4gbWFrZSBzdXJlIHRoYXQgYWJvcnQoKSB3aWxsIGJlIGZpcmVkIGFmdGVyIGNvbm5lY3QuXG4gICAgICByZXEuc2V0VGltZW91dChjb25maWcudGltZW91dCwgZnVuY3Rpb24gaGFuZGxlUmVxdWVzdFRpbWVvdXQoKSB7XG4gICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmIChyZXEuYWJvcnRlZCkgcmV0dXJuO1xuXG4gICAgICAgIHJlcS5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICBpZiAodXRpbHMuaXNTdHJlYW0oZGF0YSkpIHtcbiAgICAgIGRhdGEub24oJ2Vycm9yJywgZnVuY3Rpb24gaGFuZGxlU3RyZWFtRXJyb3IoZXJyKSB7XG4gICAgICAgIHJlamVjdChlbmhhbmNlRXJyb3IoZXJyLCBjb25maWcsIG51bGwsIHJlcSkpO1xuICAgICAgfSkucGlwZShyZXEpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXEuZW5kKGRhdGEpO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgYnVpbGRGdWxsUGF0aCA9IHJlcXVpcmUoJy4uL2NvcmUvYnVpbGRGdWxsUGF0aCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKHRpbWVvdXRFcnJvck1lc3NhZ2UsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIG1lcmdlQ29uZmlnID0gcmVxdWlyZSgnLi9jb3JlL21lcmdlQ29uZmlnJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKG1lcmdlQ29uZmlnKGF4aW9zLmRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIENhbmNlbCA9IHJlcXVpcmUoJy4vQ2FuY2VsJyk7XG5cbi8qKlxuICogQSBgQ2FuY2VsVG9rZW5gIGlzIGFuIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcXVlc3QgY2FuY2VsbGF0aW9uIG9mIGFuIG9wZXJhdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGV4ZWN1dG9yIFRoZSBleGVjdXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcbiAgaWYgKHR5cGVvZiBleGVjdXRvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2V4ZWN1dG9yIG11c3QgYmUgYSBmdW5jdGlvbi4nKTtcbiAgfVxuXG4gIHZhciByZXNvbHZlUHJvbWlzZTtcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcbiAgICByZXNvbHZlUHJvbWlzZSA9IHJlc29sdmU7XG4gIH0pO1xuXG4gIHZhciB0b2tlbiA9IHRoaXM7XG4gIGV4ZWN1dG9yKGZ1bmN0aW9uIGNhbmNlbChtZXNzYWdlKSB7XG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xuICAgICAgLy8gQ2FuY2VsbGF0aW9uIGhhcyBhbHJlYWR5IGJlZW4gcmVxdWVzdGVkXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdG9rZW4ucmVhc29uID0gbmV3IENhbmNlbChtZXNzYWdlKTtcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5DYW5jZWxUb2tlbi5wcm90b3R5cGUudGhyb3dJZlJlcXVlc3RlZCA9IGZ1bmN0aW9uIHRocm93SWZSZXF1ZXN0ZWQoKSB7XG4gIGlmICh0aGlzLnJlYXNvbikge1xuICAgIHRocm93IHRoaXMucmVhc29uO1xuICB9XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBuZXcgYENhbmNlbFRva2VuYCBhbmQgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXG4gKi9cbkNhbmNlbFRva2VuLnNvdXJjZSA9IGZ1bmN0aW9uIHNvdXJjZSgpIHtcbiAgdmFyIGNhbmNlbDtcbiAgdmFyIHRva2VuID0gbmV3IENhbmNlbFRva2VuKGZ1bmN0aW9uIGV4ZWN1dG9yKGMpIHtcbiAgICBjYW5jZWwgPSBjO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICB0b2tlbjogdG9rZW4sXG4gICAgY2FuY2VsOiBjYW5jZWxcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsVG9rZW47XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcbnZhciBtZXJnZUNvbmZpZyA9IHJlcXVpcmUoJy4vbWVyZ2VDb25maWcnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IGFyZ3VtZW50c1sxXSB8fCB7fTtcbiAgICBjb25maWcudXJsID0gYXJndW1lbnRzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcbiAgfVxuXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG5cbiAgLy8gU2V0IGNvbmZpZy5tZXRob2RcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcbiAgICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2UgaWYgKHRoaXMuZGVmYXVsdHMubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XG4gIH0gZWxzZSB7XG4gICAgY29uZmlnLm1ldGhvZCA9ICdnZXQnO1xuICB9XG5cbiAgLy8gSG9vayB1cCBpbnRlcmNlcHRvcnMgbWlkZGxld2FyZVxuICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xuICB2YXIgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZShjb25maWcpO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZm9yRWFjaChmdW5jdGlvbiB1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnVuc2hpZnQoaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgd2hpbGUgKGNoYWluLmxlbmd0aCkge1xuICAgIHByb21pc2UgPSBwcm9taXNlLnRoZW4oY2hhaW4uc2hpZnQoKSwgY2hhaW4uc2hpZnQoKSk7XG4gIH1cblxuICByZXR1cm4gcHJvbWlzZTtcbn07XG5cbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XG4gIHJldHVybiBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplcikucmVwbGFjZSgvXlxcPy8sICcnKTtcbn07XG5cbi8vIFByb3ZpZGUgYWxpYXNlcyBmb3Igc3VwcG9ydGVkIHJlcXVlc3QgbWV0aG9kc1xudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdvcHRpb25zJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybFxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQXhpb3M7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuZnVuY3Rpb24gSW50ZXJjZXB0b3JNYW5hZ2VyKCkge1xuICB0aGlzLmhhbmRsZXJzID0gW107XG59XG5cbi8qKlxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bGZpbGxlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGB0aGVuYCBmb3IgYSBgUHJvbWlzZWBcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBBbiBJRCB1c2VkIHRvIHJlbW92ZSBpbnRlcmNlcHRvciBsYXRlclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmdWxmaWxsZWQsIHJlamVjdGVkKSB7XG4gIHRoaXMuaGFuZGxlcnMucHVzaCh7XG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXG4gICAgcmVqZWN0ZWQ6IHJlamVjdGVkXG4gIH0pO1xuICByZXR1cm4gdGhpcy5oYW5kbGVycy5sZW5ndGggLSAxO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gaWQgVGhlIElEIHRoYXQgd2FzIHJldHVybmVkIGJ5IGB1c2VgXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZWplY3QgPSBmdW5jdGlvbiBlamVjdChpZCkge1xuICBpZiAodGhpcy5oYW5kbGVyc1tpZF0pIHtcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGFsbCB0aGUgcmVnaXN0ZXJlZCBpbnRlcmNlcHRvcnNcbiAqXG4gKiBUaGlzIG1ldGhvZCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciBza2lwcGluZyBvdmVyIGFueVxuICogaW50ZXJjZXB0b3JzIHRoYXQgbWF5IGhhdmUgYmVjb21lIGBudWxsYCBjYWxsaW5nIGBlamVjdGAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGVhY2ggaW50ZXJjZXB0b3JcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xuICB1dGlscy5mb3JFYWNoKHRoaXMuaGFuZGxlcnMsIGZ1bmN0aW9uIGZvckVhY2hIYW5kbGVyKGgpIHtcbiAgICBpZiAoaCAhPT0gbnVsbCkge1xuICAgICAgZm4oaCk7XG4gICAgfVxuICB9KTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSW50ZXJjZXB0b3JNYW5hZ2VyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi4vaGVscGVycy9jb21iaW5lVVJMcycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXG4gKiBvbmx5IHdoZW4gdGhlIHJlcXVlc3RlZFVSTCBpcyBub3QgYWxyZWFkeSBhbiBhYnNvbHV0ZSBVUkwuXG4gKiBJZiB0aGUgcmVxdWVzdFVSTCBpcyBhYnNvbHV0ZSwgdGhpcyBmdW5jdGlvbiByZXR1cm5zIHRoZSByZXF1ZXN0ZWRVUkwgdW50b3VjaGVkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcXVlc3RlZFVSTCBBYnNvbHV0ZSBvciByZWxhdGl2ZSBVUkwgdG8gY29tYmluZVxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkRnVsbFBhdGgoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKSB7XG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcbiAgICByZXR1cm4gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVxdWVzdGVkVVJMKTtcbiAgfVxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGVuaGFuY2VFcnJvciA9IHJlcXVpcmUoJy4vZW5oYW5jZUVycm9yJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBjcmVhdGVkIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICByZXR1cm4gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1xuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVXBkYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBjb25maWcsIGVycm9yIGNvZGUsIGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtjb2RlXSBUaGUgZXJyb3IgY29kZSAoZm9yIGV4YW1wbGUsICdFQ09OTkFCT1JURUQnKS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXG4gKiBAcmV0dXJucyB7RXJyb3J9IFRoZSBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgZXJyb3IuY29uZmlnID0gY29uZmlnO1xuICBpZiAoY29kZSkge1xuICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICB9XG5cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XG5cbiAgZXJyb3IudG9KU09OID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIFN0YW5kYXJkXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAvLyBNaWNyb3NvZnRcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxuICAgICAgbnVtYmVyOiB0aGlzLm51bWJlcixcbiAgICAgIC8vIE1vemlsbGFcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogdGhpcy5saW5lTnVtYmVyLFxuICAgICAgY29sdW1uTnVtYmVyOiB0aGlzLmNvbHVtbk51bWJlcixcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgLy8gQXhpb3NcbiAgICAgIGNvbmZpZzogdGhpcy5jb25maWcsXG4gICAgICBjb2RlOiB0aGlzLmNvZGVcbiAgICB9O1xuICB9O1xuICByZXR1cm4gZXJyb3I7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG4vKipcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcbiAqIGJ5IG1lcmdpbmcgdHdvIGNvbmZpZ3VyYXRpb24gb2JqZWN0cyB0b2dldGhlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZzJcbiAqIEByZXR1cm5zIHtPYmplY3R9IE5ldyBvYmplY3QgcmVzdWx0aW5nIGZyb20gbWVyZ2luZyBjb25maWcyIHRvIGNvbmZpZzFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtZXJnZUNvbmZpZyhjb25maWcxLCBjb25maWcyKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcbiAgdmFyIGNvbmZpZyA9IHt9O1xuXG4gIHZhciB2YWx1ZUZyb21Db25maWcyS2V5cyA9IFsndXJsJywgJ21ldGhvZCcsICdwYXJhbXMnLCAnZGF0YSddO1xuICB2YXIgbWVyZ2VEZWVwUHJvcGVydGllc0tleXMgPSBbJ2hlYWRlcnMnLCAnYXV0aCcsICdwcm94eSddO1xuICB2YXIgZGVmYXVsdFRvQ29uZmlnMktleXMgPSBbXG4gICAgJ2Jhc2VVUkwnLCAndXJsJywgJ3RyYW5zZm9ybVJlcXVlc3QnLCAndHJhbnNmb3JtUmVzcG9uc2UnLCAncGFyYW1zU2VyaWFsaXplcicsXG4gICAgJ3RpbWVvdXQnLCAnd2l0aENyZWRlbnRpYWxzJywgJ2FkYXB0ZXInLCAncmVzcG9uc2VUeXBlJywgJ3hzcmZDb29raWVOYW1lJyxcbiAgICAneHNyZkhlYWRlck5hbWUnLCAnb25VcGxvYWRQcm9ncmVzcycsICdvbkRvd25sb2FkUHJvZ3Jlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ3ZhbGlkYXRlU3RhdHVzJywgJ21heFJlZGlyZWN0cycsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnXG4gIF07XG5cbiAgdXRpbHMuZm9yRWFjaCh2YWx1ZUZyb21Db25maWcyS2V5cywgZnVuY3Rpb24gdmFsdWVGcm9tQ29uZmlnMihwcm9wKSB7XG4gICAgaWYgKHR5cGVvZiBjb25maWcyW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnW3Byb3BdID0gY29uZmlnMltwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gobWVyZ2VEZWVwUHJvcGVydGllc0tleXMsIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICh1dGlscy5pc09iamVjdChjb25maWcyW3Byb3BdKSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gdXRpbHMuZGVlcE1lcmdlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZzJbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcyW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QoY29uZmlnMVtwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IHV0aWxzLmRlZXBNZXJnZShjb25maWcxW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb25maWcxW3Byb3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uZmlnW3Byb3BdID0gY29uZmlnMVtwcm9wXTtcbiAgICB9XG4gIH0pO1xuXG4gIHV0aWxzLmZvckVhY2goZGVmYXVsdFRvQ29uZmlnMktleXMsIGZ1bmN0aW9uIGRlZmF1bHRUb0NvbmZpZzIocHJvcCkge1xuICAgIGlmICh0eXBlb2YgY29uZmlnMltwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzJbcHJvcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29uZmlnMVtwcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGNvbmZpZzFbcHJvcF07XG4gICAgfVxuICB9KTtcblxuICB2YXIgYXhpb3NLZXlzID0gdmFsdWVGcm9tQ29uZmlnMktleXNcbiAgICAuY29uY2F0KG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzKVxuICAgIC5jb25jYXQoZGVmYXVsdFRvQ29uZmlnMktleXMpO1xuXG4gIHZhciBvdGhlcktleXMgPSBPYmplY3RcbiAgICAua2V5cyhjb25maWcyKVxuICAgIC5maWx0ZXIoZnVuY3Rpb24gZmlsdGVyQXhpb3NLZXlzKGtleSkge1xuICAgICAgcmV0dXJuIGF4aW9zS2V5cy5pbmRleE9mKGtleSkgPT09IC0xO1xuICAgIH0pO1xuXG4gIHV0aWxzLmZvckVhY2gob3RoZXJLZXlzLCBmdW5jdGlvbiBvdGhlcktleXNEZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZzJbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcyW3Byb3BdO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbmZpZzFbcHJvcF0gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBjb25maWcxW3Byb3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICAvKipcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXG4gICAqIHRpbWVvdXQgaXMgbm90IGNyZWF0ZWQuXG4gICAqL1xuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBiaW5kKGZuLCB0aGlzQXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKCkge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBlbmNvZGUodmFsKSB7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQodmFsKS5cbiAgICByZXBsYWNlKC8lNDAvZ2ksICdAJykuXG4gICAgcmVwbGFjZSgvJTNBL2dpLCAnOicpLlxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxuICAgIHJlcGxhY2UoLyUyQy9naSwgJywnKS5cbiAgICByZXBsYWNlKC8lMjAvZywgJysnKS5cbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXG4gICAgcmVwbGFjZSgvJTVEL2dpLCAnXScpO1xufVxuXG4vKipcbiAqIEJ1aWxkIGEgVVJMIGJ5IGFwcGVuZGluZyBwYXJhbXMgdG8gdGhlIGVuZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIGJhc2Ugb2YgdGhlIHVybCAoZS5nLiwgaHR0cDovL3d3dy5nb29nbGUuY29tKVxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIFRoZSBwYXJhbXMgdG8gYmUgYXBwZW5kZWRcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRVUkwodXJsLCBwYXJhbXMsIHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIGlmICghcGFyYW1zKSB7XG4gICAgcmV0dXJuIHVybDtcbiAgfVxuXG4gIHZhciBzZXJpYWxpemVkUGFyYW1zO1xuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXNTZXJpYWxpemVyKHBhcmFtcyk7XG4gIH0gZWxzZSBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMocGFyYW1zKSkge1xuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBbXTtcblxuICAgIHV0aWxzLmZvckVhY2gocGFyYW1zLCBmdW5jdGlvbiBzZXJpYWxpemUodmFsLCBrZXkpIHtcbiAgICAgIGlmICh2YWwgPT09IG51bGwgfHwgdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIGtleSA9IGtleSArICdbXSc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBbdmFsXTtcbiAgICAgIH1cblxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xuICAgICAgICBpZiAodXRpbHMuaXNEYXRlKHYpKSB7XG4gICAgICAgICAgdiA9IHYudG9JU09TdHJpbmcoKTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xuICAgICAgICAgIHYgPSBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcnRzLmpvaW4oJyYnKTtcbiAgfVxuXG4gIGlmIChzZXJpYWxpemVkUGFyYW1zKSB7XG4gICAgdmFyIGhhc2htYXJrSW5kZXggPSB1cmwuaW5kZXhPZignIycpO1xuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xuICAgICAgdXJsID0gdXJsLnNsaWNlKDAsIGhhc2htYXJrSW5kZXgpO1xuICAgIH1cblxuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICAgIHZhciBjb29raWUgPSBbXTtcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdwYXRoPScgKyBwYXRoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ2RvbWFpbj0nICsgZG9tYWluKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgICB0aGlzLndyaXRlKG5hbWUsICcnLCBEYXRlLm5vdygpIC0gODY0MDAwMDApO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQoKSB7IHJldHVybiBudWxsOyB9LFxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgVVJMIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBzcGVjaWZpZWQgVVJMIGlzIGFic29sdXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0Fic29sdXRlVVJMKHVybCkge1xuICAvLyBBIFVSTCBpcyBjb25zaWRlcmVkIGFic29sdXRlIGlmIGl0IGJlZ2lucyB3aXRoIFwiPHNjaGVtZT46Ly9cIiBvciBcIi8vXCIgKHByb3RvY29sLXJlbGF0aXZlIFVSTCkuXG4gIC8vIFJGQyAzOTg2IGRlZmluZXMgc2NoZW1lIG5hbWUgYXMgYSBzZXF1ZW5jZSBvZiBjaGFyYWN0ZXJzIGJlZ2lubmluZyB3aXRoIGEgbGV0dGVyIGFuZCBmb2xsb3dlZFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cbiAgcmV0dXJuIC9eKFthLXpdW2EtelxcZFxcK1xcLVxcLl0qOik/XFwvXFwvL2kudGVzdCh1cmwpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgICB2YXIgb3JpZ2luVVJMO1xuXG4gICAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICAgIHZhciBocmVmID0gdXJsO1xuXG4gICAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICBocmVmID0gdXJsUGFyc2luZ05vZGUuaHJlZjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAgIC8vIHVybFBhcnNpbmdOb2RlIHByb3ZpZGVzIHRoZSBVcmxVdGlscyBpbnRlcmZhY2UgLSBodHRwOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsdXRpbHNcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICAgIHByb3RvY29sOiB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbCA/IHVybFBhcnNpbmdOb2RlLnByb3RvY29sLnJlcGxhY2UoLzokLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcbiAgICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XG4gICAgICAgICAgICB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZSA6XG4gICAgICAgICAgICAnLycgKyB1cmxQYXJzaW5nTm9kZS5wYXRobmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcblxuICAgICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcbiAgICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICAgIH07XG4gICAgfSkoKSA6XG5cbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cbiAgICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuICAgIH0pKClcbik7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCBub3JtYWxpemVkTmFtZSkge1xuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcbiAgICBpZiAobmFtZSAhPT0gbm9ybWFsaXplZE5hbWUgJiYgbmFtZS50b1VwcGVyQ2FzZSgpID09PSBub3JtYWxpemVkTmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBoZWFkZXJzW25vcm1hbGl6ZWROYW1lXSA9IHZhbHVlO1xuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XG4gICAgfVxuICB9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFN5bnRhY3RpYyBzdWdhciBmb3IgaW52b2tpbmcgYSBmdW5jdGlvbiBhbmQgZXhwYW5kaW5nIGFuIGFycmF5IGZvciBhcmd1bWVudHMuXG4gKlxuICogQ29tbW9uIHVzZSBjYXNlIHdvdWxkIGJlIHRvIHVzZSBgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5YC5cbiAqXG4gKiAgYGBganNcbiAqICBmdW5jdGlvbiBmKHgsIHksIHopIHt9XG4gKiAgdmFyIGFyZ3MgPSBbMSwgMiwgM107XG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcbiAqICBgYGBcbiAqXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cbiAqXG4gKiAgYGBganNcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XG4gKiAgYGBgXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoYXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KG51bGwsIGFycik7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG5cbi8qZ2xvYmFsIHRvU3RyaW5nOnRydWUqL1xuXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xuXG52YXIgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXksIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5KHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VuZGVmaW5lZCh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiAhaXNVbmRlZmluZWQodmFsKSAmJiB2YWwuY29uc3RydWN0b3IgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbC5jb25zdHJ1Y3RvcilcbiAgICAmJiB0eXBlb2YgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlcih2YWwpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRm9ybURhdGFcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBGb3JtRGF0YSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XG4gIHJldHVybiAodHlwZW9mIEZvcm1EYXRhICE9PSAndW5kZWZpbmVkJykgJiYgKHZhbCBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyh2YWwpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKCh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnKSAmJiAoQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIHJlc3VsdCA9IEFycmF5QnVmZmVyLmlzVmlldyh2YWwpO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdCA9ICh2YWwpICYmICh2YWwuYnVmZmVyKSAmJiAodmFsLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJpbmcsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc051bWJlcih2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIE9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gdmFsICE9PSBudWxsICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRGF0ZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRmlsZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRmlsZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRmlsZV0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgQmxvYlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQmxvYiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQmxvYih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQmxvYl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmVhbVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyZWFtLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWwpICYmIGlzRnVuY3Rpb24odmFsLnBpcGUpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgVVJMU2VhcmNoUGFyYW1zIG9iamVjdCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVVJMU2VhcmNoUGFyYW1zKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIFVSTFNlYXJjaFBhcmFtcyAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zO1xufVxuXG4vKipcbiAqIFRyaW0gZXhjZXNzIHdoaXRlc3BhY2Ugb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIGVuZCBvZiBhIHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgU3RyaW5nIGZyZWVkIG9mIGV4Y2VzcyB3aGl0ZXNwYWNlXG4gKi9cbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvXlxccyovLCAnJykucmVwbGFjZSgvXFxzKiQvLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gZXF1YWwgdG8gbWVyZ2Ugd2l0aCB0aGUgZGlmZmVyZW5jZSBiZWluZyB0aGF0IG5vIHJlZmVyZW5jZVxuICogdG8gb3JpZ2luYWwgb2JqZWN0cyBpcyBrZXB0LlxuICpcbiAqIEBzZWUgbWVyZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxuICogQHJldHVybnMge09iamVjdH0gUmVzdWx0IG9mIGFsbCBtZXJnZSBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGRlZXBNZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IGRlZXBNZXJnZSh7fSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBkZWVwTWVyZ2U6IGRlZXBNZXJnZSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRyaW06IHRyaW1cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsoXG4gICAgICB1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpXG4gICAgKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDJdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xuICAgICAgJz09J1xuICAgIClcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xuICAgICAgbG9va3VwWyh0bXAgPj4gNCkgJiAweDNGXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdICtcbiAgICAgICc9J1xuICAgIClcbiAgfVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50IGNhbWVsY2FzZTogXCJvZmZcIiAqL1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG5cbnZhciBac3RyZWFtID0gcmVxdWlyZSgncGFrby9saWIvemxpYi96c3RyZWFtJyk7XG52YXIgemxpYl9kZWZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9kZWZsYXRlLmpzJyk7XG52YXIgemxpYl9pbmZsYXRlID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9pbmZsYXRlLmpzJyk7XG52YXIgY29uc3RhbnRzID0gcmVxdWlyZSgncGFrby9saWIvemxpYi9jb25zdGFudHMnKTtcblxuZm9yICh2YXIga2V5IGluIGNvbnN0YW50cykge1xuICBleHBvcnRzW2tleV0gPSBjb25zdGFudHNba2V5XTtcbn1cblxuLy8gemxpYiBtb2Rlc1xuZXhwb3J0cy5OT05FID0gMDtcbmV4cG9ydHMuREVGTEFURSA9IDE7XG5leHBvcnRzLklORkxBVEUgPSAyO1xuZXhwb3J0cy5HWklQID0gMztcbmV4cG9ydHMuR1VOWklQID0gNDtcbmV4cG9ydHMuREVGTEFURVJBVyA9IDU7XG5leHBvcnRzLklORkxBVEVSQVcgPSA2O1xuZXhwb3J0cy5VTlpJUCA9IDc7XG5cbnZhciBHWklQX0hFQURFUl9JRDEgPSAweDFmO1xudmFyIEdaSVBfSEVBREVSX0lEMiA9IDB4OGI7XG5cbi8qKlxuICogRW11bGF0ZSBOb2RlJ3MgemxpYiBDKysgbGF5ZXIgZm9yIHVzZSBieSB0aGUgSlMgbGF5ZXIgaW4gaW5kZXguanNcbiAqL1xuZnVuY3Rpb24gWmxpYihtb2RlKSB7XG4gIGlmICh0eXBlb2YgbW9kZSAhPT0gJ251bWJlcicgfHwgbW9kZSA8IGV4cG9ydHMuREVGTEFURSB8fCBtb2RlID4gZXhwb3J0cy5VTlpJUCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0JhZCBhcmd1bWVudCcpO1xuICB9XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbiAgdGhpcy5lcnIgPSAwO1xuICB0aGlzLmZsdXNoID0gMDtcbiAgdGhpcy5pbml0X2RvbmUgPSBmYWxzZTtcbiAgdGhpcy5sZXZlbCA9IDA7XG4gIHRoaXMubWVtTGV2ZWwgPSAwO1xuICB0aGlzLm1vZGUgPSBtb2RlO1xuICB0aGlzLnN0cmF0ZWd5ID0gMDtcbiAgdGhpcy53aW5kb3dCaXRzID0gMDtcbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuICB0aGlzLnBlbmRpbmdfY2xvc2UgPSBmYWxzZTtcbiAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAwO1xufVxuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnBlbmRpbmdfY2xvc2UgPSB0cnVlO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMucGVuZGluZ19jbG9zZSA9IGZhbHNlO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ2Nsb3NlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgPD0gZXhwb3J0cy5VTlpJUCk7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXKSB7XG4gICAgemxpYl9kZWZsYXRlLmRlZmxhdGVFbmQodGhpcy5zdHJtKTtcbiAgfSBlbHNlIGlmICh0aGlzLm1vZGUgPT09IGV4cG9ydHMuSU5GTEFURSB8fCB0aGlzLm1vZGUgPT09IGV4cG9ydHMuR1VOWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5VTlpJUCkge1xuICAgIHpsaWJfaW5mbGF0ZS5pbmZsYXRlRW5kKHRoaXMuc3RybSk7XG4gIH1cblxuICB0aGlzLm1vZGUgPSBleHBvcnRzLk5PTkU7XG5cbiAgdGhpcy5kaWN0aW9uYXJ5ID0gbnVsbDtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGZsdXNoLCBpbnB1dCwgaW5fb2ZmLCBpbl9sZW4sIG91dCwgb3V0X29mZiwgb3V0X2xlbikge1xuICByZXR1cm4gdGhpcy5fd3JpdGUodHJ1ZSwgZmx1c2gsIGlucHV0LCBpbl9vZmYsIGluX2xlbiwgb3V0LCBvdXRfb2ZmLCBvdXRfbGVuKTtcbn07XG5cblpsaWIucHJvdG90eXBlLndyaXRlU3luYyA9IGZ1bmN0aW9uIChmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgcmV0dXJuIHRoaXMuX3dyaXRlKGZhbHNlLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGFzeW5jLCBmbHVzaCwgaW5wdXQsIGluX29mZiwgaW5fbGVuLCBvdXQsIG91dF9vZmYsIG91dF9sZW4pIHtcbiAgYXNzZXJ0LmVxdWFsKGFyZ3VtZW50cy5sZW5ndGgsIDgpO1xuXG4gIGFzc2VydCh0aGlzLmluaXRfZG9uZSwgJ3dyaXRlIGJlZm9yZSBpbml0Jyk7XG4gIGFzc2VydCh0aGlzLm1vZGUgIT09IGV4cG9ydHMuTk9ORSwgJ2FscmVhZHkgZmluYWxpemVkJyk7XG4gIGFzc2VydC5lcXVhbChmYWxzZSwgdGhpcy53cml0ZV9pbl9wcm9ncmVzcywgJ3dyaXRlIGFscmVhZHkgaW4gcHJvZ3Jlc3MnKTtcbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCB0aGlzLnBlbmRpbmdfY2xvc2UsICdjbG9zZSBpcyBwZW5kaW5nJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgYXNzZXJ0LmVxdWFsKGZhbHNlLCBmbHVzaCA9PT0gdW5kZWZpbmVkLCAnbXVzdCBwcm92aWRlIGZsdXNoIHZhbHVlJyk7XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IHRydWU7XG5cbiAgaWYgKGZsdXNoICE9PSBleHBvcnRzLlpfTk9fRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9QQVJUSUFMX0ZMVVNIICYmIGZsdXNoICE9PSBleHBvcnRzLlpfU1lOQ19GTFVTSCAmJiBmbHVzaCAhPT0gZXhwb3J0cy5aX0ZVTExfRkxVU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9GSU5JU0ggJiYgZmx1c2ggIT09IGV4cG9ydHMuWl9CTE9DSykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCB2YWx1ZScpO1xuICB9XG5cbiAgaWYgKGlucHV0ID09IG51bGwpIHtcbiAgICBpbnB1dCA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpbl9sZW4gPSAwO1xuICAgIGluX29mZiA9IDA7XG4gIH1cblxuICB0aGlzLnN0cm0uYXZhaWxfaW4gPSBpbl9sZW47XG4gIHRoaXMuc3RybS5pbnB1dCA9IGlucHV0O1xuICB0aGlzLnN0cm0ubmV4dF9pbiA9IGluX29mZjtcbiAgdGhpcy5zdHJtLmF2YWlsX291dCA9IG91dF9sZW47XG4gIHRoaXMuc3RybS5vdXRwdXQgPSBvdXQ7XG4gIHRoaXMuc3RybS5uZXh0X291dCA9IG91dF9vZmY7XG4gIHRoaXMuZmx1c2ggPSBmbHVzaDtcblxuICBpZiAoIWFzeW5jKSB7XG4gICAgLy8gc3luYyB2ZXJzaW9uXG4gICAgdGhpcy5fcHJvY2VzcygpO1xuXG4gICAgaWYgKHRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX2FmdGVyU3luYygpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBhc3luYyB2ZXJzaW9uXG4gIHZhciBzZWxmID0gdGhpcztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgc2VsZi5fcHJvY2VzcygpO1xuICAgIHNlbGYuX2FmdGVyKCk7XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyU3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGF2YWlsX291dCA9IHRoaXMuc3RybS5hdmFpbF9vdXQ7XG4gIHZhciBhdmFpbF9pbiA9IHRoaXMuc3RybS5hdmFpbF9pbjtcblxuICB0aGlzLndyaXRlX2luX3Byb2dyZXNzID0gZmFsc2U7XG5cbiAgcmV0dXJuIFthdmFpbF9pbiwgYXZhaWxfb3V0XTtcbn07XG5cblpsaWIucHJvdG90eXBlLl9wcm9jZXNzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IG51bGw7XG5cbiAgLy8gSWYgdGhlIGF2YWlsX291dCBpcyBsZWZ0IGF0IDAsIHRoZW4gaXQgbWVhbnMgdGhhdCBpdCByYW4gb3V0XG4gIC8vIG9mIHJvb20uICBJZiB0aGVyZSB3YXMgYXZhaWxfb3V0IGxlZnQgb3ZlciwgdGhlbiBpdCBtZWFuc1xuICAvLyB0aGF0IGFsbCBvZiB0aGUgaW5wdXQgd2FzIGNvbnN1bWVkLlxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZSh0aGlzLnN0cm0sIHRoaXMuZmx1c2gpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlVOWklQOlxuICAgICAgaWYgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDApIHtcbiAgICAgICAgbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9IHRoaXMuc3RybS5uZXh0X2luO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKHRoaXMuZ3ppcF9pZF9ieXRlc19yZWFkKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBpZiAobmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHRoaXMuc3RybS5pbnB1dFtuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlXSA9PT0gR1pJUF9IRUFERVJfSUQxKSB7XG4gICAgICAgICAgICB0aGlzLmd6aXBfaWRfYnl0ZXNfcmVhZCA9IDE7XG4gICAgICAgICAgICBuZXh0X2V4cGVjdGVkX2hlYWRlcl9ieXRlKys7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfaW4gPT09IDEpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIG9ubHkgYXZhaWxhYmxlIGJ5dGUgd2FzIGFscmVhZHkgcmVhZC5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAvLyBmYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKG5leHRfZXhwZWN0ZWRfaGVhZGVyX2J5dGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICh0aGlzLnN0cm0uaW5wdXRbbmV4dF9leHBlY3RlZF9oZWFkZXJfYnl0ZV0gPT09IEdaSVBfSEVBREVSX0lEMikge1xuICAgICAgICAgICAgdGhpcy5nemlwX2lkX2J5dGVzX3JlYWQgPSAyO1xuICAgICAgICAgICAgdGhpcy5tb2RlID0gZXhwb3J0cy5HVU5aSVA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIGFjdHVhbCBkaWZmZXJlbmNlIGJldHdlZW4gSU5GTEFURSBhbmQgSU5GTEFURVJBV1xuICAgICAgICAgICAgLy8gKGFmdGVyIGluaXRpYWxpemF0aW9uKS5cbiAgICAgICAgICAgIHRoaXMubW9kZSA9IGV4cG9ydHMuSU5GTEFURTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgbnVtYmVyIG9mIGd6aXAgbWFnaWMgbnVtYmVyIGJ5dGVzIHJlYWQnKTtcbiAgICAgIH1cblxuICAgIC8vIGZhbGx0aHJvdWdoXG4gICAgY2FzZSBleHBvcnRzLklORkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdVTlpJUDpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoXG5cbiAgICAgIC8vIElmIGRhdGEgd2FzIGVuY29kZWQgd2l0aCBkaWN0aW9uYXJ5XG4gICAgICApO2lmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX05FRURfRElDVCAmJiB0aGlzLmRpY3Rpb25hcnkpIHtcbiAgICAgICAgLy8gTG9hZCBpdFxuICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICAgIGlmICh0aGlzLmVyciA9PT0gZXhwb3J0cy5aX09LKSB7XG4gICAgICAgICAgLy8gQW5kIHRyeSB0byBkZWNvZGUgYWdhaW5cbiAgICAgICAgICB0aGlzLmVyciA9IHpsaWJfaW5mbGF0ZS5pbmZsYXRlKHRoaXMuc3RybSwgdGhpcy5mbHVzaCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5lcnIgPT09IGV4cG9ydHMuWl9EQVRBX0VSUk9SKSB7XG4gICAgICAgICAgLy8gQm90aCBpbmZsYXRlU2V0RGljdGlvbmFyeSgpIGFuZCBpbmZsYXRlKCkgcmV0dXJuIFpfREFUQV9FUlJPUi5cbiAgICAgICAgICAvLyBNYWtlIGl0IHBvc3NpYmxlIGZvciBBZnRlcigpIHRvIHRlbGwgYSBiYWQgZGljdGlvbmFyeSBmcm9tIGJhZFxuICAgICAgICAgIC8vIGlucHV0LlxuICAgICAgICAgIHRoaXMuZXJyID0gZXhwb3J0cy5aX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHRoaXMuc3RybS5hdmFpbF9pbiA+IDAgJiYgdGhpcy5tb2RlID09PSBleHBvcnRzLkdVTlpJUCAmJiB0aGlzLmVyciA9PT0gZXhwb3J0cy5aX1NUUkVBTV9FTkQgJiYgdGhpcy5zdHJtLm5leHRfaW5bMF0gIT09IDB4MDApIHtcbiAgICAgICAgLy8gQnl0ZXMgcmVtYWluIGluIGlucHV0IGJ1ZmZlci4gUGVyaGFwcyB0aGlzIGlzIGFub3RoZXIgY29tcHJlc3NlZFxuICAgICAgICAvLyBtZW1iZXIgaW4gdGhlIHNhbWUgYXJjaGl2ZSwgb3IganVzdCB0cmFpbGluZyBnYXJiYWdlLlxuICAgICAgICAvLyBUcmFpbGluZyB6ZXJvIGJ5dGVzIGFyZSBva2F5LCB0aG91Z2gsIHNpbmNlIHRoZXkgYXJlIGZyZXF1ZW50bHlcbiAgICAgICAgLy8gdXNlZCBmb3IgcGFkZGluZy5cblxuICAgICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGUodGhpcy5zdHJtLCB0aGlzLmZsdXNoKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbW9kZSAnICsgdGhpcy5tb2RlKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX2NoZWNrRXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIEFjY2VwdGFibGUgZXJyb3Igc3RhdGVzIGRlcGVuZCBvbiB0aGUgdHlwZSBvZiB6bGliIHN0cmVhbS5cbiAgc3dpdGNoICh0aGlzLmVycikge1xuICAgIGNhc2UgZXhwb3J0cy5aX09LOlxuICAgIGNhc2UgZXhwb3J0cy5aX0JVRl9FUlJPUjpcbiAgICAgIGlmICh0aGlzLnN0cm0uYXZhaWxfb3V0ICE9PSAwICYmIHRoaXMuZmx1c2ggPT09IGV4cG9ydHMuWl9GSU5JU0gpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGZpbGUnKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBleHBvcnRzLlpfU1RSRUFNX0VORDpcbiAgICAgIC8vIG5vcm1hbCBzdGF0dXNlcywgbm90IGZhdGFsXG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuWl9ORUVEX0RJQ1Q6XG4gICAgICBpZiAodGhpcy5kaWN0aW9uYXJ5ID09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ01pc3NpbmcgZGljdGlvbmFyeScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXJyb3IoJ0JhZCBkaWN0aW9uYXJ5Jyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIHNvbWV0aGluZyBlbHNlLlxuICAgICAgdGhpcy5fZXJyb3IoJ1psaWIgZXJyb3InKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2FmdGVyID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuX2NoZWNrRXJyb3IoKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBhdmFpbF9vdXQgPSB0aGlzLnN0cm0uYXZhaWxfb3V0O1xuICB2YXIgYXZhaWxfaW4gPSB0aGlzLnN0cm0uYXZhaWxfaW47XG5cbiAgdGhpcy53cml0ZV9pbl9wcm9ncmVzcyA9IGZhbHNlO1xuXG4gIC8vIGNhbGwgdGhlIHdyaXRlKCkgY2JcbiAgdGhpcy5jYWxsYmFjayhhdmFpbF9pbiwgYXZhaWxfb3V0KTtcblxuICBpZiAodGhpcy5wZW5kaW5nX2Nsb3NlKSB7XG4gICAgdGhpcy5jbG9zZSgpO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5fZXJyb3IgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICBpZiAodGhpcy5zdHJtLm1zZykge1xuICAgIG1lc3NhZ2UgPSB0aGlzLnN0cm0ubXNnO1xuICB9XG4gIHRoaXMub25lcnJvcihtZXNzYWdlLCB0aGlzLmVyclxuXG4gIC8vIG5vIGhvcGUgb2YgcmVzY3VlLlxuICApO3RoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgaWYgKHRoaXMucGVuZGluZ19jbG9zZSkge1xuICAgIHRoaXMuY2xvc2UoKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICh3aW5kb3dCaXRzLCBsZXZlbCwgbWVtTGV2ZWwsIHN0cmF0ZWd5LCBkaWN0aW9uYXJ5KSB7XG4gIGFzc2VydChhcmd1bWVudHMubGVuZ3RoID09PSA0IHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDUsICdpbml0KHdpbmRvd0JpdHMsIGxldmVsLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIFtkaWN0aW9uYXJ5XSknKTtcblxuICBhc3NlcnQod2luZG93Qml0cyA+PSA4ICYmIHdpbmRvd0JpdHMgPD0gMTUsICdpbnZhbGlkIHdpbmRvd0JpdHMnKTtcbiAgYXNzZXJ0KGxldmVsID49IC0xICYmIGxldmVsIDw9IDksICdpbnZhbGlkIGNvbXByZXNzaW9uIGxldmVsJyk7XG5cbiAgYXNzZXJ0KG1lbUxldmVsID49IDEgJiYgbWVtTGV2ZWwgPD0gOSwgJ2ludmFsaWQgbWVtbGV2ZWwnKTtcblxuICBhc3NlcnQoc3RyYXRlZ3kgPT09IGV4cG9ydHMuWl9GSUxURVJFRCB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0hVRkZNQU5fT05MWSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX1JMRSB8fCBzdHJhdGVneSA9PT0gZXhwb3J0cy5aX0ZJWEVEIHx8IHN0cmF0ZWd5ID09PSBleHBvcnRzLlpfREVGQVVMVF9TVFJBVEVHWSwgJ2ludmFsaWQgc3RyYXRlZ3knKTtcblxuICB0aGlzLl9pbml0KGxldmVsLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3ksIGRpY3Rpb25hcnkpO1xuICB0aGlzLl9zZXREaWN0aW9uYXJ5KCk7XG59O1xuXG5abGliLnByb3RvdHlwZS5wYXJhbXMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignZGVmbGF0ZVBhcmFtcyBOb3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5abGliLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fcmVzZXQoKTtcbiAgdGhpcy5fc2V0RGljdGlvbmFyeSgpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiAobGV2ZWwsIHdpbmRvd0JpdHMsIG1lbUxldmVsLCBzdHJhdGVneSwgZGljdGlvbmFyeSkge1xuICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gIHRoaXMud2luZG93Qml0cyA9IHdpbmRvd0JpdHM7XG4gIHRoaXMubWVtTGV2ZWwgPSBtZW1MZXZlbDtcbiAgdGhpcy5zdHJhdGVneSA9IHN0cmF0ZWd5O1xuXG4gIHRoaXMuZmx1c2ggPSBleHBvcnRzLlpfTk9fRkxVU0g7XG5cbiAgdGhpcy5lcnIgPSBleHBvcnRzLlpfT0s7XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HWklQIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5HVU5aSVApIHtcbiAgICB0aGlzLndpbmRvd0JpdHMgKz0gMTY7XG4gIH1cblxuICBpZiAodGhpcy5tb2RlID09PSBleHBvcnRzLlVOWklQKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzICs9IDMyO1xuICB9XG5cbiAgaWYgKHRoaXMubW9kZSA9PT0gZXhwb3J0cy5ERUZMQVRFUkFXIHx8IHRoaXMubW9kZSA9PT0gZXhwb3J0cy5JTkZMQVRFUkFXKSB7XG4gICAgdGhpcy53aW5kb3dCaXRzID0gLTEgKiB0aGlzLndpbmRvd0JpdHM7XG4gIH1cblxuICB0aGlzLnN0cm0gPSBuZXcgWnN0cmVhbSgpO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkdaSVA6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlSW5pdDIodGhpcy5zdHJtLCB0aGlzLmxldmVsLCBleHBvcnRzLlpfREVGTEFURUQsIHRoaXMud2luZG93Qml0cywgdGhpcy5tZW1MZXZlbCwgdGhpcy5zdHJhdGVneSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgIGNhc2UgZXhwb3J0cy5JTkZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5VTlpJUDpcbiAgICAgIHRoaXMuZXJyID0gemxpYl9pbmZsYXRlLmluZmxhdGVJbml0Mih0aGlzLnN0cm0sIHRoaXMud2luZG93Qml0cyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIG1vZGUgJyArIHRoaXMubW9kZSk7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdJbml0IGVycm9yJyk7XG4gIH1cblxuICB0aGlzLmRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5O1xuXG4gIHRoaXMud3JpdGVfaW5fcHJvZ3Jlc3MgPSBmYWxzZTtcbiAgdGhpcy5pbml0X2RvbmUgPSB0cnVlO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3NldERpY3Rpb25hcnkgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmRpY3Rpb25hcnkgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXMuZXJyID0gZXhwb3J0cy5aX09LO1xuXG4gIHN3aXRjaCAodGhpcy5tb2RlKSB7XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEU6XG4gICAgY2FzZSBleHBvcnRzLkRFRkxBVEVSQVc6XG4gICAgICB0aGlzLmVyciA9IHpsaWJfZGVmbGF0ZS5kZWZsYXRlU2V0RGljdGlvbmFyeSh0aGlzLnN0cm0sIHRoaXMuZGljdGlvbmFyeSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gc2V0IGRpY3Rpb25hcnknKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUuX3Jlc2V0ID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVyciA9IGV4cG9ydHMuWl9PSztcblxuICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFOlxuICAgIGNhc2UgZXhwb3J0cy5ERUZMQVRFUkFXOlxuICAgIGNhc2UgZXhwb3J0cy5HWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2RlZmxhdGUuZGVmbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURTpcbiAgICBjYXNlIGV4cG9ydHMuSU5GTEFURVJBVzpcbiAgICBjYXNlIGV4cG9ydHMuR1VOWklQOlxuICAgICAgdGhpcy5lcnIgPSB6bGliX2luZmxhdGUuaW5mbGF0ZVJlc2V0KHRoaXMuc3RybSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBpZiAodGhpcy5lcnIgIT09IGV4cG9ydHMuWl9PSykge1xuICAgIHRoaXMuX2Vycm9yKCdGYWlsZWQgdG8gcmVzZXQgc3RyZWFtJyk7XG4gIH1cbn07XG5cbmV4cG9ydHMuWmxpYiA9IFpsaWI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJ3N0cmVhbScpLlRyYW5zZm9ybTtcbnZhciBiaW5kaW5nID0gcmVxdWlyZSgnLi9iaW5kaW5nJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKS5vaztcbnZhciBrTWF4TGVuZ3RoID0gcmVxdWlyZSgnYnVmZmVyJykua01heExlbmd0aDtcbnZhciBrUmFuZ2VFcnJvck1lc3NhZ2UgPSAnQ2Fubm90IGNyZWF0ZSBmaW5hbCBCdWZmZXIuIEl0IHdvdWxkIGJlIGxhcmdlciAnICsgJ3RoYW4gMHgnICsga01heExlbmd0aC50b1N0cmluZygxNikgKyAnIGJ5dGVzJztcblxuLy8gemxpYiBkb2Vzbid0IHByb3ZpZGUgdGhlc2UsIHNvIGtsdWRnZSB0aGVtIGluIGZvbGxvd2luZyB0aGUgc2FtZVxuLy8gY29uc3QgbmFtaW5nIHNjaGVtZSB6bGliIHVzZXMuXG5iaW5kaW5nLlpfTUlOX1dJTkRPV0JJVFMgPSA4O1xuYmluZGluZy5aX01BWF9XSU5ET1dCSVRTID0gMTU7XG5iaW5kaW5nLlpfREVGQVVMVF9XSU5ET1dCSVRTID0gMTU7XG5cbi8vIGZld2VyIHRoYW4gNjQgYnl0ZXMgcGVyIGNodW5rIGlzIHN0dXBpZC5cbi8vIHRlY2huaWNhbGx5IGl0IGNvdWxkIHdvcmsgd2l0aCBhcyBmZXcgYXMgOCwgYnV0IGV2ZW4gNjQgYnl0ZXNcbi8vIGlzIGFic3VyZGx5IGxvdy4gIFVzdWFsbHkgYSBNQiBvciBtb3JlIGlzIGJlc3QuXG5iaW5kaW5nLlpfTUlOX0NIVU5LID0gNjQ7XG5iaW5kaW5nLlpfTUFYX0NIVU5LID0gSW5maW5pdHk7XG5iaW5kaW5nLlpfREVGQVVMVF9DSFVOSyA9IDE2ICogMTAyNDtcblxuYmluZGluZy5aX01JTl9NRU1MRVZFTCA9IDE7XG5iaW5kaW5nLlpfTUFYX01FTUxFVkVMID0gOTtcbmJpbmRpbmcuWl9ERUZBVUxUX01FTUxFVkVMID0gODtcblxuYmluZGluZy5aX01JTl9MRVZFTCA9IC0xO1xuYmluZGluZy5aX01BWF9MRVZFTCA9IDk7XG5iaW5kaW5nLlpfREVGQVVMVF9MRVZFTCA9IGJpbmRpbmcuWl9ERUZBVUxUX0NPTVBSRVNTSU9OO1xuXG4vLyBleHBvc2UgYWxsIHRoZSB6bGliIGNvbnN0YW50c1xudmFyIGJrZXlzID0gT2JqZWN0LmtleXMoYmluZGluZyk7XG5mb3IgKHZhciBiayA9IDA7IGJrIDwgYmtleXMubGVuZ3RoOyBiaysrKSB7XG4gIHZhciBia2V5ID0gYmtleXNbYmtdO1xuICBpZiAoYmtleS5tYXRjaCgvXlovKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBia2V5LCB7XG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogYmluZGluZ1tia2V5XSwgd3JpdGFibGU6IGZhbHNlXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gdHJhbnNsYXRpb24gdGFibGUgZm9yIHJldHVybiBjb2Rlcy5cbnZhciBjb2RlcyA9IHtcbiAgWl9PSzogYmluZGluZy5aX09LLFxuICBaX1NUUkVBTV9FTkQ6IGJpbmRpbmcuWl9TVFJFQU1fRU5ELFxuICBaX05FRURfRElDVDogYmluZGluZy5aX05FRURfRElDVCxcbiAgWl9FUlJOTzogYmluZGluZy5aX0VSUk5PLFxuICBaX1NUUkVBTV9FUlJPUjogYmluZGluZy5aX1NUUkVBTV9FUlJPUixcbiAgWl9EQVRBX0VSUk9SOiBiaW5kaW5nLlpfREFUQV9FUlJPUixcbiAgWl9NRU1fRVJST1I6IGJpbmRpbmcuWl9NRU1fRVJST1IsXG4gIFpfQlVGX0VSUk9SOiBiaW5kaW5nLlpfQlVGX0VSUk9SLFxuICBaX1ZFUlNJT05fRVJST1I6IGJpbmRpbmcuWl9WRVJTSU9OX0VSUk9SXG59O1xuXG52YXIgY2tleXMgPSBPYmplY3Qua2V5cyhjb2Rlcyk7XG5mb3IgKHZhciBjayA9IDA7IGNrIDwgY2tleXMubGVuZ3RoOyBjaysrKSB7XG4gIHZhciBja2V5ID0gY2tleXNbY2tdO1xuICBjb2Rlc1tjb2Rlc1tja2V5XV0gPSBja2V5O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2NvZGVzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogT2JqZWN0LmZyZWV6ZShjb2RlcyksIHdyaXRhYmxlOiBmYWxzZVxufSk7XG5cbmV4cG9ydHMuRGVmbGF0ZSA9IERlZmxhdGU7XG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlO1xuZXhwb3J0cy5HemlwID0gR3ppcDtcbmV4cG9ydHMuR3VuemlwID0gR3VuemlwO1xuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhdztcbmV4cG9ydHMuSW5mbGF0ZVJhdyA9IEluZmxhdGVSYXc7XG5leHBvcnRzLlVuemlwID0gVW56aXA7XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZSA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZShvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlRGVmbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgRGVmbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlSW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgSW5mbGF0ZVJhdyhvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3ppcCA9IGZ1bmN0aW9uIChvKSB7XG4gIHJldHVybiBuZXcgR3ppcChvKTtcbn07XG5cbmV4cG9ydHMuY3JlYXRlR3VuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBHdW56aXAobyk7XG59O1xuXG5leHBvcnRzLmNyZWF0ZVVuemlwID0gZnVuY3Rpb24gKG8pIHtcbiAgcmV0dXJuIG5ldyBVbnppcChvKTtcbn07XG5cbi8vIENvbnZlbmllbmNlIG1ldGhvZHMuXG4vLyBjb21wcmVzcy9kZWNvbXByZXNzIGEgc3RyaW5nIG9yIGJ1ZmZlciBpbiBvbmUgc3RlcC5cbmV4cG9ydHMuZGVmbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IERlZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5kZWZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBEZWZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5nemlwID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2FsbGJhY2sgPSBvcHRzO1xuICAgIG9wdHMgPSB7fTtcbiAgfVxuICByZXR1cm4gemxpYkJ1ZmZlcihuZXcgR3ppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLmd6aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd6aXAob3B0cyksIGJ1ZmZlcik7XG59O1xuXG5leHBvcnRzLmRlZmxhdGVSYXcgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBEZWZsYXRlUmF3KG9wdHMpLCBidWZmZXIsIGNhbGxiYWNrKTtcbn07XG5cbmV4cG9ydHMuZGVmbGF0ZVJhd1N5bmMgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzKSB7XG4gIHJldHVybiB6bGliQnVmZmVyU3luYyhuZXcgRGVmbGF0ZVJhdyhvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMudW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyLCBjYWxsYmFjayk7XG59O1xuXG5leHBvcnRzLnVuemlwU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBVbnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGUob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlU3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlKG9wdHMpLCBidWZmZXIpO1xufTtcblxuZXhwb3J0cy5ndW56aXAgPSBmdW5jdGlvbiAoYnVmZmVyLCBvcHRzLCBjYWxsYmFjaykge1xuICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYWxsYmFjayA9IG9wdHM7XG4gICAgb3B0cyA9IHt9O1xuICB9XG4gIHJldHVybiB6bGliQnVmZmVyKG5ldyBHdW56aXAob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5ndW56aXBTeW5jID0gZnVuY3Rpb24gKGJ1ZmZlciwgb3B0cykge1xuICByZXR1cm4gemxpYkJ1ZmZlclN5bmMobmV3IEd1bnppcChvcHRzKSwgYnVmZmVyKTtcbn07XG5cbmV4cG9ydHMuaW5mbGF0ZVJhdyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNhbGxiYWNrID0gb3B0cztcbiAgICBvcHRzID0ge307XG4gIH1cbiAgcmV0dXJuIHpsaWJCdWZmZXIobmV3IEluZmxhdGVSYXcob3B0cyksIGJ1ZmZlciwgY2FsbGJhY2spO1xufTtcblxuZXhwb3J0cy5pbmZsYXRlUmF3U3luYyA9IGZ1bmN0aW9uIChidWZmZXIsIG9wdHMpIHtcbiAgcmV0dXJuIHpsaWJCdWZmZXJTeW5jKG5ldyBJbmZsYXRlUmF3KG9wdHMpLCBidWZmZXIpO1xufTtcblxuZnVuY3Rpb24gemxpYkJ1ZmZlcihlbmdpbmUsIGJ1ZmZlciwgY2FsbGJhY2spIHtcbiAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgdmFyIG5yZWFkID0gMDtcblxuICBlbmdpbmUub24oJ2Vycm9yJywgb25FcnJvcik7XG4gIGVuZ2luZS5vbignZW5kJywgb25FbmQpO1xuXG4gIGVuZ2luZS5lbmQoYnVmZmVyKTtcbiAgZmxvdygpO1xuXG4gIGZ1bmN0aW9uIGZsb3coKSB7XG4gICAgdmFyIGNodW5rO1xuICAgIHdoaWxlIChudWxsICE9PSAoY2h1bmsgPSBlbmdpbmUucmVhZCgpKSkge1xuICAgICAgYnVmZmVycy5wdXNoKGNodW5rKTtcbiAgICAgIG5yZWFkICs9IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gICAgZW5naW5lLm9uY2UoJ3JlYWRhYmxlJywgZmxvdyk7XG4gIH1cblxuICBmdW5jdGlvbiBvbkVycm9yKGVycikge1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25FbmQpO1xuICAgIGVuZ2luZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBmbG93KTtcbiAgICBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgZnVuY3Rpb24gb25FbmQoKSB7XG4gICAgdmFyIGJ1ZjtcbiAgICB2YXIgZXJyID0gbnVsbDtcblxuICAgIGlmIChucmVhZCA+PSBrTWF4TGVuZ3RoKSB7XG4gICAgICBlcnIgPSBuZXcgUmFuZ2VFcnJvcihrUmFuZ2VFcnJvck1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWYgPSBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMsIG5yZWFkKTtcbiAgICB9XG5cbiAgICBidWZmZXJzID0gW107XG4gICAgZW5naW5lLmNsb3NlKCk7XG4gICAgY2FsbGJhY2soZXJyLCBidWYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHpsaWJCdWZmZXJTeW5jKGVuZ2luZSwgYnVmZmVyKSB7XG4gIGlmICh0eXBlb2YgYnVmZmVyID09PSAnc3RyaW5nJykgYnVmZmVyID0gQnVmZmVyLmZyb20oYnVmZmVyKTtcblxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWZmZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdOb3QgYSBzdHJpbmcgb3IgYnVmZmVyJyk7XG5cbiAgdmFyIGZsdXNoRmxhZyA9IGVuZ2luZS5fZmluaXNoRmx1c2hGbGFnO1xuXG4gIHJldHVybiBlbmdpbmUuX3Byb2Nlc3NDaHVuayhidWZmZXIsIGZsdXNoRmxhZyk7XG59XG5cbi8vIGdlbmVyaWMgemxpYlxuLy8gbWluaW1hbCAyLWJ5dGUgaGVhZGVyXG5mdW5jdGlvbiBEZWZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIERlZmxhdGUpKSByZXR1cm4gbmV3IERlZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkRFRkxBVEUpO1xufVxuXG5mdW5jdGlvbiBJbmZsYXRlKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEluZmxhdGUpKSByZXR1cm4gbmV3IEluZmxhdGUob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLklORkxBVEUpO1xufVxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5mdW5jdGlvbiBHemlwKG9wdHMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEd6aXApKSByZXR1cm4gbmV3IEd6aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdaSVApO1xufVxuXG5mdW5jdGlvbiBHdW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgR3VuemlwKSkgcmV0dXJuIG5ldyBHdW56aXAob3B0cyk7XG4gIFpsaWIuY2FsbCh0aGlzLCBvcHRzLCBiaW5kaW5nLkdVTlpJUCk7XG59XG5cbi8vIHJhdyAtIG5vIGhlYWRlclxuZnVuY3Rpb24gRGVmbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEZWZsYXRlUmF3KSkgcmV0dXJuIG5ldyBEZWZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5ERUZMQVRFUkFXKTtcbn1cblxuZnVuY3Rpb24gSW5mbGF0ZVJhdyhvcHRzKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBJbmZsYXRlUmF3KSkgcmV0dXJuIG5ldyBJbmZsYXRlUmF3KG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5JTkZMQVRFUkFXKTtcbn1cblxuLy8gYXV0by1kZXRlY3QgaGVhZGVyLlxuZnVuY3Rpb24gVW56aXAob3B0cykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVW56aXApKSByZXR1cm4gbmV3IFVuemlwKG9wdHMpO1xuICBabGliLmNhbGwodGhpcywgb3B0cywgYmluZGluZy5VTlpJUCk7XG59XG5cbmZ1bmN0aW9uIGlzVmFsaWRGbHVzaEZsYWcoZmxhZykge1xuICByZXR1cm4gZmxhZyA9PT0gYmluZGluZy5aX05PX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9QQVJUSUFMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9TWU5DX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GVUxMX0ZMVVNIIHx8IGZsYWcgPT09IGJpbmRpbmcuWl9GSU5JU0ggfHwgZmxhZyA9PT0gYmluZGluZy5aX0JMT0NLO1xufVxuXG4vLyB0aGUgWmxpYiBjbGFzcyB0aGV5IGFsbCBpbmhlcml0IGZyb21cbi8vIFRoaXMgdGhpbmcgbWFuYWdlcyB0aGUgcXVldWUgb2YgcmVxdWVzdHMsIGFuZCByZXR1cm5zXG4vLyB0cnVlIG9yIGZhbHNlIGlmIHRoZXJlIGlzIGFueXRoaW5nIGluIHRoZSBxdWV1ZSB3aGVuXG4vLyB5b3UgY2FsbCB0aGUgLndyaXRlKCkgbWV0aG9kLlxuXG5mdW5jdGlvbiBabGliKG9wdHMsIG1vZGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLl9vcHRzID0gb3B0cyA9IG9wdHMgfHwge307XG4gIHRoaXMuX2NodW5rU2l6ZSA9IG9wdHMuY2h1bmtTaXplIHx8IGV4cG9ydHMuWl9ERUZBVUxUX0NIVU5LO1xuXG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdHMpO1xuXG4gIGlmIChvcHRzLmZsdXNoICYmICFpc1ZhbGlkRmx1c2hGbGFnKG9wdHMuZmx1c2gpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGZsdXNoIGZsYWc6ICcgKyBvcHRzLmZsdXNoKTtcbiAgfVxuICBpZiAob3B0cy5maW5pc2hGbHVzaCAmJiAhaXNWYWxpZEZsdXNoRmxhZyhvcHRzLmZpbmlzaEZsdXNoKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBmbHVzaCBmbGFnOiAnICsgb3B0cy5maW5pc2hGbHVzaCk7XG4gIH1cblxuICB0aGlzLl9mbHVzaEZsYWcgPSBvcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgdGhpcy5fZmluaXNoRmx1c2hGbGFnID0gdHlwZW9mIG9wdHMuZmluaXNoRmx1c2ggIT09ICd1bmRlZmluZWQnID8gb3B0cy5maW5pc2hGbHVzaCA6IGJpbmRpbmcuWl9GSU5JU0g7XG5cbiAgaWYgKG9wdHMuY2h1bmtTaXplKSB7XG4gICAgaWYgKG9wdHMuY2h1bmtTaXplIDwgZXhwb3J0cy5aX01JTl9DSFVOSyB8fCBvcHRzLmNodW5rU2l6ZSA+IGV4cG9ydHMuWl9NQVhfQ0hVTkspIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjaHVuayBzaXplOiAnICsgb3B0cy5jaHVua1NpemUpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLndpbmRvd0JpdHMpIHtcbiAgICBpZiAob3B0cy53aW5kb3dCaXRzIDwgZXhwb3J0cy5aX01JTl9XSU5ET1dCSVRTIHx8IG9wdHMud2luZG93Qml0cyA+IGV4cG9ydHMuWl9NQVhfV0lORE9XQklUUykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHdpbmRvd0JpdHM6ICcgKyBvcHRzLndpbmRvd0JpdHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChvcHRzLmxldmVsKSB7XG4gICAgaWYgKG9wdHMubGV2ZWwgPCBleHBvcnRzLlpfTUlOX0xFVkVMIHx8IG9wdHMubGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBvcHRzLmxldmVsKTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5tZW1MZXZlbCkge1xuICAgIGlmIChvcHRzLm1lbUxldmVsIDwgZXhwb3J0cy5aX01JTl9NRU1MRVZFTCB8fCBvcHRzLm1lbUxldmVsID4gZXhwb3J0cy5aX01BWF9NRU1MRVZFTCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIG1lbUxldmVsOiAnICsgb3B0cy5tZW1MZXZlbCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG9wdHMuc3RyYXRlZ3kpIHtcbiAgICBpZiAob3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfRklMVEVSRUQgJiYgb3B0cy5zdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIG9wdHMuc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX1JMRSAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSVhFRCAmJiBvcHRzLnN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyYXRlZ3k6ICcgKyBvcHRzLnN0cmF0ZWd5KTtcbiAgICB9XG4gIH1cblxuICBpZiAob3B0cy5kaWN0aW9uYXJ5KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIob3B0cy5kaWN0aW9uYXJ5KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGRpY3Rpb25hcnk6IGl0IHNob3VsZCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuX2hhbmRsZSA9IG5ldyBiaW5kaW5nLlpsaWIobW9kZSk7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB0aGlzLl9oYWRFcnJvciA9IGZhbHNlO1xuICB0aGlzLl9oYW5kbGUub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlLCBlcnJubykge1xuICAgIC8vIHRoZXJlIGlzIG5vIHdheSB0byBjbGVhbmx5IHJlY292ZXIuXG4gICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgIF9jbG9zZShzZWxmKTtcbiAgICBzZWxmLl9oYWRFcnJvciA9IHRydWU7XG5cbiAgICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgZXJyb3IuZXJybm8gPSBlcnJubztcbiAgICBlcnJvci5jb2RlID0gZXhwb3J0cy5jb2Rlc1tlcnJub107XG4gICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgfTtcblxuICB2YXIgbGV2ZWwgPSBleHBvcnRzLlpfREVGQVVMVF9DT01QUkVTU0lPTjtcbiAgaWYgKHR5cGVvZiBvcHRzLmxldmVsID09PSAnbnVtYmVyJykgbGV2ZWwgPSBvcHRzLmxldmVsO1xuXG4gIHZhciBzdHJhdGVneSA9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZO1xuICBpZiAodHlwZW9mIG9wdHMuc3RyYXRlZ3kgPT09ICdudW1iZXInKSBzdHJhdGVneSA9IG9wdHMuc3RyYXRlZ3k7XG5cbiAgdGhpcy5faGFuZGxlLmluaXQob3B0cy53aW5kb3dCaXRzIHx8IGV4cG9ydHMuWl9ERUZBVUxUX1dJTkRPV0JJVFMsIGxldmVsLCBvcHRzLm1lbUxldmVsIHx8IGV4cG9ydHMuWl9ERUZBVUxUX01FTUxFVkVMLCBzdHJhdGVneSwgb3B0cy5kaWN0aW9uYXJ5KTtcblxuICB0aGlzLl9idWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUodGhpcy5fY2h1bmtTaXplKTtcbiAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgdGhpcy5fbGV2ZWwgPSBsZXZlbDtcbiAgdGhpcy5fc3RyYXRlZ3kgPSBzdHJhdGVneTtcblxuICB0aGlzLm9uY2UoJ2VuZCcsIHRoaXMuY2xvc2UpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnX2Nsb3NlZCcsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiAhX3RoaXMuX2hhbmRsZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG51dGlsLmluaGVyaXRzKFpsaWIsIFRyYW5zZm9ybSk7XG5cblpsaWIucHJvdG90eXBlLnBhcmFtcyA9IGZ1bmN0aW9uIChsZXZlbCwgc3RyYXRlZ3ksIGNhbGxiYWNrKSB7XG4gIGlmIChsZXZlbCA8IGV4cG9ydHMuWl9NSU5fTEVWRUwgfHwgbGV2ZWwgPiBleHBvcnRzLlpfTUFYX0xFVkVMKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgY29tcHJlc3Npb24gbGV2ZWw6ICcgKyBsZXZlbCk7XG4gIH1cbiAgaWYgKHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9GSUxURVJFRCAmJiBzdHJhdGVneSAhPSBleHBvcnRzLlpfSFVGRk1BTl9PTkxZICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9STEUgJiYgc3RyYXRlZ3kgIT0gZXhwb3J0cy5aX0ZJWEVEICYmIHN0cmF0ZWd5ICE9IGV4cG9ydHMuWl9ERUZBVUxUX1NUUkFURUdZKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSW52YWxpZCBzdHJhdGVneTogJyArIHN0cmF0ZWd5KTtcbiAgfVxuXG4gIGlmICh0aGlzLl9sZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5fc3RyYXRlZ3kgIT09IHN0cmF0ZWd5KSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuZmx1c2goYmluZGluZy5aX1NZTkNfRkxVU0gsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGFzc2VydChzZWxmLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgICBzZWxmLl9oYW5kbGUucGFyYW1zKGxldmVsLCBzdHJhdGVneSk7XG4gICAgICBpZiAoIXNlbGYuX2hhZEVycm9yKSB7XG4gICAgICAgIHNlbGYuX2xldmVsID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX3N0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gICAgICAgIGlmIChjYWxsYmFjaykgY2FsbGJhY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrKTtcbiAgfVxufTtcblxuWmxpYi5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gIHJldHVybiB0aGlzLl9oYW5kbGUucmVzZXQoKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIF9mbHVzaCBmdW5jdGlvbiBjYWxsZWQgYnkgdGhlIHRyYW5zZm9ybSBjbGFzcyxcbi8vIGludGVybmFsbHksIHdoZW4gdGhlIGxhc3QgY2h1bmsgaGFzIGJlZW4gd3JpdHRlbi5cblpsaWIucHJvdG90eXBlLl9mbHVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLl90cmFuc2Zvcm0oQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xufTtcblxuWmxpYi5wcm90b3R5cGUuZmx1c2ggPSBmdW5jdGlvbiAoa2luZCwgY2FsbGJhY2spIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgdmFyIHdzID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGtpbmQgPT09ICdmdW5jdGlvbicgfHwga2luZCA9PT0gdW5kZWZpbmVkICYmICFjYWxsYmFjaykge1xuICAgIGNhbGxiYWNrID0ga2luZDtcbiAgICBraW5kID0gYmluZGluZy5aX0ZVTExfRkxVU0g7XG4gIH1cblxuICBpZiAod3MuZW5kZWQpIHtcbiAgICBpZiAoY2FsbGJhY2spIHByb2Nlc3MubmV4dFRpY2soY2FsbGJhY2spO1xuICB9IGVsc2UgaWYgKHdzLmVuZGluZykge1xuICAgIGlmIChjYWxsYmFjaykgdGhpcy5vbmNlKCdlbmQnLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAod3MubmVlZERyYWluKSB7XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uY2UoJ2RyYWluJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gX3RoaXMyLmZsdXNoKGtpbmQsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9mbHVzaEZsYWcgPSBraW5kO1xuICAgIHRoaXMud3JpdGUoQnVmZmVyLmFsbG9jKDApLCAnJywgY2FsbGJhY2spO1xuICB9XG59O1xuXG5abGliLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICBfY2xvc2UodGhpcywgY2FsbGJhY2spO1xuICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCB0aGlzKTtcbn07XG5cbmZ1bmN0aW9uIF9jbG9zZShlbmdpbmUsIGNhbGxiYWNrKSB7XG4gIGlmIChjYWxsYmFjaykgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG5cbiAgLy8gQ2FsbGVyIG1heSBpbnZva2UgLmNsb3NlIGFmdGVyIGEgemxpYiBlcnJvciAod2hpY2ggd2lsbCBudWxsIF9oYW5kbGUpLlxuICBpZiAoIWVuZ2luZS5faGFuZGxlKSByZXR1cm47XG5cbiAgZW5naW5lLl9oYW5kbGUuY2xvc2UoKTtcbiAgZW5naW5lLl9oYW5kbGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuWmxpYi5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBmbHVzaEZsYWc7XG4gIHZhciB3cyA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBlbmRpbmcgPSB3cy5lbmRpbmcgfHwgd3MuZW5kZWQ7XG4gIHZhciBsYXN0ID0gZW5kaW5nICYmICghY2h1bmsgfHwgd3MubGVuZ3RoID09PSBjaHVuay5sZW5ndGgpO1xuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkgcmV0dXJuIGNiKG5ldyBFcnJvcignaW52YWxpZCBpbnB1dCcpKTtcblxuICBpZiAoIXRoaXMuX2hhbmRsZSkgcmV0dXJuIGNiKG5ldyBFcnJvcignemxpYiBiaW5kaW5nIGNsb3NlZCcpKTtcblxuICAvLyBJZiBpdCdzIHRoZSBsYXN0IGNodW5rLCBvciBhIGZpbmFsIGZsdXNoLCB3ZSB1c2UgdGhlIFpfRklOSVNIIGZsdXNoIGZsYWdcbiAgLy8gKG9yIHdoYXRldmVyIGZsYWcgd2FzIHByb3ZpZGVkIHVzaW5nIG9wdHMuZmluaXNoRmx1c2gpLlxuICAvLyBJZiBpdCdzIGV4cGxpY2l0bHkgZmx1c2hpbmcgYXQgc29tZSBvdGhlciB0aW1lLCB0aGVuIHdlIHVzZVxuICAvLyBaX0ZVTExfRkxVU0guIE90aGVyd2lzZSwgdXNlIFpfTk9fRkxVU0ggZm9yIG1heGltdW0gY29tcHJlc3Npb25cbiAgLy8gZ29vZG5lc3MuXG4gIGlmIChsYXN0KSBmbHVzaEZsYWcgPSB0aGlzLl9maW5pc2hGbHVzaEZsYWc7ZWxzZSB7XG4gICAgZmx1c2hGbGFnID0gdGhpcy5fZmx1c2hGbGFnO1xuICAgIC8vIG9uY2Ugd2UndmUgZmx1c2hlZCB0aGUgbGFzdCBvZiB0aGUgcXVldWUsIHN0b3AgZmx1c2hpbmcgYW5kXG4gICAgLy8gZ28gYmFjayB0byB0aGUgbm9ybWFsIGJlaGF2aW9yLlxuICAgIGlmIChjaHVuay5sZW5ndGggPj0gd3MubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9mbHVzaEZsYWcgPSB0aGlzLl9vcHRzLmZsdXNoIHx8IGJpbmRpbmcuWl9OT19GTFVTSDtcbiAgICB9XG4gIH1cblxuICB0aGlzLl9wcm9jZXNzQ2h1bmsoY2h1bmssIGZsdXNoRmxhZywgY2IpO1xufTtcblxuWmxpYi5wcm90b3R5cGUuX3Byb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaywgZmx1c2hGbGFnLCBjYikge1xuICB2YXIgYXZhaWxJbkJlZm9yZSA9IGNodW5rICYmIGNodW5rLmxlbmd0aDtcbiAgdmFyIGF2YWlsT3V0QmVmb3JlID0gdGhpcy5fY2h1bmtTaXplIC0gdGhpcy5fb2Zmc2V0O1xuICB2YXIgaW5PZmYgPSAwO1xuXG4gIHZhciBzZWxmID0gdGhpcztcblxuICB2YXIgYXN5bmMgPSB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKCFhc3luYykge1xuICAgIHZhciBidWZmZXJzID0gW107XG4gICAgdmFyIG5yZWFkID0gMDtcblxuICAgIHZhciBlcnJvcjtcbiAgICB0aGlzLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcikge1xuICAgICAgZXJyb3IgPSBlcjtcbiAgICB9KTtcblxuICAgIGFzc2VydCh0aGlzLl9oYW5kbGUsICd6bGliIGJpbmRpbmcgY2xvc2VkJyk7XG4gICAgZG8ge1xuICAgICAgdmFyIHJlcyA9IHRoaXMuX2hhbmRsZS53cml0ZVN5bmMoZmx1c2hGbGFnLCBjaHVuaywgLy8gaW5cbiAgICAgIGluT2ZmLCAvLyBpbl9vZmZcbiAgICAgIGF2YWlsSW5CZWZvcmUsIC8vIGluX2xlblxuICAgICAgdGhpcy5fYnVmZmVyLCAvLyBvdXRcbiAgICAgIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gICAgICBhdmFpbE91dEJlZm9yZSk7IC8vIG91dF9sZW5cbiAgICB9IHdoaWxlICghdGhpcy5faGFkRXJyb3IgJiYgY2FsbGJhY2socmVzWzBdLCByZXNbMV0pKTtcblxuICAgIGlmICh0aGlzLl9oYWRFcnJvcikge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgaWYgKG5yZWFkID49IGtNYXhMZW5ndGgpIHtcbiAgICAgIF9jbG9zZSh0aGlzKTtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGtSYW5nZUVycm9yTWVzc2FnZSk7XG4gICAgfVxuXG4gICAgdmFyIGJ1ZiA9IEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpO1xuICAgIF9jbG9zZSh0aGlzKTtcblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICBhc3NlcnQodGhpcy5faGFuZGxlLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpO1xuICB2YXIgcmVxID0gdGhpcy5faGFuZGxlLndyaXRlKGZsdXNoRmxhZywgY2h1bmssIC8vIGluXG4gIGluT2ZmLCAvLyBpbl9vZmZcbiAgYXZhaWxJbkJlZm9yZSwgLy8gaW5fbGVuXG4gIHRoaXMuX2J1ZmZlciwgLy8gb3V0XG4gIHRoaXMuX29mZnNldCwgLy9vdXRfb2ZmXG4gIGF2YWlsT3V0QmVmb3JlKTsgLy8gb3V0X2xlblxuXG4gIHJlcS5idWZmZXIgPSBjaHVuaztcbiAgcmVxLmNhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgZnVuY3Rpb24gY2FsbGJhY2soYXZhaWxJbkFmdGVyLCBhdmFpbE91dEFmdGVyKSB7XG4gICAgLy8gV2hlbiB0aGUgY2FsbGJhY2sgaXMgdXNlZCBpbiBhbiBhc3luYyB3cml0ZSwgdGhlIGNhbGxiYWNrJ3NcbiAgICAvLyBjb250ZXh0IGlzIHRoZSBgcmVxYCBvYmplY3QgdGhhdCB3YXMgY3JlYXRlZC4gVGhlIHJlcSBvYmplY3RcbiAgICAvLyBpcyA9PT0gdGhpcy5faGFuZGxlLCBhbmQgdGhhdCdzIHdoeSBpdCdzIGltcG9ydGFudCB0byBudWxsXG4gICAgLy8gb3V0IHRoZSB2YWx1ZXMgYWZ0ZXIgdGhleSBhcmUgZG9uZSBiZWluZyB1c2VkLiBgdGhpcy5faGFuZGxlYFxuICAgIC8vIGNhbiBzdGF5IGluIG1lbW9yeSBsb25nZXIgdGhhbiB0aGUgY2FsbGJhY2sgYW5kIGJ1ZmZlciBhcmUgbmVlZGVkLlxuICAgIGlmICh0aGlzKSB7XG4gICAgICB0aGlzLmJ1ZmZlciA9IG51bGw7XG4gICAgICB0aGlzLmNhbGxiYWNrID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoc2VsZi5faGFkRXJyb3IpIHJldHVybjtcblxuICAgIHZhciBoYXZlID0gYXZhaWxPdXRCZWZvcmUgLSBhdmFpbE91dEFmdGVyO1xuICAgIGFzc2VydChoYXZlID49IDAsICdoYXZlIHNob3VsZCBub3QgZ28gZG93bicpO1xuXG4gICAgaWYgKGhhdmUgPiAwKSB7XG4gICAgICB2YXIgb3V0ID0gc2VsZi5fYnVmZmVyLnNsaWNlKHNlbGYuX29mZnNldCwgc2VsZi5fb2Zmc2V0ICsgaGF2ZSk7XG4gICAgICBzZWxmLl9vZmZzZXQgKz0gaGF2ZTtcbiAgICAgIC8vIHNlcnZlIHNvbWUgb3V0cHV0IHRvIHRoZSBjb25zdW1lci5cbiAgICAgIGlmIChhc3luYykge1xuICAgICAgICBzZWxmLnB1c2gob3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJ1ZmZlcnMucHVzaChvdXQpO1xuICAgICAgICBucmVhZCArPSBvdXQubGVuZ3RoO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV4aGF1c3RlZCB0aGUgb3V0cHV0IGJ1ZmZlciwgb3IgdXNlZCBhbGwgdGhlIGlucHV0IGNyZWF0ZSBhIG5ldyBvbmUuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDAgfHwgc2VsZi5fb2Zmc2V0ID49IHNlbGYuX2NodW5rU2l6ZSkge1xuICAgICAgYXZhaWxPdXRCZWZvcmUgPSBzZWxmLl9jaHVua1NpemU7XG4gICAgICBzZWxmLl9vZmZzZXQgPSAwO1xuICAgICAgc2VsZi5fYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgfVxuXG4gICAgaWYgKGF2YWlsT3V0QWZ0ZXIgPT09IDApIHtcbiAgICAgIC8vIE5vdCBhY3R1YWxseSBkb25lLiAgTmVlZCB0byByZXByb2Nlc3MuXG4gICAgICAvLyBBbHNvLCB1cGRhdGUgdGhlIGF2YWlsSW5CZWZvcmUgdG8gdGhlIGF2YWlsSW5BZnRlciB2YWx1ZSxcbiAgICAgIC8vIHNvIHRoYXQgaWYgd2UgaGF2ZSB0byBoaXQgaXQgYSB0aGlyZCAoZm91cnRoLCBldGMuKSB0aW1lLFxuICAgICAgLy8gaXQnbGwgaGF2ZSB0aGUgY29ycmVjdCBieXRlIGNvdW50cy5cbiAgICAgIGluT2ZmICs9IGF2YWlsSW5CZWZvcmUgLSBhdmFpbEluQWZ0ZXI7XG4gICAgICBhdmFpbEluQmVmb3JlID0gYXZhaWxJbkFmdGVyO1xuXG4gICAgICBpZiAoIWFzeW5jKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgdmFyIG5ld1JlcSA9IHNlbGYuX2hhbmRsZS53cml0ZShmbHVzaEZsYWcsIGNodW5rLCBpbk9mZiwgYXZhaWxJbkJlZm9yZSwgc2VsZi5fYnVmZmVyLCBzZWxmLl9vZmZzZXQsIHNlbGYuX2NodW5rU2l6ZSk7XG4gICAgICBuZXdSZXEuY2FsbGJhY2sgPSBjYWxsYmFjazsgLy8gdGhpcyBzYW1lIGZ1bmN0aW9uXG4gICAgICBuZXdSZXEuYnVmZmVyID0gY2h1bms7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFhc3luYykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gZmluaXNoZWQgd2l0aCB0aGUgY2h1bmsuXG4gICAgY2IoKTtcbiAgfVxufTtcblxudXRpbC5pbmhlcml0cyhEZWZsYXRlLCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZSwgWmxpYik7XG51dGlsLmluaGVyaXRzKEd6aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhHdW56aXAsIFpsaWIpO1xudXRpbC5pbmhlcml0cyhEZWZsYXRlUmF3LCBabGliKTtcbnV0aWwuaW5oZXJpdHMoSW5mbGF0ZVJhdywgWmxpYik7XG51dGlsLmluaGVyaXRzKFVuemlwLCBabGliKTsiLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBpc0FycmF5ID0gcmVxdWlyZSgnaXNhcnJheScpXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgVXNlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogRHVlIHRvIHZhcmlvdXMgYnJvd3NlciBidWdzLCBzb21ldGltZXMgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiB3aWxsIGJlIHVzZWQgZXZlblxuICogd2hlbiB0aGUgYnJvd3NlciBzdXBwb3J0cyB0eXBlZCBhcnJheXMuXG4gKlxuICogTm90ZTpcbiAqXG4gKiAgIC0gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWAgaW5zdGFuY2VzLFxuICogICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4LlxuICpcbiAqICAgLSBDaHJvbWUgOS0xMCBpcyBtaXNzaW5nIHRoZSBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uLlxuICpcbiAqICAgLSBJRTEwIGhhcyBhIGJyb2tlbiBgVHlwZWRBcnJheS5wcm90b3R5cGUuc3ViYXJyYXlgIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYXJyYXlzIG9mXG4gKiAgICAgaW5jb3JyZWN0IGxlbmd0aCBpbiBzb21lIHNpdHVhdGlvbnMuXG5cbiAqIFdlIGRldGVjdCB0aGVzZSBidWdneSBicm93c2VycyBhbmQgc2V0IGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGAgdG8gYGZhbHNlYCBzbyB0aGV5XG4gKiBnZXQgdGhlIE9iamVjdCBpbXBsZW1lbnRhdGlvbiwgd2hpY2ggaXMgc2xvd2VyIGJ1dCBiZWhhdmVzIGNvcnJlY3RseS5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSBnbG9iYWwuVFlQRURfQVJSQVlfU1VQUE9SVCAhPT0gdW5kZWZpbmVkXG4gID8gZ2xvYmFsLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgOiB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbi8qXG4gKiBFeHBvcnQga01heExlbmd0aCBhZnRlciB0eXBlZCBhcnJheSBzdXBwb3J0IGlzIGRldGVybWluZWQuXG4gKi9cbmV4cG9ydHMua01heExlbmd0aCA9IGtNYXhMZW5ndGgoKVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDIgJiYgLy8gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWRcbiAgICAgICAgdHlwZW9mIGFyci5zdWJhcnJheSA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBjaHJvbWUgOS0xMCBsYWNrIGBzdWJhcnJheWBcbiAgICAgICAgYXJyLnN1YmFycmF5KDEsIDEpLmJ5dGVMZW5ndGggPT09IDAgLy8gaWUxMCBoYXMgYnJva2VuIGBzdWJhcnJheWBcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGtNYXhMZW5ndGggKCkge1xuICByZXR1cm4gQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRcbiAgICA/IDB4N2ZmZmZmZmZcbiAgICA6IDB4M2ZmZmZmZmZcbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyICh0aGF0LCBsZW5ndGgpIHtcbiAgaWYgKGtNYXhMZW5ndGgoKSA8IGxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgICB0aGF0Ll9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICAvLyBGYWxsYmFjazogUmV0dXJuIGFuIG9iamVjdCBpbnN0YW5jZSBvZiB0aGUgQnVmZmVyIGNsYXNzXG4gICAgaWYgKHRoYXQgPT09IG51bGwpIHtcbiAgICAgIHRoYXQgPSBuZXcgQnVmZmVyKGxlbmd0aClcbiAgICB9XG4gICAgdGhhdC5sZW5ndGggPSBsZW5ndGhcbiAgfVxuXG4gIHJldHVybiB0aGF0XG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmICEodGhpcyBpbnN0YW5jZW9mIEJ1ZmZlcikpIHtcbiAgICByZXR1cm4gbmV3IEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKHRoaXMsIGFyZylcbiAgfVxuICByZXR1cm4gZnJvbSh0aGlzLCBhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbi8vIFRPRE86IExlZ2FjeSwgbm90IG5lZWRlZCBhbnltb3JlLiBSZW1vdmUgaW4gbmV4dCBtYWpvciB2ZXJzaW9uLlxuQnVmZmVyLl9hdWdtZW50ID0gZnVuY3Rpb24gKGFycikge1xuICBhcnIuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIGZyb20gKHRoYXQsIHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgdmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodGhhdCwgdmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICByZXR1cm4gZnJvbU9iamVjdCh0aGF0LCB2YWx1ZSlcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbShudWxsLCB2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5pZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxuICBCdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnNwZWNpZXMgJiZcbiAgICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICAgIC8vIEZpeCBzdWJhcnJheSgpIGluIEVTMjAxNi4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzk3XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlciwgU3ltYm9sLnNwZWNpZXMsIHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHRoYXQsIHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcih0aGF0LCBzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKG51bGwsIHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAodGhhdCwgc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHRoYXQgPSBjcmVhdGVCdWZmZXIodGhhdCwgc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG4gIGlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7ICsraSkge1xuICAgICAgdGhhdFtpXSA9IDBcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoYXRcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShudWxsLCBzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nICh0aGF0LCBzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gdGhhdC53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgdGhhdCA9IHRoYXQuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIHRoYXRcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAodGhhdCwgYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIHRoYXRbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAodGhhdCwgYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBhcnJheS5ieXRlTGVuZ3RoIC8vIHRoaXMgdGhyb3dzIGlmIGBhcnJheWAgaXMgbm90IGEgdmFsaWQgQXJyYXlCdWZmZXJcblxuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYXJyYXkgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2UsIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhhdCA9IGFycmF5XG4gICAgdGhhdC5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIH0gZWxzZSB7XG4gICAgLy8gRmFsbGJhY2s6IFJldHVybiBhbiBvYmplY3QgaW5zdGFuY2Ugb2YgdGhlIEJ1ZmZlciBjbGFzc1xuICAgIHRoYXQgPSBmcm9tQXJyYXlMaWtlKHRoYXQsIGFycmF5KVxuICB9XG4gIHJldHVybiB0aGF0XG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKHRoYXQsIG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB0aGF0ID0gY3JlYXRlQnVmZmVyKHRoYXQsIGxlbilcblxuICAgIGlmICh0aGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoYXRcbiAgICB9XG5cbiAgICBvYmouY29weSh0aGF0LCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIHRoYXRcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgaXNuYW4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcih0aGF0LCAwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2UodGhhdCwgb2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKHRoYXQsIG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwga01heExlbmd0aCgpYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IGtNYXhMZW5ndGgoKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBrTWF4TGVuZ3RoKCkudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiAhIShiICE9IG51bGwgJiYgYi5faXNCdWZmZXIpXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIG11c3QgYmUgQnVmZmVycycpXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFpc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH1cbiAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicgJiZcbiAgICAgIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBzdHJpbmcgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGUgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCBhbmQgYGlzLWJ1ZmZlcmAgKGluIFNhZmFyaSA1LTcpIHRvIGRldGVjdFxuLy8gQnVmZmVyIGluc3RhbmNlcy5cbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGggfCAwXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKGlzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiZcbiAgICAgICAgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChpc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggfCAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgLy8gbGVnYWN5IHdyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldCwgbGVuZ3RoKSAtIHJlbW92ZSBpbiB2MC4xM1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRikgPyAyXG4gICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gdG9IZXgoYnVmW2ldKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIHZhciByZXMgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyBieXRlc1tpICsgMV0gKiAyNTYpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZlxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gICAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xpY2VMZW4gPSBlbmQgLSBzdGFydFxuICAgIG5ld0J1ZiA9IG5ldyBCdWZmZXIoc2xpY2VMZW4sIHVuZGVmaW5lZClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNsaWNlTGVuOyArK2kpIHtcbiAgICAgIG5ld0J1ZltpXSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIHZhciBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCB8IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQxNiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmYgKyB2YWx1ZSArIDFcbiAgZm9yICh2YXIgaSA9IDAsIGogPSBNYXRoLm1pbihidWYubGVuZ3RoIC0gb2Zmc2V0LCAyKTsgaSA8IGo7ICsraSkge1xuICAgIGJ1ZltvZmZzZXQgKyBpXSA9ICh2YWx1ZSAmICgweGZmIDw8ICg4ICogKGxpdHRsZUVuZGlhbiA/IGkgOiAxIC0gaSkpKSkgPj4+XG4gICAgICAobGl0dGxlRW5kaWFuID8gaSA6IDEgLSBpKSAqIDhcbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDE2KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5mdW5jdGlvbiBvYmplY3RXcml0ZVVJbnQzMiAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4pIHtcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIGZvciAodmFyIGkgPSAwLCBqID0gTWF0aC5taW4oYnVmLmxlbmd0aCAtIG9mZnNldCwgNCk7IGkgPCBqOyArK2kpIHtcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSAodmFsdWUgPj4+IChsaXR0bGVFbmRpYW4gPyBpIDogMyAtIGkpICogOCkgJiAweGZmXG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gICAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gICAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQzMih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgfCAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MTYodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIGlmIChCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCkge1xuICAgIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgfSBlbHNlIHtcbiAgICBvYmplY3RXcml0ZVVJbnQxNih0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSlcbiAgfVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0IHwgMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB9IGVsc2Uge1xuICAgIG9iamVjdFdyaXRlVUludDMyKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCB8IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICBpZiAoQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQpIHtcbiAgICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICAgIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICAgIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gICAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIH0gZWxzZSB7XG4gICAgb2JqZWN0V3JpdGVVSW50MzIodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UpXG4gIH1cbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDAgfHwgIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogdXRmOFRvQnl0ZXMobmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKS50b1N0cmluZygpKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXitcXC8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHJpbmd0cmltKHN0cikucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gc3RyaW5ndHJpbSAoc3RyKSB7XG4gIGlmIChzdHIudHJpbSkgcmV0dXJuIHN0ci50cmltKClcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJylcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiBpc25hbiAodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IHZhbCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH07IH0gZWxzZSB7IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTsgfSByZXR1cm4gX3R5cGVvZihvYmopOyB9XG5cbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbJyMwMDAwQ0MnLCAnIzAwMDBGRicsICcjMDAzM0NDJywgJyMwMDMzRkYnLCAnIzAwNjZDQycsICcjMDA2NkZGJywgJyMwMDk5Q0MnLCAnIzAwOTlGRicsICcjMDBDQzAwJywgJyMwMENDMzMnLCAnIzAwQ0M2NicsICcjMDBDQzk5JywgJyMwMENDQ0MnLCAnIzAwQ0NGRicsICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJywgJyMzMzk5RkYnLCAnIzMzQ0MwMCcsICcjMzNDQzMzJywgJyMzM0NDNjYnLCAnIzMzQ0M5OScsICcjMzNDQ0NDJywgJyMzM0NDRkYnLCAnIzY2MDBDQycsICcjNjYwMEZGJywgJyM2NjMzQ0MnLCAnIzY2MzNGRicsICcjNjZDQzAwJywgJyM2NkNDMzMnLCAnIzk5MDBDQycsICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJywgJyNDQzAwNjYnLCAnI0NDMDA5OScsICcjQ0MwMENDJywgJyNDQzAwRkYnLCAnI0NDMzMwMCcsICcjQ0MzMzMzJywgJyNDQzMzNjYnLCAnI0NDMzM5OScsICcjQ0MzM0NDJywgJyNDQzMzRkYnLCAnI0NDNjYwMCcsICcjQ0M2NjMzJywgJyNDQzk5MDAnLCAnI0NDOTkzMycsICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJywgJyNGRjAwRkYnLCAnI0ZGMzMwMCcsICcjRkYzMzMzJywgJyNGRjMzNjYnLCAnI0ZGMzM5OScsICcjRkYzM0NDJywgJyNGRjMzRkYnLCAnI0ZGNjYwMCcsICcjRkY2NjMzJywgJyNGRjk5MDAnLCAnI0ZGOTkzMycsICcjRkZDQzAwJywgJyNGRkNDMzMnXTtcbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5cbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuICAvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuICAvLyBleHBsaWNpdGx5XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXG5cbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG4gIC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cblxuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlIHx8IC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgd2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSB8fCAvLyBJcyBmaXJlZm94ID49IHYzMT9cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG4gIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEgfHwgLy8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuICB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKTtcbn1cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcbiAgYXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgKyB0aGlzLm5hbWVzcGFjZSArICh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArIGFyZ3NbMF0gKyAodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgKyAnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG4gIGlmICghdGhpcy51c2VDb2xvcnMpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpOyAvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuICAvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsYXN0QyA9IDA7XG4gIGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbmRleCsrO1xuXG4gICAgaWYgKG1hdGNoID09PSAnJWMnKSB7XG4gICAgICAvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG4gICAgICBsYXN0QyA9IGluZGV4O1xuICAgIH1cbiAgfSk7XG4gIGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5sb2coKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmxvZ2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuXG5mdW5jdGlvbiBsb2coKSB7XG4gIHZhciBfY29uc29sZTtcblxuICAvLyBUaGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxuICAvLyB0aGUgYGNvbnNvbGUubG9nYCBmdW5jdGlvbiBkb2Vzbid0IGhhdmUgJ2FwcGx5J1xuICByZXR1cm4gKHR5cGVvZiBjb25zb2xlID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YoY29uc29sZSkpID09PSAnb2JqZWN0JyAmJiBjb25zb2xlLmxvZyAmJiAoX2NvbnNvbGUgPSBjb25zb2xlKS5sb2cuYXBwbHkoX2NvbnNvbGUsIGFyZ3VtZW50cyk7XG59XG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuICB0cnkge1xuICAgIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgICBleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikgey8vIFN3YWxsb3dcbiAgICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgfVxufVxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5cbmZ1bmN0aW9uIGxvYWQoKSB7XG4gIHZhciByO1xuXG4gIHRyeSB7XG4gICAgciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuICB9IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvd1xuICAvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cbiAgLy8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXG5cbiAgaWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG5cbiAgcmV0dXJuIHI7XG59XG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuICB0cnkge1xuICAgIC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcbiAgICAvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuICAgIHJldHVybiBsb2NhbFN0b3JhZ2U7XG4gIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3dhbGxvd1xuICAgIC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcbnZhciBmb3JtYXR0ZXJzID0gbW9kdWxlLmV4cG9ydHMuZm9ybWF0dGVycztcbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuICB9XG59O1xuXG4iLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcbiAgY3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1ZztcbiAgY3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuICBjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG4gIGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuICBjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG4gIGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuICBjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG4gIE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgY3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuICB9KTtcbiAgLyoqXG4gICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxuICAqL1xuXG4gIGNyZWF0ZURlYnVnLmluc3RhbmNlcyA9IFtdO1xuICAvKipcbiAgKiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cbiAgKi9cblxuICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICBjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuICAvKipcbiAgKiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG4gICpcbiAgKiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG4gICovXG5cbiAgY3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuICAvKipcbiAgKiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuICAqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG4gIGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuICAgIHZhciBoYXNoID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNoID0gKGhhc2ggPDwgNSkgLSBoYXNoICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG4gICAgICBoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcbiAgfVxuXG4gIGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG4gIC8qKlxuICAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuICAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICAqIEBhcGkgcHVibGljXG4gICovXG5cbiAgZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG4gICAgdmFyIHByZXZUaW1lO1xuXG4gICAgZnVuY3Rpb24gZGVidWcoKSB7XG4gICAgICAvLyBEaXNhYmxlZD9cbiAgICAgIGlmICghZGVidWcuZW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuXG4gICAgICB2YXIgc2VsZiA9IGRlYnVnOyAvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXG4gICAgICB2YXIgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcbiAgICAgIHZhciBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG4gICAgICBzZWxmLmRpZmYgPSBtcztcbiAgICAgIHNlbGYucHJldiA9IHByZXZUaW1lO1xuICAgICAgc2VsZi5jdXJyID0gY3VycjtcbiAgICAgIHByZXZUaW1lID0gY3VycjtcbiAgICAgIGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cbiAgICAgICAgYXJncy51bnNoaWZ0KCclTycpO1xuICAgICAgfSAvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXG5cbiAgICAgIHZhciBpbmRleCA9IDA7XG4gICAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24gKG1hdGNoLCBmb3JtYXQpIHtcbiAgICAgICAgLy8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuICAgICAgICBpZiAobWF0Y2ggPT09ICclJScpIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cblxuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICAgIG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTsgLy8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXG4gICAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgIGluZGV4LS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTsgLy8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblxuICAgICAgY3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuICAgICAgdmFyIGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuICAgICAgbG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgfVxuXG4gICAgZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuICAgIGRlYnVnLmVuYWJsZWQgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG4gICAgZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG4gICAgZGVidWcuY29sb3IgPSBzZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuICAgIGRlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuICAgIGRlYnVnLmV4dGVuZCA9IGV4dGVuZDsgLy8gRGVidWcuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG4gICAgLy8gZGVidWcucmF3TG9nID0gcmF3TG9nO1xuICAgIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cbiAgICBpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuICAgIH1cblxuICAgIGNyZWF0ZURlYnVnLmluc3RhbmNlcy5wdXNoKGRlYnVnKTtcbiAgICByZXR1cm4gZGVidWc7XG4gIH1cblxuICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgIHZhciBpbmRleCA9IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5pbmRleE9mKHRoaXMpO1xuXG4gICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgY3JlYXRlRGVidWcuaW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcbiAgICByZXR1cm4gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcbiAgfVxuICAvKipcbiAgKiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG4gICogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gICogQGFwaSBwdWJsaWNcbiAgKi9cblxuXG4gIGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG4gICAgY3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcbiAgICBjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuICAgIGNyZWF0ZURlYnVnLnNraXBzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcbiAgICB2YXIgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoIXNwbGl0W2ldKSB7XG4gICAgICAgIC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuICAgICAgaWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuICAgICAgICBjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zdWJzdHIoMSkgKyAnJCcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGNyZWF0ZURlYnVnLmluc3RhbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluc3RhbmNlID0gY3JlYXRlRGVidWcuaW5zdGFuY2VzW2ldO1xuICAgICAgaW5zdGFuY2UuZW5hYmxlZCA9IGNyZWF0ZURlYnVnLmVuYWJsZWQoaW5zdGFuY2UubmFtZXNwYWNlKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG4gICpcbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZGlzYWJsZSgpIHtcbiAgICBjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gICogQHJldHVybiB7Qm9vbGVhbn1cbiAgKiBAYXBpIHB1YmxpY1xuICAqL1xuXG5cbiAgZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG4gICAgaWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIENvZXJjZSBgdmFsYC5cbiAgKlxuICAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuICAqIEByZXR1cm4ge01peGVkfVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5cbiAgZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuICAgIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsO1xuICB9XG5cbiAgY3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG4gIHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogRGV0ZWN0IEVsZWN0cm9uIHJlbmRlcmVyIC8gbndqcyBwcm9jZXNzLCB3aGljaCBpcyBub2RlLCBidXQgd2Ugc2hvdWxkXG4gKiB0cmVhdCBhcyBhIGJyb3dzZXIuXG4gKi9cbmlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZSB8fCBwcm9jZXNzLl9fbndqcykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vYnJvd3Nlci5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL25vZGUuanMnKTtcbn1cblxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqL1xudmFyIHR0eSA9IHJlcXVpcmUoJ3R0eScpO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgTm9kZS5qcyBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuXG5leHBvcnRzLmluaXQgPSBpbml0O1xuZXhwb3J0cy5sb2cgPSBsb2c7XG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gWzYsIDIsIDMsIDQsIDUsIDFdO1xuXG50cnkge1xuICAvLyBPcHRpb25hbCBkZXBlbmRlbmN5IChhcyBpbiwgZG9lc24ndCBuZWVkIHRvIGJlIGluc3RhbGxlZCwgTk9UIGxpa2Ugb3B0aW9uYWxEZXBlbmRlbmNpZXMgaW4gcGFja2FnZS5qc29uKVxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLWV4dHJhbmVvdXMtZGVwZW5kZW5jaWVzXG4gIHZhciBzdXBwb3J0c0NvbG9yID0gcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcblxuICBpZiAoc3VwcG9ydHNDb2xvciAmJiAoc3VwcG9ydHNDb2xvci5zdGRlcnIgfHwgc3VwcG9ydHNDb2xvcikubGV2ZWwgPj0gMikge1xuICAgIGV4cG9ydHMuY29sb3JzID0gWzIwLCAyMSwgMjYsIDI3LCAzMiwgMzMsIDM4LCAzOSwgNDAsIDQxLCA0MiwgNDMsIDQ0LCA0NSwgNTYsIDU3LCA2MiwgNjMsIDY4LCA2OSwgNzQsIDc1LCA3NiwgNzcsIDc4LCA3OSwgODAsIDgxLCA5MiwgOTMsIDk4LCA5OSwgMTEyLCAxMTMsIDEyOCwgMTI5LCAxMzQsIDEzNSwgMTQ4LCAxNDksIDE2MCwgMTYxLCAxNjIsIDE2MywgMTY0LCAxNjUsIDE2NiwgMTY3LCAxNjgsIDE2OSwgMTcwLCAxNzEsIDE3MiwgMTczLCAxNzgsIDE3OSwgMTg0LCAxODUsIDE5NiwgMTk3LCAxOTgsIDE5OSwgMjAwLCAyMDEsIDIwMiwgMjAzLCAyMDQsIDIwNSwgMjA2LCAyMDcsIDIwOCwgMjA5LCAyMTQsIDIxNSwgMjIwLCAyMjFdO1xuICB9XG59IGNhdGNoIChlcnJvcikge30gLy8gU3dhbGxvdyAtIHdlIG9ubHkgY2FyZSBpZiBgc3VwcG9ydHMtY29sb3JgIGlzIGF2YWlsYWJsZTsgaXQgZG9lc24ndCBoYXZlIHRvIGJlLlxuXG4vKipcbiAqIEJ1aWxkIHVwIHRoZSBkZWZhdWx0IGBpbnNwZWN0T3B0c2Agb2JqZWN0IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiAgICQgREVCVUdfQ09MT1JTPW5vIERFQlVHX0RFUFRIPTEwIERFQlVHX1NIT1dfSElEREVOPWVuYWJsZWQgbm9kZSBzY3JpcHQuanNcbiAqL1xuXG5cbmV4cG9ydHMuaW5zcGVjdE9wdHMgPSBPYmplY3Qua2V5cyhwcm9jZXNzLmVudikuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIC9eZGVidWdfL2kudGVzdChrZXkpO1xufSkucmVkdWNlKGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAvLyBDYW1lbC1jYXNlXG4gIHZhciBwcm9wID0ga2V5LnN1YnN0cmluZyg2KS50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL18oW2Etel0pL2csIGZ1bmN0aW9uIChfLCBrKSB7XG4gICAgcmV0dXJuIGsudG9VcHBlckNhc2UoKTtcbiAgfSk7IC8vIENvZXJjZSBzdHJpbmcgdmFsdWUgaW50byBKUyB2YWx1ZVxuXG4gIHZhciB2YWwgPSBwcm9jZXNzLmVudltrZXldO1xuXG4gIGlmICgvXih5ZXN8b258dHJ1ZXxlbmFibGVkKSQvaS50ZXN0KHZhbCkpIHtcbiAgICB2YWwgPSB0cnVlO1xuICB9IGVsc2UgaWYgKC9eKG5vfG9mZnxmYWxzZXxkaXNhYmxlZCkkL2kudGVzdCh2YWwpKSB7XG4gICAgdmFsID0gZmFsc2U7XG4gIH0gZWxzZSBpZiAodmFsID09PSAnbnVsbCcpIHtcbiAgICB2YWwgPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHZhbCA9IE51bWJlcih2YWwpO1xuICB9XG5cbiAgb2JqW3Byb3BdID0gdmFsO1xuICByZXR1cm4gb2JqO1xufSwge30pO1xuLyoqXG4gKiBJcyBzdGRvdXQgYSBUVFk/IENvbG9yZWQgb3V0cHV0IGlzIGVuYWJsZWQgd2hlbiBgdHJ1ZWAuXG4gKi9cblxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuICByZXR1cm4gJ2NvbG9ycycgaW4gZXhwb3J0cy5pbnNwZWN0T3B0cyA/IEJvb2xlYW4oZXhwb3J0cy5pbnNwZWN0T3B0cy5jb2xvcnMpIDogdHR5LmlzYXR0eShwcm9jZXNzLnN0ZGVyci5mZCk7XG59XG4vKipcbiAqIEFkZHMgQU5TSSBjb2xvciBlc2NhcGUgY29kZXMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG4gIHZhciBuYW1lID0gdGhpcy5uYW1lc3BhY2UsXG4gICAgICB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcblxuICBpZiAodXNlQ29sb3JzKSB7XG4gICAgdmFyIGMgPSB0aGlzLmNvbG9yO1xuICAgIHZhciBjb2xvckNvZGUgPSBcIlxceDFCWzNcIiArIChjIDwgOCA/IGMgOiAnODs1OycgKyBjKTtcbiAgICB2YXIgcHJlZml4ID0gXCIgIFwiLmNvbmNhdChjb2xvckNvZGUsIFwiOzFtXCIpLmNvbmNhdChuYW1lLCBcIiBcXHgxQlswbVwiKTtcbiAgICBhcmdzWzBdID0gcHJlZml4ICsgYXJnc1swXS5zcGxpdCgnXFxuJykuam9pbignXFxuJyArIHByZWZpeCk7XG4gICAgYXJncy5wdXNoKGNvbG9yQ29kZSArICdtKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpICsgXCJcXHgxQlswbVwiKTtcbiAgfSBlbHNlIHtcbiAgICBhcmdzWzBdID0gZ2V0RGF0ZSgpICsgbmFtZSArICcgJyArIGFyZ3NbMF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGF0ZSgpIHtcbiAgaWYgKGV4cG9ydHMuaW5zcGVjdE9wdHMuaGlkZURhdGUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICByZXR1cm4gbmV3IERhdGUoKS50b0lTT1N0cmluZygpICsgJyAnO1xufVxuLyoqXG4gKiBJbnZva2VzIGB1dGlsLmZvcm1hdCgpYCB3aXRoIHRoZSBzcGVjaWZpZWQgYXJndW1lbnRzIGFuZCB3cml0ZXMgdG8gc3RkZXJyLlxuICovXG5cblxuZnVuY3Rpb24gbG9nKCkge1xuICByZXR1cm4gcHJvY2Vzcy5zdGRlcnIud3JpdGUodXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgYXJndW1lbnRzKSArICdcXG4nKTtcbn1cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG4gIGlmIChuYW1lc3BhY2VzKSB7XG4gICAgcHJvY2Vzcy5lbnYuREVCVUcgPSBuYW1lc3BhY2VzO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIHlvdSBzZXQgYSBwcm9jZXNzLmVudiBmaWVsZCB0byBudWxsIG9yIHVuZGVmaW5lZCwgaXQgZ2V0cyBjYXN0IHRvIHRoZVxuICAgIC8vIHN0cmluZyAnbnVsbCcgb3IgJ3VuZGVmaW5lZCcuIEp1c3QgZGVsZXRlIGluc3RlYWQuXG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkRFQlVHO1xuICB9XG59XG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblxuZnVuY3Rpb24gbG9hZCgpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52LkRFQlVHO1xufVxuLyoqXG4gKiBJbml0IGxvZ2ljIGZvciBgZGVidWdgIGluc3RhbmNlcy5cbiAqXG4gKiBDcmVhdGUgYSBuZXcgYGluc3BlY3RPcHRzYCBvYmplY3QgaW4gY2FzZSBgdXNlQ29sb3JzYCBpcyBzZXRcbiAqIGRpZmZlcmVudGx5IGZvciBhIHBhcnRpY3VsYXIgYGRlYnVnYCBpbnN0YW5jZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGluaXQoZGVidWcpIHtcbiAgZGVidWcuaW5zcGVjdE9wdHMgPSB7fTtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhleHBvcnRzLmluc3BlY3RPcHRzKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBkZWJ1Zy5pbnNwZWN0T3B0c1trZXlzW2ldXSA9IGV4cG9ydHMuaW5zcGVjdE9wdHNba2V5c1tpXV07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xudmFyIGZvcm1hdHRlcnMgPSBtb2R1bGUuZXhwb3J0cy5mb3JtYXR0ZXJzO1xuLyoqXG4gKiBNYXAgJW8gdG8gYHV0aWwuaW5zcGVjdCgpYCwgYWxsIG9uIGEgc2luZ2xlIGxpbmUuXG4gKi9cblxuZm9ybWF0dGVycy5vID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5pbnNwZWN0T3B0cy5jb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcbiAgcmV0dXJuIHV0aWwuaW5zcGVjdCh2LCB0aGlzLmluc3BlY3RPcHRzKS5yZXBsYWNlKC9cXHMqXFxuXFxzKi9nLCAnICcpO1xufTtcbi8qKlxuICogTWFwICVPIHRvIGB1dGlsLmluc3BlY3QoKWAsIGFsbG93aW5nIG11bHRpcGxlIGxpbmVzIGlmIG5lZWRlZC5cbiAqL1xuXG5cbmZvcm1hdHRlcnMuTyA9IGZ1bmN0aW9uICh2KSB7XG4gIHRoaXMuaW5zcGVjdE9wdHMuY29sb3JzID0gdGhpcy51c2VDb2xvcnM7XG4gIHJldHVybiB1dGlsLmluc3BlY3QodiwgdGhpcy5pbnNwZWN0T3B0cyk7XG59O1xuXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUiA9IHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyA/IFJlZmxlY3QgOiBudWxsXG52YXIgUmVmbGVjdEFwcGx5ID0gUiAmJiB0eXBlb2YgUi5hcHBseSA9PT0gJ2Z1bmN0aW9uJ1xuICA/IFIuYXBwbHlcbiAgOiBmdW5jdGlvbiBSZWZsZWN0QXBwbHkodGFyZ2V0LCByZWNlaXZlciwgYXJncykge1xuICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbCh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKTtcbiAgfVxuXG52YXIgUmVmbGVjdE93bktleXNcbmlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVmbGVjdE93bktleXMgPSBSLm93bktleXNcbn0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHModGFyZ2V0KSk7XG4gIH07XG59IGVsc2Uge1xuICBSZWZsZWN0T3duS2V5cyA9IGZ1bmN0aW9uIFJlZmxlY3RPd25LZXlzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBQcm9jZXNzRW1pdFdhcm5pbmcod2FybmluZykge1xuICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbn1cblxudmFyIE51bWJlcklzTmFOID0gTnVtYmVyLmlzTmFOIHx8IGZ1bmN0aW9uIE51bWJlcklzTmFOKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICBpZiAoIXRoaXMuZmlyZWQpIHtcbiAgICB0aGlzLnRhcmdldC5yZW1vdmVMaXN0ZW5lcih0aGlzLnR5cGUsIHRoaXMud3JhcEZuKTtcbiAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICBSZWZsZWN0QXBwbHkodGhpcy5saXN0ZW5lciwgdGhpcy50YXJnZXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgfVxuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cbiIsInZhciB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xudmFyIGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbnZhciBodHRwcyA9IHJlcXVpcmUoXCJodHRwc1wiKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKFwiYXNzZXJ0XCIpO1xudmFyIFdyaXRhYmxlID0gcmVxdWlyZShcInN0cmVhbVwiKS5Xcml0YWJsZTtcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoXCJkZWJ1Z1wiKShcImZvbGxvdy1yZWRpcmVjdHNcIik7XG5cbi8vIFJGQzcyMzHCpzQuMi4xOiBPZiB0aGUgcmVxdWVzdCBtZXRob2RzIGRlZmluZWQgYnkgdGhpcyBzcGVjaWZpY2F0aW9uLFxuLy8gdGhlIEdFVCwgSEVBRCwgT1BUSU9OUywgYW5kIFRSQUNFIG1ldGhvZHMgYXJlIGRlZmluZWQgdG8gYmUgc2FmZS5cbnZhciBTQUZFX01FVEhPRFMgPSB7IEdFVDogdHJ1ZSwgSEVBRDogdHJ1ZSwgT1BUSU9OUzogdHJ1ZSwgVFJBQ0U6IHRydWUgfTtcblxuLy8gQ3JlYXRlIGhhbmRsZXJzIHRoYXQgcGFzcyBldmVudHMgZnJvbSBuYXRpdmUgcmVxdWVzdHNcbnZhciBldmVudEhhbmRsZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbltcImFib3J0XCIsIFwiYWJvcnRlZFwiLCBcImVycm9yXCIsIFwic29ja2V0XCIsIFwidGltZW91dFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICBldmVudEhhbmRsZXJzW2V2ZW50XSA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICB0aGlzLl9yZWRpcmVjdGFibGUuZW1pdChldmVudCwgYXJnKTtcbiAgfTtcbn0pO1xuXG4vLyBBbiBIVFRQKFMpIHJlcXVlc3QgdGhhdCBjYW4gYmUgcmVkaXJlY3RlZFxuZnVuY3Rpb24gUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCByZXNwb25zZUNhbGxiYWNrKSB7XG4gIC8vIEluaXRpYWxpemUgdGhlIHJlcXVlc3RcbiAgV3JpdGFibGUuY2FsbCh0aGlzKTtcbiAgb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy5fcmVkaXJlY3RDb3VudCA9IDA7XG4gIHRoaXMuX3JlZGlyZWN0cyA9IFtdO1xuICB0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCA9IDA7XG4gIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuXG4gIC8vIFNpbmNlIGh0dHAucmVxdWVzdCB0cmVhdHMgaG9zdCBhcyBhbiBhbGlhcyBvZiBob3N0bmFtZSxcbiAgLy8gYnV0IHRoZSB1cmwgbW9kdWxlIGludGVycHJldHMgaG9zdCBhcyBob3N0bmFtZSBwbHVzIHBvcnQsXG4gIC8vIGVsaW1pbmF0ZSB0aGUgaG9zdCBwcm9wZXJ0eSB0byBhdm9pZCBjb25mdXNpb24uXG4gIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAvLyBVc2UgaG9zdG5hbWUgaWYgc2V0LCBiZWNhdXNlIGl0IGhhcyBwcmVjZWRlbmNlXG4gICAgaWYgKCFvcHRpb25zLmhvc3RuYW1lKSB7XG4gICAgICBvcHRpb25zLmhvc3RuYW1lID0gb3B0aW9ucy5ob3N0O1xuICAgIH1cbiAgICBkZWxldGUgb3B0aW9ucy5ob3N0O1xuICB9XG5cbiAgLy8gQXR0YWNoIGEgY2FsbGJhY2sgaWYgcGFzc2VkXG4gIGlmIChyZXNwb25zZUNhbGxiYWNrKSB7XG4gICAgdGhpcy5vbihcInJlc3BvbnNlXCIsIHJlc3BvbnNlQ2FsbGJhY2spO1xuICB9XG5cbiAgLy8gUmVhY3QgdG8gcmVzcG9uc2VzIG9mIG5hdGl2ZSByZXF1ZXN0c1xuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICBzZWxmLl9wcm9jZXNzUmVzcG9uc2UocmVzcG9uc2UpO1xuICB9O1xuXG4gIC8vIENvbXBsZXRlIHRoZSBVUkwgb2JqZWN0IHdoZW4gbmVjZXNzYXJ5XG4gIGlmICghb3B0aW9ucy5wYXRobmFtZSAmJiBvcHRpb25zLnBhdGgpIHtcbiAgICB2YXIgc2VhcmNoUG9zID0gb3B0aW9ucy5wYXRoLmluZGV4T2YoXCI/XCIpO1xuICAgIGlmIChzZWFyY2hQb3MgPCAwKSB7XG4gICAgICBvcHRpb25zLnBhdGhuYW1lID0gb3B0aW9ucy5wYXRoO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIG9wdGlvbnMucGF0aG5hbWUgPSBvcHRpb25zLnBhdGguc3Vic3RyaW5nKDAsIHNlYXJjaFBvcyk7XG4gICAgICBvcHRpb25zLnNlYXJjaCA9IG9wdGlvbnMucGF0aC5zdWJzdHJpbmcoc2VhcmNoUG9zKTtcbiAgICB9XG4gIH1cblxuICAvLyBQZXJmb3JtIHRoZSBmaXJzdCByZXF1ZXN0XG4gIHRoaXMuX3BlcmZvcm1SZXF1ZXN0KCk7XG59XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoV3JpdGFibGUucHJvdG90eXBlKTtcblxuLy8gV3JpdGVzIGJ1ZmZlcmVkIGRhdGEgdG8gdGhlIGN1cnJlbnQgbmF0aXZlIHJlcXVlc3RcblJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBWYWxpZGF0ZSBpbnB1dCBhbmQgc2hpZnQgcGFyYW1ldGVycyBpZiBuZWNlc3NhcnlcbiAgaWYgKCEodHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgKFwibGVuZ3RoXCIgaW4gZGF0YSkpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZGF0YSBzaG91bGQgYmUgYSBzdHJpbmcsIEJ1ZmZlciBvciBVaW50OEFycmF5XCIpO1xuICB9XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgLy8gSWdub3JlIGVtcHR5IGJ1ZmZlcnMsIHNpbmNlIHdyaXRpbmcgdGhlbSBkb2Vzbid0IGludm9rZSB0aGUgY2FsbGJhY2tcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMjA2NlxuICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyBPbmx5IHdyaXRlIHdoZW4gd2UgZG9uJ3QgZXhjZWVkIHRoZSBtYXhpbXVtIGJvZHkgbGVuZ3RoXG4gIGlmICh0aGlzLl9yZXF1ZXN0Qm9keUxlbmd0aCArIGRhdGEubGVuZ3RoIDw9IHRoaXMuX29wdGlvbnMubWF4Qm9keUxlbmd0aCkge1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5TGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycy5wdXNoKHsgZGF0YTogZGF0YSwgZW5jb2Rpbmc6IGVuY29kaW5nIH0pO1xuICAgIHRoaXMuX2N1cnJlbnRSZXF1ZXN0LndyaXRlKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gIH1cbiAgLy8gRXJyb3Igd2hlbiB3ZSBleGNlZWQgdGhlIG1heGltdW0gYm9keSBsZW5ndGhcbiAgZWxzZSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKFwiUmVxdWVzdCBib2R5IGxhcmdlciB0aGFuIG1heEJvZHlMZW5ndGggbGltaXRcIikpO1xuICAgIHRoaXMuYWJvcnQoKTtcbiAgfVxufTtcblxuLy8gRW5kcyB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAvLyBTaGlmdCBwYXJhbWV0ZXJzIGlmIG5lY2Vzc2FyeVxuICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICBkYXRhID0gZW5jb2RpbmcgPSBudWxsO1xuICB9XG4gIGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY2FsbGJhY2sgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICAvLyBXcml0ZSBkYXRhIGFuZCBlbmRcbiAgdmFyIGN1cnJlbnRSZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3Q7XG4gIHRoaXMud3JpdGUoZGF0YSB8fCBcIlwiLCBlbmNvZGluZywgZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRSZXF1ZXN0LmVuZChudWxsLCBudWxsLCBjYWxsYmFjayk7XG4gIH0pO1xufTtcblxuLy8gU2V0cyBhIGhlYWRlciB2YWx1ZSBvbiB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHRoaXMuX29wdGlvbnMuaGVhZGVyc1tuYW1lXSA9IHZhbHVlO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5zZXRIZWFkZXIobmFtZSwgdmFsdWUpO1xufTtcblxuLy8gQ2xlYXJzIGEgaGVhZGVyIHZhbHVlIG9uIHRoZSBjdXJyZW50IG5hdGl2ZSByZXF1ZXN0XG5SZWRpcmVjdGFibGVSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuICBkZWxldGUgdGhpcy5fb3B0aW9ucy5oZWFkZXJzW25hbWVdO1xuICB0aGlzLl9jdXJyZW50UmVxdWVzdC5yZW1vdmVIZWFkZXIobmFtZSk7XG59O1xuXG4vLyBQcm94eSBhbGwgb3RoZXIgcHVibGljIENsaWVudFJlcXVlc3QgbWV0aG9kc1xuW1xuICBcImFib3J0XCIsIFwiZmx1c2hIZWFkZXJzXCIsIFwiZ2V0SGVhZGVyXCIsXG4gIFwic2V0Tm9EZWxheVwiLCBcInNldFNvY2tldEtlZXBBbGl2ZVwiLCBcInNldFRpbWVvdXRcIixcbl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gIFJlZGlyZWN0YWJsZVJlcXVlc3QucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFttZXRob2RdKGEsIGIpO1xuICB9O1xufSk7XG5cbi8vIFByb3h5IGFsbCBwdWJsaWMgQ2xpZW50UmVxdWVzdCBwcm9wZXJ0aWVzXG5bXCJhYm9ydGVkXCIsIFwiY29ubmVjdGlvblwiLCBcInNvY2tldFwiXS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wZXJ0eSkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUsIHByb3BlcnR5LCB7XG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9jdXJyZW50UmVxdWVzdFtwcm9wZXJ0eV07IH0sXG4gIH0pO1xufSk7XG5cbi8vIEV4ZWN1dGVzIHRoZSBuZXh0IG5hdGl2ZSByZXF1ZXN0IChpbml0aWFsIG9yIHJlZGlyZWN0KVxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3BlcmZvcm1SZXF1ZXN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBMb2FkIHRoZSBuYXRpdmUgcHJvdG9jb2xcbiAgdmFyIHByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5wcm90b2NvbDtcbiAgdmFyIG5hdGl2ZVByb3RvY29sID0gdGhpcy5fb3B0aW9ucy5uYXRpdmVQcm90b2NvbHNbcHJvdG9jb2xdO1xuICBpZiAoIW5hdGl2ZVByb3RvY29sKSB7XG4gICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgbmV3IEVycm9yKFwiVW5zdXBwb3J0ZWQgcHJvdG9jb2wgXCIgKyBwcm90b2NvbCkpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIHNwZWNpZmllZCwgdXNlIHRoZSBhZ2VudCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyAoSFRUUCBhbmQgSFRUUFMgdXNlIGRpZmZlcmVudCB0eXBlcyBvZiBhZ2VudHMpXG4gIGlmICh0aGlzLl9vcHRpb25zLmFnZW50cykge1xuICAgIHZhciBzY2hlbWUgPSBwcm90b2NvbC5zdWJzdHIoMCwgcHJvdG9jb2wubGVuZ3RoIC0gMSk7XG4gICAgdGhpcy5fb3B0aW9ucy5hZ2VudCA9IHRoaXMuX29wdGlvbnMuYWdlbnRzW3NjaGVtZV07XG4gIH1cblxuICAvLyBDcmVhdGUgdGhlIG5hdGl2ZSByZXF1ZXN0XG4gIHZhciByZXF1ZXN0ID0gdGhpcy5fY3VycmVudFJlcXVlc3QgPVxuICAgICAgICBuYXRpdmVQcm90b2NvbC5yZXF1ZXN0KHRoaXMuX29wdGlvbnMsIHRoaXMuX29uTmF0aXZlUmVzcG9uc2UpO1xuICB0aGlzLl9jdXJyZW50VXJsID0gdXJsLmZvcm1hdCh0aGlzLl9vcHRpb25zKTtcblxuICAvLyBTZXQgdXAgZXZlbnQgaGFuZGxlcnNcbiAgcmVxdWVzdC5fcmVkaXJlY3RhYmxlID0gdGhpcztcbiAgZm9yICh2YXIgZXZlbnQgaW4gZXZlbnRIYW5kbGVycykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICByZXF1ZXN0Lm9uKGV2ZW50LCBldmVudEhhbmRsZXJzW2V2ZW50XSk7XG4gICAgfVxuICB9XG5cbiAgLy8gRW5kIGEgcmVkaXJlY3RlZCByZXF1ZXN0XG4gIC8vIChUaGUgZmlyc3QgcmVxdWVzdCBtdXN0IGJlIGVuZGVkIGV4cGxpY2l0bHkgd2l0aCBSZWRpcmVjdGFibGVSZXF1ZXN0I2VuZClcbiAgaWYgKHRoaXMuX2lzUmVkaXJlY3QpIHtcbiAgICAvLyBXcml0ZSB0aGUgcmVxdWVzdCBlbnRpdHkgYW5kIGVuZC5cbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGJ1ZmZlcnMgPSB0aGlzLl9yZXF1ZXN0Qm9keUJ1ZmZlcnM7XG4gICAgKGZ1bmN0aW9uIHdyaXRlTmV4dCgpIHtcbiAgICAgIGlmIChpIDwgYnVmZmVycy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IGJ1ZmZlcnNbaSsrXTtcbiAgICAgICAgcmVxdWVzdC53cml0ZShidWZmZXIuZGF0YSwgYnVmZmVyLmVuY29kaW5nLCB3cml0ZU5leHQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICB9XG4gICAgfSgpKTtcbiAgfVxufTtcblxuLy8gUHJvY2Vzc2VzIGEgcmVzcG9uc2UgZnJvbSB0aGUgY3VycmVudCBuYXRpdmUgcmVxdWVzdFxuUmVkaXJlY3RhYmxlUmVxdWVzdC5wcm90b3R5cGUuX3Byb2Nlc3NSZXNwb25zZSA9IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAvLyBTdG9yZSB0aGUgcmVkaXJlY3RlZCByZXNwb25zZVxuICBpZiAodGhpcy5fb3B0aW9ucy50cmFja1JlZGlyZWN0cykge1xuICAgIHRoaXMuX3JlZGlyZWN0cy5wdXNoKHtcbiAgICAgIHVybDogdGhpcy5fY3VycmVudFVybCxcbiAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNDb2RlLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gUkZDNzIzMcKnNi40OiBUaGUgM3h4IChSZWRpcmVjdGlvbikgY2xhc3Mgb2Ygc3RhdHVzIGNvZGUgaW5kaWNhdGVzXG4gIC8vIHRoYXQgZnVydGhlciBhY3Rpb24gbmVlZHMgdG8gYmUgdGFrZW4gYnkgdGhlIHVzZXIgYWdlbnQgaW4gb3JkZXIgdG9cbiAgLy8gZnVsZmlsbCB0aGUgcmVxdWVzdC4gSWYgYSBMb2NhdGlvbiBoZWFkZXIgZmllbGQgaXMgcHJvdmlkZWQsXG4gIC8vIHRoZSB1c2VyIGFnZW50IE1BWSBhdXRvbWF0aWNhbGx5IHJlZGlyZWN0IGl0cyByZXF1ZXN0IHRvIHRoZSBVUklcbiAgLy8gcmVmZXJlbmNlZCBieSB0aGUgTG9jYXRpb24gZmllbGQgdmFsdWUsXG4gIC8vIGV2ZW4gaWYgdGhlIHNwZWNpZmljIHN0YXR1cyBjb2RlIGlzIG5vdCB1bmRlcnN0b29kLlxuICB2YXIgbG9jYXRpb24gPSByZXNwb25zZS5oZWFkZXJzLmxvY2F0aW9uO1xuICBpZiAobG9jYXRpb24gJiYgdGhpcy5fb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMgIT09IGZhbHNlICYmXG4gICAgICByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCAmJiByZXNwb25zZS5zdGF0dXNDb2RlIDwgNDAwKSB7XG4gICAgLy8gUkZDNzIzMcKnNi40OiBBIGNsaWVudCBTSE9VTEQgZGV0ZWN0IGFuZCBpbnRlcnZlbmVcbiAgICAvLyBpbiBjeWNsaWNhbCByZWRpcmVjdGlvbnMgKGkuZS4sIFwiaW5maW5pdGVcIiByZWRpcmVjdGlvbiBsb29wcykuXG4gICAgaWYgKCsrdGhpcy5fcmVkaXJlY3RDb3VudCA+IHRoaXMuX29wdGlvbnMubWF4UmVkaXJlY3RzKSB7XG4gICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBuZXcgRXJyb3IoXCJNYXggcmVkaXJlY3RzIGV4Y2VlZGVkLlwiKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUkZDNzIzMcKnNi40OiBBdXRvbWF0aWMgcmVkaXJlY3Rpb24gbmVlZHMgdG8gZG9uZSB3aXRoXG4gICAgLy8gY2FyZSBmb3IgbWV0aG9kcyBub3Qga25vd24gdG8gYmUgc2FmZSBb4oCmXSxcbiAgICAvLyBzaW5jZSB0aGUgdXNlciBtaWdodCBub3Qgd2lzaCB0byByZWRpcmVjdCBhbiB1bnNhZmUgcmVxdWVzdC5cbiAgICAvLyBSRkM3MjMxwqc2LjQuNzogVGhlIDMwNyAoVGVtcG9yYXJ5IFJlZGlyZWN0KSBzdGF0dXMgY29kZSBpbmRpY2F0ZXNcbiAgICAvLyB0aGF0IHRoZSB0YXJnZXQgcmVzb3VyY2UgcmVzaWRlcyB0ZW1wb3JhcmlseSB1bmRlciBhIGRpZmZlcmVudCBVUklcbiAgICAvLyBhbmQgdGhlIHVzZXIgYWdlbnQgTVVTVCBOT1QgY2hhbmdlIHRoZSByZXF1ZXN0IG1ldGhvZFxuICAgIC8vIGlmIGl0IHBlcmZvcm1zIGFuIGF1dG9tYXRpYyByZWRpcmVjdGlvbiB0byB0aGF0IFVSSS5cbiAgICB2YXIgaGVhZGVyO1xuICAgIHZhciBoZWFkZXJzID0gdGhpcy5fb3B0aW9ucy5oZWFkZXJzO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAzMDcgJiYgISh0aGlzLl9vcHRpb25zLm1ldGhvZCBpbiBTQUZFX01FVEhPRFMpKSB7XG4gICAgICB0aGlzLl9vcHRpb25zLm1ldGhvZCA9IFwiR0VUXCI7XG4gICAgICAvLyBEcm9wIGEgcG9zc2libGUgZW50aXR5IGFuZCBoZWFkZXJzIHJlbGF0ZWQgdG8gaXRcbiAgICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuICAgICAgZm9yIChoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICBpZiAoL15jb250ZW50LS9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcm9wIHRoZSBIb3N0IGhlYWRlciwgYXMgdGhlIHJlZGlyZWN0IG1pZ2h0IGxlYWQgdG8gYSBkaWZmZXJlbnQgaG9zdFxuICAgIGlmICghdGhpcy5faXNSZWRpcmVjdCkge1xuICAgICAgZm9yIChoZWFkZXIgaW4gaGVhZGVycykge1xuICAgICAgICBpZiAoL15ob3N0JC9pLnRlc3QoaGVhZGVyKSkge1xuICAgICAgICAgIGRlbGV0ZSBoZWFkZXJzW2hlYWRlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQZXJmb3JtIHRoZSByZWRpcmVjdGVkIHJlcXVlc3RcbiAgICB2YXIgcmVkaXJlY3RVcmwgPSB1cmwucmVzb2x2ZSh0aGlzLl9jdXJyZW50VXJsLCBsb2NhdGlvbik7XG4gICAgZGVidWcoXCJyZWRpcmVjdGluZyB0b1wiLCByZWRpcmVjdFVybCk7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9vcHRpb25zLCB1cmwucGFyc2UocmVkaXJlY3RVcmwpKTtcbiAgICB0aGlzLl9pc1JlZGlyZWN0ID0gdHJ1ZTtcbiAgICB0aGlzLl9wZXJmb3JtUmVxdWVzdCgpO1xuXG4gICAgLy8gRGlzY2FyZCB0aGUgcmVtYWluZGVyIG9mIHRoZSByZXNwb25zZSB0byBhdm9pZCB3YWl0aW5nIGZvciBkYXRhXG4gICAgcmVzcG9uc2UuZGVzdHJveSgpO1xuICB9XG4gIGVsc2Uge1xuICAgIC8vIFRoZSByZXNwb25zZSBpcyBub3QgYSByZWRpcmVjdDsgcmV0dXJuIGl0IGFzLWlzXG4gICAgcmVzcG9uc2UucmVzcG9uc2VVcmwgPSB0aGlzLl9jdXJyZW50VXJsO1xuICAgIHJlc3BvbnNlLnJlZGlyZWN0cyA9IHRoaXMuX3JlZGlyZWN0cztcbiAgICB0aGlzLmVtaXQoXCJyZXNwb25zZVwiLCByZXNwb25zZSk7XG5cbiAgICAvLyBDbGVhbiB1cFxuICAgIHRoaXMuX3JlcXVlc3RCb2R5QnVmZmVycyA9IFtdO1xuICB9XG59O1xuXG4vLyBXcmFwcyB0aGUga2V5L3ZhbHVlIG9iamVjdCBvZiBwcm90b2NvbHMgd2l0aCByZWRpcmVjdCBmdW5jdGlvbmFsaXR5XG5mdW5jdGlvbiB3cmFwKHByb3RvY29scykge1xuICAvLyBEZWZhdWx0IHNldHRpbmdzXG4gIHZhciBleHBvcnRzID0ge1xuICAgIG1heFJlZGlyZWN0czogMjEsXG4gICAgbWF4Qm9keUxlbmd0aDogMTAgKiAxMDI0ICogMTAyNCxcbiAgfTtcblxuICAvLyBXcmFwIGVhY2ggcHJvdG9jb2xcbiAgdmFyIG5hdGl2ZVByb3RvY29scyA9IHt9O1xuICBPYmplY3Qua2V5cyhwcm90b2NvbHMpLmZvckVhY2goZnVuY3Rpb24gKHNjaGVtZSkge1xuICAgIHZhciBwcm90b2NvbCA9IHNjaGVtZSArIFwiOlwiO1xuICAgIHZhciBuYXRpdmVQcm90b2NvbCA9IG5hdGl2ZVByb3RvY29sc1twcm90b2NvbF0gPSBwcm90b2NvbHNbc2NoZW1lXTtcbiAgICB2YXIgd3JhcHBlZFByb3RvY29sID0gZXhwb3J0c1tzY2hlbWVdID0gT2JqZWN0LmNyZWF0ZShuYXRpdmVQcm90b2NvbCk7XG5cbiAgICAvLyBFeGVjdXRlcyBhIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHNcbiAgICB3cmFwcGVkUHJvdG9jb2wucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG9wdGlvbnMgPSB1cmwucGFyc2Uob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMubWF4UmVkaXJlY3RzID0gZXhwb3J0cy5tYXhSZWRpcmVjdHM7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHByb3RvY29sOiBwcm90b2NvbCxcbiAgICAgICAgICBtYXhSZWRpcmVjdHM6IGV4cG9ydHMubWF4UmVkaXJlY3RzLFxuICAgICAgICAgIG1heEJvZHlMZW5ndGg6IGV4cG9ydHMubWF4Qm9keUxlbmd0aCxcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBvcHRpb25zLm5hdGl2ZVByb3RvY29scyA9IG5hdGl2ZVByb3RvY29scztcbiAgICAgIGFzc2VydC5lcXVhbChvcHRpb25zLnByb3RvY29sLCBwcm90b2NvbCwgXCJwcm90b2NvbCBtaXNtYXRjaFwiKTtcbiAgICAgIGRlYnVnKFwib3B0aW9uc1wiLCBvcHRpb25zKTtcbiAgICAgIHJldHVybiBuZXcgUmVkaXJlY3RhYmxlUmVxdWVzdChvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIC8vIEV4ZWN1dGVzIGEgR0VUIHJlcXVlc3QsIGZvbGxvd2luZyByZWRpcmVjdHNcbiAgICB3cmFwcGVkUHJvdG9jb2wuZ2V0ID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgcmVxdWVzdCA9IHdyYXBwZWRQcm90b2NvbC5yZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgIHJlcXVlc3QuZW5kKCk7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9O1xuICB9KTtcbiAgcmV0dXJuIGV4cG9ydHM7XG59XG5cbi8vIEV4cG9ydHNcbm1vZHVsZS5leHBvcnRzID0gd3JhcCh7IGh0dHA6IGh0dHAsIGh0dHBzOiBodHRwcyB9KTtcbm1vZHVsZS5leHBvcnRzLndyYXAgPSB3cmFwO1xuIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSAoZmxhZywgYXJndikgPT4ge1xuXHRhcmd2ID0gYXJndiB8fCBwcm9jZXNzLmFyZ3Y7XG5cdGNvbnN0IHByZWZpeCA9IGZsYWcuc3RhcnRzV2l0aCgnLScpID8gJycgOiAoZmxhZy5sZW5ndGggPT09IDEgPyAnLScgOiAnLS0nKTtcblx0Y29uc3QgcG9zID0gYXJndi5pbmRleE9mKHByZWZpeCArIGZsYWcpO1xuXHRjb25zdCB0ZXJtaW5hdG9yUG9zID0gYXJndi5pbmRleE9mKCctLScpO1xuXHRyZXR1cm4gcG9zICE9PSAtMSAmJiAodGVybWluYXRvclBvcyA9PT0gLTEgPyB0cnVlIDogcG9zIDwgdGVybWluYXRvclBvcyk7XG59O1xuIiwidmFyIGh0dHAgPSByZXF1aXJlKCdodHRwJylcbnZhciB1cmwgPSByZXF1aXJlKCd1cmwnKVxuXG52YXIgaHR0cHMgPSBtb2R1bGUuZXhwb3J0c1xuXG5mb3IgKHZhciBrZXkgaW4gaHR0cCkge1xuICBpZiAoaHR0cC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBodHRwc1trZXldID0gaHR0cFtrZXldXG59XG5cbmh0dHBzLnJlcXVlc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICBwYXJhbXMgPSB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpXG4gIHJldHVybiBodHRwLnJlcXVlc3QuY2FsbCh0aGlzLCBwYXJhbXMsIGNiKVxufVxuXG5odHRwcy5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYikge1xuICBwYXJhbXMgPSB2YWxpZGF0ZVBhcmFtcyhwYXJhbXMpXG4gIHJldHVybiBodHRwLmdldC5jYWxsKHRoaXMsIHBhcmFtcywgY2IpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUGFyYW1zIChwYXJhbXMpIHtcbiAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcGFyYW1zID0gdXJsLnBhcnNlKHBhcmFtcylcbiAgfVxuICBpZiAoIXBhcmFtcy5wcm90b2NvbCkge1xuICAgIHBhcmFtcy5wcm90b2NvbCA9ICdodHRwczonXG4gIH1cbiAgaWYgKHBhcmFtcy5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb3RvY29sIFwiJyArIHBhcmFtcy5wcm90b2NvbCArICdcIiBub3Qgc3VwcG9ydGVkLiBFeHBlY3RlZCBcImh0dHBzOlwiJylcbiAgfVxuICByZXR1cm4gcGFyYW1zXG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iLCJ0cnkge1xuICB2YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgaWYgKHR5cGVvZiB1dGlsLmluaGVyaXRzICE9PSAnZnVuY3Rpb24nKSB0aHJvdyAnJztcbiAgbW9kdWxlLmV4cG9ydHMgPSB1dGlsLmluaGVyaXRzO1xufSBjYXRjaCAoZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vaW5oZXJpdHNfYnJvd3Nlci5qcycpO1xufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNCdWZmZXIoYXJnKSB7XG4gIHJldHVybiBhcmcgaW5zdGFuY2VvZiBCdWZmZXI7XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyB8fFxuICBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9iaikge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgICB2YXIgZGVzY3JpcHRvcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc2NyaXB0b3JzW2tleXNbaV1dID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleXNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gZGVzY3JpcHRvcnM7XG4gIH07XG5cbnZhciBmb3JtYXRSZWdFeHAgPSAvJVtzZGolXS9nO1xuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XG4gIGlmICghaXNTdHJpbmcoZikpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBvYmplY3RzLnB1c2goaW5zcGVjdChhcmd1bWVudHNbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xuICB9XG5cbiAgdmFyIGkgPSAxO1xuICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgdmFyIGxlbiA9IGFyZ3MubGVuZ3RoO1xuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XG4gICAgaWYgKHggPT09ICclJScpIHJldHVybiAnJSc7XG4gICAgaWYgKGkgPj0gbGVuKSByZXR1cm4geDtcbiAgICBzd2l0Y2ggKHgpIHtcbiAgICAgIGNhc2UgJyVzJzogcmV0dXJuIFN0cmluZyhhcmdzW2krK10pO1xuICAgICAgY2FzZSAnJWQnOiByZXR1cm4gTnVtYmVyKGFyZ3NbaSsrXSk7XG4gICAgICBjYXNlICclaic6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3NbaSsrXSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xuICBmb3IgKHZhciB4ID0gYXJnc1tpXTsgaSA8IGxlbjsgeCA9IGFyZ3NbKytpXSkge1xuICAgIGlmIChpc051bGwoeCkgfHwgIWlzT2JqZWN0KHgpKSB7XG4gICAgICBzdHIgKz0gJyAnICsgeDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyICs9ICcgJyArIGluc3BlY3QoeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdHI7XG59O1xuXG5cbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4vLyBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuLy8gSWYgLS1uby1kZXByZWNhdGlvbiBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIC8vIEFsbG93IGZvciBkZXByZWNhdGluZyB0aGluZ3MgaW4gdGhlIHByb2Nlc3Mgb2Ygc3RhcnRpbmcgdXAuXG4gIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5kZXByZWNhdGUoZm4sIG1zZykuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAocHJvY2Vzcy50aHJvd0RlcHJlY2F0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLnRyYWNlRGVwcmVjYXRpb24pIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn07XG5cblxudmFyIGRlYnVncyA9IHt9O1xudmFyIGRlYnVnRW52aXJvbjtcbmV4cG9ydHMuZGVidWdsb2cgPSBmdW5jdGlvbihzZXQpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXG4gICAgZGVidWdFbnZpcm9uID0gcHJvY2Vzcy5lbnYuTk9ERV9ERUJVRyB8fCAnJztcbiAgc2V0ID0gc2V0LnRvVXBwZXJDYXNlKCk7XG4gIGlmICghZGVidWdzW3NldF0pIHtcbiAgICBpZiAobmV3IFJlZ0V4cCgnXFxcXGInICsgc2V0ICsgJ1xcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcbiAgICAgIHZhciBwaWQgPSBwcm9jZXNzLnBpZDtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xuICAgICAgICBjb25zb2xlLmVycm9yKCclcyAlZDogJXMnLCBzZXQsIHBpZCwgbXNnKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlYnVnc1tzZXRdID0gZnVuY3Rpb24oKSB7fTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRlYnVnc1tzZXRdO1xufTtcblxuXG4vKipcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcbiAqIGluIHRoZSBiZXN0IHdheSBwb3NzaWJsZSBnaXZlbiB0aGUgZGlmZmVyZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0cyBPcHRpb25hbCBvcHRpb25zIG9iamVjdCB0aGF0IGFsdGVycyB0aGUgb3V0cHV0LlxuICovXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXG5mdW5jdGlvbiBpbnNwZWN0KG9iaiwgb3B0cykge1xuICAvLyBkZWZhdWx0IG9wdGlvbnNcbiAgdmFyIGN0eCA9IHtcbiAgICBzZWVuOiBbXSxcbiAgICBzdHlsaXplOiBzdHlsaXplTm9Db2xvclxuICB9O1xuICAvLyBsZWdhY3kuLi5cbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gMykgY3R4LmRlcHRoID0gYXJndW1lbnRzWzJdO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xuICBpZiAoaXNCb29sZWFuKG9wdHMpKSB7XG4gICAgLy8gbGVnYWN5Li4uXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xuICB9IGVsc2UgaWYgKG9wdHMpIHtcbiAgICAvLyBnb3QgYW4gXCJvcHRpb25zXCIgb2JqZWN0XG4gICAgZXhwb3J0cy5fZXh0ZW5kKGN0eCwgb3B0cyk7XG4gIH1cbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LnNob3dIaWRkZW4pKSBjdHguc2hvd0hpZGRlbiA9IGZhbHNlO1xuICBpZiAoaXNVbmRlZmluZWQoY3R4LmRlcHRoKSkgY3R4LmRlcHRoID0gMjtcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XG4gIGlmIChpc1VuZGVmaW5lZChjdHguY3VzdG9tSW5zcGVjdCkpIGN0eC5jdXN0b21JbnNwZWN0ID0gdHJ1ZTtcbiAgaWYgKGN0eC5jb2xvcnMpIGN0eC5zdHlsaXplID0gc3R5bGl6ZVdpdGhDb2xvcjtcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xufVxuZXhwb3J0cy5pbnNwZWN0ID0gaW5zcGVjdDtcblxuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0FOU0lfZXNjYXBlX2NvZGUjZ3JhcGhpY3Ncbmluc3BlY3QuY29sb3JzID0ge1xuICAnYm9sZCcgOiBbMSwgMjJdLFxuICAnaXRhbGljJyA6IFszLCAyM10sXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcbiAgJ2ludmVyc2UnIDogWzcsIDI3XSxcbiAgJ3doaXRlJyA6IFszNywgMzldLFxuICAnZ3JleScgOiBbOTAsIDM5XSxcbiAgJ2JsYWNrJyA6IFszMCwgMzldLFxuICAnYmx1ZScgOiBbMzQsIDM5XSxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXG4gICdncmVlbicgOiBbMzIsIDM5XSxcbiAgJ21hZ2VudGEnIDogWzM1LCAzOV0sXG4gICdyZWQnIDogWzMxLCAzOV0sXG4gICd5ZWxsb3cnIDogWzMzLCAzOV1cbn07XG5cbi8vIERvbid0IHVzZSAnYmx1ZScgbm90IHZpc2libGUgb24gY21kLmV4ZVxuaW5zcGVjdC5zdHlsZXMgPSB7XG4gICdzcGVjaWFsJzogJ2N5YW4nLFxuICAnbnVtYmVyJzogJ3llbGxvdycsXG4gICdib29sZWFuJzogJ3llbGxvdycsXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXG4gICdudWxsJzogJ2JvbGQnLFxuICAnc3RyaW5nJzogJ2dyZWVuJyxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXG4gIC8vIFwibmFtZVwiOiBpbnRlbnRpb25hbGx5IG5vdCBzdHlsaW5nXG4gICdyZWdleHAnOiAncmVkJ1xufTtcblxuXG5mdW5jdGlvbiBzdHlsaXplV2l0aENvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XG4gIHZhciBzdHlsZSA9IGluc3BlY3Quc3R5bGVzW3N0eWxlVHlwZV07XG5cbiAgaWYgKHN0eWxlKSB7XG4gICAgcmV0dXJuICdcXHUwMDFiWycgKyBpbnNwZWN0LmNvbG9yc1tzdHlsZV1bMF0gKyAnbScgKyBzdHIgK1xuICAgICAgICAgICAnXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzFdICsgJ20nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHI7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBzdHlsaXplTm9Db2xvcihzdHIsIHN0eWxlVHlwZSkge1xuICByZXR1cm4gc3RyO1xufVxuXG5cbmZ1bmN0aW9uIGFycmF5VG9IYXNoKGFycmF5KSB7XG4gIHZhciBoYXNoID0ge307XG5cbiAgYXJyYXkuZm9yRWFjaChmdW5jdGlvbih2YWwsIGlkeCkge1xuICAgIGhhc2hbdmFsXSA9IHRydWU7XG4gIH0pO1xuXG4gIHJldHVybiBoYXNoO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xuICAvLyBQcm92aWRlIGEgaG9vayBmb3IgdXNlci1zcGVjaWZpZWQgaW5zcGVjdCBmdW5jdGlvbnMuXG4gIC8vIENoZWNrIHRoYXQgdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggYW4gaW5zcGVjdCBmdW5jdGlvbiBvbiBpdFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcbiAgICAgIHZhbHVlICYmXG4gICAgICBpc0Z1bmN0aW9uKHZhbHVlLmluc3BlY3QpICYmXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcbiAgICAgIHZhbHVlLmluc3BlY3QgIT09IGV4cG9ydHMuaW5zcGVjdCAmJlxuICAgICAgLy8gQWxzbyBmaWx0ZXIgb3V0IGFueSBwcm90b3R5cGUgb2JqZWN0cyB1c2luZyB0aGUgY2lyY3VsYXIgY2hlY2suXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XG4gICAgdmFyIHJldCA9IHZhbHVlLmluc3BlY3QocmVjdXJzZVRpbWVzLCBjdHgpO1xuICAgIGlmICghaXNTdHJpbmcocmV0KSkge1xuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvLyBQcmltaXRpdmUgdHlwZXMgY2Fubm90IGhhdmUgcHJvcGVydGllc1xuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xuICBpZiAocHJpbWl0aXZlKSB7XG4gICAgcmV0dXJuIHByaW1pdGl2ZTtcbiAgfVxuXG4gIC8vIExvb2sgdXAgdGhlIGtleXMgb2YgdGhlIG9iamVjdC5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XG4gIHZhciB2aXNpYmxlS2V5cyA9IGFycmF5VG9IYXNoKGtleXMpO1xuXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xuICAgIGtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh2YWx1ZSk7XG4gIH1cblxuICAvLyBJRSBkb2Vzbid0IG1ha2UgZXJyb3IgZmllbGRzIG5vbi1lbnVtZXJhYmxlXG4gIC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9kd3c1MnNidCh2PXZzLjk0KS5hc3B4XG4gIGlmIChpc0Vycm9yKHZhbHVlKVxuICAgICAgJiYgKGtleXMuaW5kZXhPZignbWVzc2FnZScpID49IDAgfHwga2V5cy5pbmRleE9mKCdkZXNjcmlwdGlvbicpID49IDApKSB7XG4gICAgcmV0dXJuIGZvcm1hdEVycm9yKHZhbHVlKTtcbiAgfVxuXG4gIC8vIFNvbWUgdHlwZSBvZiBvYmplY3Qgd2l0aG91dCBwcm9wZXJ0aWVzIGNhbiBiZSBzaG9ydGN1dHRlZC5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICB2YXIgbmFtZSA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcbiAgICB9XG4gICAgaWYgKGlzRXJyb3IodmFsdWUpKSB7XG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNlID0gJycsIGFycmF5ID0gZmFsc2UsIGJyYWNlcyA9IFsneycsICd9J107XG5cbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxuICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICBhcnJheSA9IHRydWU7XG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcbiAgfVxuXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xuICBpZiAoaXNGdW5jdGlvbih2YWx1ZSkpIHtcbiAgICB2YXIgbiA9IHZhbHVlLm5hbWUgPyAnOiAnICsgdmFsdWUubmFtZSA6ICcnO1xuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xuICB9XG5cbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcbiAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xuICAgIGJhc2UgPSAnICcgKyBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBkYXRlcyB3aXRoIHByb3BlcnRpZXMgZmlyc3Qgc2F5IHRoZSBkYXRlXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XG4gICAgYmFzZSA9ICcgJyArIERhdGUucHJvdG90eXBlLnRvVVRDU3RyaW5nLmNhbGwodmFsdWUpO1xuICB9XG5cbiAgLy8gTWFrZSBlcnJvciB3aXRoIG1lc3NhZ2UgZmlyc3Qgc2F5IHRoZSBlcnJvclxuICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xuICB9XG5cbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XG4gICAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyBicmFjZXNbMV07XG4gIH1cblxuICBpZiAocmVjdXJzZVRpbWVzIDwgMCkge1xuICAgIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZSgnW09iamVjdF0nLCAnc3BlY2lhbCcpO1xuICAgIH1cbiAgfVxuXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xuXG4gIHZhciBvdXRwdXQ7XG4gIGlmIChhcnJheSkge1xuICAgIG91dHB1dCA9IGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpO1xuICB9IGVsc2Uge1xuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xuICAgICAgcmV0dXJuIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpO1xuICAgIH0pO1xuICB9XG5cbiAgY3R4LnNlZW4ucG9wKCk7XG5cbiAgcmV0dXJuIHJlZHVjZVRvU2luZ2xlU3RyaW5nKG91dHB1dCwgYmFzZSwgYnJhY2VzKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRQcmltaXRpdmUoY3R4LCB2YWx1ZSkge1xuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxuICAgIHJldHVybiBjdHguc3R5bGl6ZSgndW5kZWZpbmVkJywgJ3VuZGVmaW5lZCcpO1xuICBpZiAoaXNTdHJpbmcodmFsdWUpKSB7XG4gICAgdmFyIHNpbXBsZSA9ICdcXCcnICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpLnJlcGxhY2UoL15cInxcIiQvZywgJycpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFwiL2csICdcIicpICsgJ1xcJyc7XG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xuICB9XG4gIGlmIChpc051bWJlcih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcbiAgaWYgKGlzQm9vbGVhbih2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdib29sZWFuJyk7XG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcIm9iamVjdFwiLCBzbyBzcGVjaWFsIGNhc2UgaGVyZS5cbiAgaWYgKGlzTnVsbCh2YWx1ZSkpXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcbn1cblxuXG5mdW5jdGlvbiBmb3JtYXRFcnJvcih2YWx1ZSkge1xuICByZXR1cm4gJ1snICsgRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ10nO1xufVxuXG5cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7ICsraSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xuICAgICAgb3V0cHV0LnB1c2goZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cyxcbiAgICAgICAgICBTdHJpbmcoaSksIHRydWUpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2goJycpO1xuICAgIH1cbiAgfVxuICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgaWYgKCFrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICBvdXRwdXQucHVzaChmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cblxuZnVuY3Rpb24gZm9ybWF0UHJvcGVydHkoY3R4LCB2YWx1ZSwgcmVjdXJzZVRpbWVzLCB2aXNpYmxlS2V5cywga2V5LCBhcnJheSkge1xuICB2YXIgbmFtZSwgc3RyLCBkZXNjO1xuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XG4gIGlmIChkZXNjLmdldCkge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciA9IGN0eC5zdHlsaXplKCdbR2V0dGVyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChkZXNjLnNldCkge1xuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xuICAgIG5hbWUgPSAnWycgKyBrZXkgKyAnXSc7XG4gIH1cbiAgaWYgKCFzdHIpIHtcbiAgICBpZiAoY3R4LnNlZW4uaW5kZXhPZihkZXNjLnZhbHVlKSA8IDApIHtcbiAgICAgIGlmIChpc051bGwocmVjdXJzZVRpbWVzKSkge1xuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyID0gZm9ybWF0VmFsdWUoY3R4LCBkZXNjLnZhbHVlLCByZWN1cnNlVGltZXMgLSAxKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdHIuaW5kZXhPZignXFxuJykgPiAtMSkge1xuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBzdHIgPSBzdHIuc3BsaXQoJ1xcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICByZXR1cm4gJyAgJyArIGxpbmU7XG4gICAgICAgICAgfSkuam9pbignXFxuJykuc3Vic3RyKDIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0ciA9ICdcXG4nICsgc3RyLnNwbGl0KCdcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcbiAgICAgICAgICB9KS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHIgPSBjdHguc3R5bGl6ZSgnW0NpcmN1bGFyXScsICdzcGVjaWFsJyk7XG4gICAgfVxuICB9XG4gIGlmIChpc1VuZGVmaW5lZChuYW1lKSkge1xuICAgIGlmIChhcnJheSAmJiBrZXkubWF0Y2goL15cXGQrJC8pKSB7XG4gICAgICByZXR1cm4gc3RyO1xuICAgIH1cbiAgICBuYW1lID0gSlNPTi5zdHJpbmdpZnkoJycgKyBrZXkpO1xuICAgIGlmIChuYW1lLm1hdGNoKC9eXCIoW2EtekEtWl9dW2EtekEtWl8wLTldKilcIiQvKSkge1xuICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyKDEsIG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ25hbWUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvJy9nLCBcIlxcXFwnXCIpXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJylcbiAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLyheXCJ8XCIkKS9nLCBcIidcIik7XG4gICAgICBuYW1lID0gY3R4LnN0eWxpemUobmFtZSwgJ3N0cmluZycpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lICsgJzogJyArIHN0cjtcbn1cblxuXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xuICB2YXIgbnVtTGluZXNFc3QgPSAwO1xuICB2YXIgbGVuZ3RoID0gb3V0cHV0LnJlZHVjZShmdW5jdGlvbihwcmV2LCBjdXIpIHtcbiAgICBudW1MaW5lc0VzdCsrO1xuICAgIGlmIChjdXIuaW5kZXhPZignXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcbiAgICByZXR1cm4gcHJldiArIGN1ci5yZXBsYWNlKC9cXHUwMDFiXFxbXFxkXFxkP20vZywgJycpLmxlbmd0aCArIDE7XG4gIH0sIDApO1xuXG4gIGlmIChsZW5ndGggPiA2MCkge1xuICAgIHJldHVybiBicmFjZXNbMF0gK1xuICAgICAgICAgICAoYmFzZSA9PT0gJycgPyAnJyA6IGJhc2UgKyAnXFxuICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXG4gICcpICtcbiAgICAgICAgICAgJyAnICtcbiAgICAgICAgICAgYnJhY2VzWzFdO1xuICB9XG5cbiAgcmV0dXJuIGJyYWNlc1swXSArIGJhc2UgKyAnICcgKyBvdXRwdXQuam9pbignLCAnKSArICcgJyArIGJyYWNlc1sxXTtcbn1cblxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuZnVuY3Rpb24gaXNBcnJheShhcikge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShhcik7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcbn1cbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG5cbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XG4gIHJldHVybiBpc09iamVjdChkKSAmJiBvYmplY3RUb1N0cmluZyhkKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xufVxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XG5cbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcbiAgICAgIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IHJlcXVpcmUoJy4vc3VwcG9ydC9pc0J1ZmZlcicpO1xuXG5mdW5jdGlvbiBvYmplY3RUb1N0cmluZyhvKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobyk7XG59XG5cblxuZnVuY3Rpb24gcGFkKG4pIHtcbiAgcmV0dXJuIG4gPCAxMCA/ICcwJyArIG4udG9TdHJpbmcoMTApIDogbi50b1N0cmluZygxMCk7XG59XG5cblxudmFyIG1vbnRocyA9IFsnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcblxuLy8gMjYgRmViIDE2OjE5OjM0XG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XG4gIHZhciBkID0gbmV3IERhdGUoKTtcbiAgdmFyIHRpbWUgPSBbcGFkKGQuZ2V0SG91cnMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXG4gICAgICAgICAgICAgIHBhZChkLmdldFNlY29uZHMoKSldLmpvaW4oJzonKTtcbiAgcmV0dXJuIFtkLmdldERhdGUoKSwgbW9udGhzW2QuZ2V0TW9udGgoKV0sIHRpbWVdLmpvaW4oJyAnKTtcbn1cblxuXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXG5leHBvcnRzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICBjb25zb2xlLmxvZygnJXMgLSAlcycsIHRpbWVzdGFtcCgpLCBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpKTtcbn07XG5cblxuLyoqXG4gKiBJbmhlcml0IHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuXG4gKlxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxuICogZnVuY3Rpb24gKG5vdCBvbiBGdW5jdGlvbi5wcm90b3R5cGUpLiBOT1RFOiBJZiB0aGlzIGZpbGUgaXMgdG8gYmUgbG9hZGVkXG4gKiBkdXJpbmcgYm9vdHN0cmFwcGluZyB0aGlzIGZ1bmN0aW9uIG5lZWRzIHRvIGJlIHJld3JpdHRlbiB1c2luZyBzb21lIG5hdGl2ZVxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXG4gKiBleHBlY3RlZCBkdXJpbmcgYm9vdHN0cmFwcGluZyAoc2VlIG1pcnJvci5qcyBpbiByMTE0OTAzKS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXG4gKiAgICAgcHJvdG90eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gc3VwZXJDdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGluaGVyaXQgcHJvdG90eXBlIGZyb20uXG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xuICAvLyBEb24ndCBkbyBhbnl0aGluZyBpZiBhZGQgaXNuJ3QgYW4gb2JqZWN0XG4gIGlmICghYWRkIHx8ICFpc09iamVjdChhZGQpKSByZXR1cm4gb3JpZ2luO1xuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoYWRkKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIG9yaWdpbltrZXlzW2ldXSA9IGFkZFtrZXlzW2ldXTtcbiAgfVxuICByZXR1cm4gb3JpZ2luO1xufTtcblxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxudmFyIGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnID8gU3ltYm9sKCd1dGlsLnByb21pc2lmeS5jdXN0b20nKSA6IHVuZGVmaW5lZDtcblxuZXhwb3J0cy5wcm9taXNpZnkgPSBmdW5jdGlvbiBwcm9taXNpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJvcmlnaW5hbFwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbicpO1xuXG4gIGlmIChrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wgJiYgb3JpZ2luYWxba0N1c3RvbVByb21pc2lmaWVkU3ltYm9sXSkge1xuICAgIHZhciBmbiA9IG9yaWdpbmFsW2tDdXN0b21Qcm9taXNpZmllZFN5bWJvbF07XG4gICAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwidXRpbC5wcm9taXNpZnkuY3VzdG9tXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwga0N1c3RvbVByb21pc2lmaWVkU3ltYm9sLCB7XG4gICAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBmbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZuKCkge1xuICAgIHZhciBwcm9taXNlUmVzb2x2ZSwgcHJvbWlzZVJlamVjdDtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgfSk7XG5cbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG4gICAgYXJncy5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb21pc2VSZXNvbHZlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRyeSB7XG4gICAgICBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHByb21pc2VSZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihmbiwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG9yaWdpbmFsKSk7XG5cbiAgaWYgKGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbCkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZuLCBrQ3VzdG9tUHJvbWlzaWZpZWRTeW1ib2wsIHtcbiAgICB2YWx1ZTogZm4sIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogZmFsc2UsIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFxuICAgIGZuLFxuICAgIGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMob3JpZ2luYWwpXG4gICk7XG59XG5cbmV4cG9ydHMucHJvbWlzaWZ5LmN1c3RvbSA9IGtDdXN0b21Qcm9taXNpZmllZFN5bWJvbFxuXG5mdW5jdGlvbiBjYWxsYmFja2lmeU9uUmVqZWN0ZWQocmVhc29uLCBjYikge1xuICAvLyBgIXJlYXNvbmAgZ3VhcmQgaW5zcGlyZWQgYnkgYmx1ZWJpcmQgKFJlZjogaHR0cHM6Ly9nb28uZ2wvdDVJUzZNKS5cbiAgLy8gQmVjYXVzZSBgbnVsbGAgaXMgYSBzcGVjaWFsIGVycm9yIHZhbHVlIGluIGNhbGxiYWNrcyB3aGljaCBtZWFucyBcIm5vIGVycm9yXG4gIC8vIG9jY3VycmVkXCIsIHdlIGVycm9yLXdyYXAgc28gdGhlIGNhbGxiYWNrIGNvbnN1bWVyIGNhbiBkaXN0aW5ndWlzaCBiZXR3ZWVuXG4gIC8vIFwidGhlIHByb21pc2UgcmVqZWN0ZWQgd2l0aCBudWxsXCIgb3IgXCJ0aGUgcHJvbWlzZSBmdWxmaWxsZWQgd2l0aCB1bmRlZmluZWRcIi5cbiAgaWYgKCFyZWFzb24pIHtcbiAgICB2YXIgbmV3UmVhc29uID0gbmV3IEVycm9yKCdQcm9taXNlIHdhcyByZWplY3RlZCB3aXRoIGEgZmFsc3kgdmFsdWUnKTtcbiAgICBuZXdSZWFzb24ucmVhc29uID0gcmVhc29uO1xuICAgIHJlYXNvbiA9IG5ld1JlYXNvbjtcbiAgfVxuICByZXR1cm4gY2IocmVhc29uKTtcbn1cblxuZnVuY3Rpb24gY2FsbGJhY2tpZnkob3JpZ2luYWwpIHtcbiAgaWYgKHR5cGVvZiBvcmlnaW5hbCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcIm9yaWdpbmFsXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uJyk7XG4gIH1cblxuICAvLyBXZSBETyBOT1QgcmV0dXJuIHRoZSBwcm9taXNlIGFzIGl0IGdpdmVzIHRoZSB1c2VyIGEgZmFsc2Ugc2Vuc2UgdGhhdFxuICAvLyB0aGUgcHJvbWlzZSBpcyBhY3R1YWxseSBzb21laG93IHJlbGF0ZWQgdG8gdGhlIGNhbGxiYWNrJ3MgZXhlY3V0aW9uXG4gIC8vIGFuZCB0aGF0IHRoZSBjYWxsYmFjayB0aHJvd2luZyB3aWxsIHJlamVjdCB0aGUgcHJvbWlzZS5cbiAgZnVuY3Rpb24gY2FsbGJhY2tpZmllZCgpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB9XG5cbiAgICB2YXIgbWF5YmVDYiA9IGFyZ3MucG9wKCk7XG4gICAgaWYgKHR5cGVvZiBtYXliZUNiICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGFzdCBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24nKTtcbiAgICB9XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBjYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG1heWJlQ2IuYXBwbHkoc2VsZiwgYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIEluIHRydWUgbm9kZSBzdHlsZSB3ZSBwcm9jZXNzIHRoZSBjYWxsYmFjayBvbiBgbmV4dFRpY2tgIHdpdGggYWxsIHRoZVxuICAgIC8vIGltcGxpY2F0aW9ucyAoc3RhY2ssIGB1bmNhdWdodEV4Y2VwdGlvbmAsIGBhc3luY19ob29rc2ApXG4gICAgb3JpZ2luYWwuYXBwbHkodGhpcywgYXJncylcbiAgICAgIC50aGVuKGZ1bmN0aW9uKHJldCkgeyBwcm9jZXNzLm5leHRUaWNrKGNiLCBudWxsLCByZXQpIH0sXG4gICAgICAgICAgICBmdW5jdGlvbihyZWopIHsgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja2lmeU9uUmVqZWN0ZWQsIHJlaiwgY2IpIH0pO1xuICB9XG5cbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGNhbGxiYWNraWZpZWQsIE9iamVjdC5nZXRQcm90b3R5cGVPZihvcmlnaW5hbCkpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjYWxsYmFja2lmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKG9yaWdpbmFsKSk7XG4gIHJldHVybiBjYWxsYmFja2lmaWVkO1xufVxuZXhwb3J0cy5jYWxsYmFja2lmeSA9IGNhbGxiYWNraWZ5O1xuIiwiZXhwb3J0cy5lbmRpYW5uZXNzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0xFJyB9O1xuXG5leHBvcnRzLmhvc3RuYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0eXBlb2YgbG9jYXRpb24gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiBsb2NhdGlvbi5ob3N0bmFtZVxuICAgIH1cbiAgICBlbHNlIHJldHVybiAnJztcbn07XG5cbmV4cG9ydHMubG9hZGF2ZyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFtdIH07XG5cbmV4cG9ydHMudXB0aW1lID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gMCB9O1xuXG5leHBvcnRzLmZyZWVtZW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIE51bWJlci5NQVhfVkFMVUU7XG59O1xuXG5leHBvcnRzLnRvdGFsbWVtID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBOdW1iZXIuTUFYX1ZBTFVFO1xufTtcblxuZXhwb3J0cy5jcHVzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gW10gfTtcblxuZXhwb3J0cy50eXBlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ0Jyb3dzZXInIH07XG5cbmV4cG9ydHMucmVsZWFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5hcHBWZXJzaW9uO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59O1xuXG5leHBvcnRzLm5ldHdvcmtJbnRlcmZhY2VzXG49IGV4cG9ydHMuZ2V0TmV0d29ya0ludGVyZmFjZXNcbj0gZnVuY3Rpb24gKCkgeyByZXR1cm4ge30gfTtcblxuZXhwb3J0cy5hcmNoID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2phdmFzY3JpcHQnIH07XG5cbmV4cG9ydHMucGxhdGZvcm0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnYnJvd3NlcicgfTtcblxuZXhwb3J0cy50bXBkaXIgPSBleHBvcnRzLnRtcERpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJy90bXAnO1xufTtcblxuZXhwb3J0cy5FT0wgPSAnXFxuJztcblxuZXhwb3J0cy5ob21lZGlyID0gZnVuY3Rpb24gKCkge1xuXHRyZXR1cm4gJy8nXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5cbnZhciBUWVBFRF9PSyA9ICAodHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgVWludDE2QXJyYXkgIT09ICd1bmRlZmluZWQnKSAmJlxuICAgICAgICAgICAgICAgICh0eXBlb2YgSW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG5mdW5jdGlvbiBfaGFzKG9iaiwga2V5KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG5leHBvcnRzLmFzc2lnbiA9IGZ1bmN0aW9uIChvYmogLypmcm9tMSwgZnJvbTIsIGZyb20zLCAuLi4qLykge1xuICB2YXIgc291cmNlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHdoaWxlIChzb3VyY2VzLmxlbmd0aCkge1xuICAgIHZhciBzb3VyY2UgPSBzb3VyY2VzLnNoaWZ0KCk7XG4gICAgaWYgKCFzb3VyY2UpIHsgY29udGludWU7IH1cblxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzb3VyY2UgKyAnbXVzdCBiZSBub24tb2JqZWN0Jyk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcCBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChfaGFzKHNvdXJjZSwgcCkpIHtcbiAgICAgICAgb2JqW3BdID0gc291cmNlW3BdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG5cbi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydHMuc2hyaW5rQnVmID0gZnVuY3Rpb24gKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxudmFyIGZuVHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICAgIGRlc3Quc2V0KHNyYy5zdWJhcnJheShzcmNfb2Zmcywgc3JjX29mZnMgKyBsZW4pLCBkZXN0X29mZnMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBGYWxsYmFjayB0byBvcmRpbmFyeSBhcnJheVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgICB9XG4gIH0sXG4gIC8vIEpvaW4gYXJyYXkgb2YgY2h1bmtzIHRvIHNpbmdsZSBhcnJheS5cbiAgZmxhdHRlbkNodW5rczogZnVuY3Rpb24gKGNodW5rcykge1xuICAgIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAgIC8vIGNhbGN1bGF0ZSBkYXRhIGxlbmd0aFxuICAgIGxlbiA9IDA7XG4gICAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGxlbiArPSBjaHVua3NbaV0ubGVuZ3RoO1xuICAgIH1cblxuICAgIC8vIGpvaW4gY2h1bmtzXG4gICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcbiAgICBwb3MgPSAwO1xuICAgIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBjaHVuayA9IGNodW5rc1tpXTtcbiAgICAgIHJlc3VsdC5zZXQoY2h1bmssIHBvcyk7XG4gICAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn07XG5cbnZhciBmblVudHlwZWQgPSB7XG4gIGFycmF5U2V0OiBmdW5jdGlvbiAoZGVzdCwgc3JjLCBzcmNfb2ZmcywgbGVuLCBkZXN0X29mZnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0W2Rlc3Rfb2ZmcyArIGldID0gc3JjW3NyY19vZmZzICsgaV07XG4gICAgfVxuICB9LFxuICAvLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG4gIGZsYXR0ZW5DaHVua3M6IGZ1bmN0aW9uIChjaHVua3MpIHtcbiAgICByZXR1cm4gW10uY29uY2F0LmFwcGx5KFtdLCBjaHVua3MpO1xuICB9XG59O1xuXG5cbi8vIEVuYWJsZS9EaXNhYmxlIHR5cGVkIGFycmF5cyB1c2UsIGZvciB0ZXN0aW5nXG4vL1xuZXhwb3J0cy5zZXRUeXBlZCA9IGZ1bmN0aW9uIChvbikge1xuICBpZiAob24pIHtcbiAgICBleHBvcnRzLkJ1ZjggID0gVWludDhBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjE2ID0gVWludDE2QXJyYXk7XG4gICAgZXhwb3J0cy5CdWYzMiA9IEludDMyQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5UeXBlZCk7XG4gIH0gZWxzZSB7XG4gICAgZXhwb3J0cy5CdWY4ICA9IEFycmF5O1xuICAgIGV4cG9ydHMuQnVmMTYgPSBBcnJheTtcbiAgICBleHBvcnRzLkJ1ZjMyID0gQXJyYXk7XG4gICAgZXhwb3J0cy5hc3NpZ24oZXhwb3J0cywgZm5VbnR5cGVkKTtcbiAgfVxufTtcblxuZXhwb3J0cy5zZXRUeXBlZChUWVBFRF9PSyk7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGlzbid0IHdvcnRoIGl0IHRvIG1ha2UgYWRkaXRpb25hbCBvcHRpbWl6YXRpb25zIGFzIGluIG9yaWdpbmFsLlxuLy8gU21hbGwgc2l6ZSBpcyBwcmVmZXJhYmxlLlxuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbmZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGFkbGVyMzI7XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG5cbiAgLyogQWxsb3dlZCBmbHVzaCB2YWx1ZXM7IHNlZSBkZWZsYXRlKCkgYW5kIGluZmxhdGUoKSBiZWxvdyBmb3IgZGV0YWlscyAqL1xuICBaX05PX0ZMVVNIOiAgICAgICAgIDAsXG4gIFpfUEFSVElBTF9GTFVTSDogICAgMSxcbiAgWl9TWU5DX0ZMVVNIOiAgICAgICAyLFxuICBaX0ZVTExfRkxVU0g6ICAgICAgIDMsXG4gIFpfRklOSVNIOiAgICAgICAgICAgNCxcbiAgWl9CTE9DSzogICAgICAgICAgICA1LFxuICBaX1RSRUVTOiAgICAgICAgICAgIDYsXG5cbiAgLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAgKi9cbiAgWl9PSzogICAgICAgICAgICAgICAwLFxuICBaX1NUUkVBTV9FTkQ6ICAgICAgIDEsXG4gIFpfTkVFRF9ESUNUOiAgICAgICAgMixcbiAgWl9FUlJOTzogICAgICAgICAgIC0xLFxuICBaX1NUUkVBTV9FUlJPUjogICAgLTIsXG4gIFpfREFUQV9FUlJPUjogICAgICAtMyxcbiAgLy9aX01FTV9FUlJPUjogICAgIC00LFxuICBaX0JVRl9FUlJPUjogICAgICAgLTUsXG4gIC8vWl9WRVJTSU9OX0VSUk9SOiAtNixcblxuICAvKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbiAgWl9OT19DT01QUkVTU0lPTjogICAgICAgICAwLFxuICBaX0JFU1RfU1BFRUQ6ICAgICAgICAgICAgIDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogICAgICAgOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAgIC0xLFxuXG5cbiAgWl9GSUxURVJFRDogICAgICAgICAgICAgICAxLFxuICBaX0hVRkZNQU5fT05MWTogICAgICAgICAgIDIsXG4gIFpfUkxFOiAgICAgICAgICAgICAgICAgICAgMyxcbiAgWl9GSVhFRDogICAgICAgICAgICAgICAgICA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6ICAgICAgIDAsXG5cbiAgLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xuICBaX0JJTkFSWTogICAgICAgICAgICAgICAgIDAsXG4gIFpfVEVYVDogICAgICAgICAgICAgICAgICAgMSxcbiAgLy9aX0FTQ0lJOiAgICAgICAgICAgICAgICAxLCAvLyA9IFpfVEVYVCAoZGVwcmVjYXRlZClcbiAgWl9VTktOT1dOOiAgICAgICAgICAgICAgICAyLFxuXG4gIC8qIFRoZSBkZWZsYXRlIGNvbXByZXNzaW9uIG1ldGhvZCAqL1xuICBaX0RFRkxBVEVEOiAgICAgICAgICAgICAgIDhcbiAgLy9aX05VTEw6ICAgICAgICAgICAgICAgICBudWxsIC8vIFVzZSAtMSBvciBudWxsIGlubGluZSwgZGVwZW5kaW5nIG9uIHZhciB0eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBOb3RlOiB3ZSBjYW4ndCBnZXQgc2lnbmlmaWNhbnQgc3BlZWQgYm9vc3QgaGVyZS5cbi8vIFNvIHdyaXRlIGNvZGUgdG8gbWluaW1pemUgc2l6ZSAtIG5vIHByZWdlbmVyYXRlZCB0YWJsZXNcbi8vIGFuZCBhcnJheSB0b29scyBkZXBlbmRlbmNpZXMuXG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuLy8gVXNlIG9yZGluYXJ5IGFycmF5LCBzaW5jZSB1bnR5cGVkIG1ha2VzIG5vIGJvb3N0IGhlcmVcbmZ1bmN0aW9uIG1ha2VUYWJsZSgpIHtcbiAgdmFyIGMsIHRhYmxlID0gW107XG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCAyNTY7IG4rKykge1xuICAgIGMgPSBuO1xuICAgIGZvciAodmFyIGsgPSAwOyBrIDwgODsgaysrKSB7XG4gICAgICBjID0gKChjICYgMSkgPyAoMHhFREI4ODMyMCBeIChjID4+PiAxKSkgOiAoYyA+Pj4gMSkpO1xuICAgIH1cbiAgICB0YWJsZVtuXSA9IGM7XG4gIH1cblxuICByZXR1cm4gdGFibGU7XG59XG5cbi8vIENyZWF0ZSB0YWJsZSBvbiBsb2FkLiBKdXN0IDI1NSBzaWduZWQgbG9uZ3MuIE5vdCBhIHByb2JsZW0uXG52YXIgY3JjVGFibGUgPSBtYWtlVGFibGUoKTtcblxuXG5mdW5jdGlvbiBjcmMzMihjcmMsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHQgPSBjcmNUYWJsZSxcbiAgICAgIGVuZCA9IHBvcyArIGxlbjtcblxuICBjcmMgXj0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IHBvczsgaSA8IGVuZDsgaSsrKSB7XG4gICAgY3JjID0gKGNyYyA+Pj4gOCkgXiB0WyhjcmMgXiBidWZbaV0pICYgMHhGRl07XG4gIH1cblxuICByZXR1cm4gKGNyYyBeICgtMSkpOyAvLyA+Pj4gMDtcbn1cblxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyYzMyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgdHJlZXMgICA9IHJlcXVpcmUoJy4vdHJlZXMnKTtcbnZhciBhZGxlcjMyID0gcmVxdWlyZSgnLi9hZGxlcjMyJyk7XG52YXIgY3JjMzIgICA9IHJlcXVpcmUoJy4vY3JjMzInKTtcbnZhciBtc2cgICAgID0gcmVxdWlyZSgnLi9tZXNzYWdlcycpO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG52YXIgWl9OT19GTFVTSCAgICAgID0gMDtcbnZhciBaX1BBUlRJQUxfRkxVU0ggPSAxO1xuLy92YXIgWl9TWU5DX0ZMVVNIICAgID0gMjtcbnZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbi8vdmFyIFpfVFJFRVMgICAgICAgICA9IDY7XG5cblxuLyogUmV0dXJuIGNvZGVzIGZvciB0aGUgY29tcHJlc3Npb24vZGVjb21wcmVzc2lvbiBmdW5jdGlvbnMuIE5lZ2F0aXZlIHZhbHVlc1xuICogYXJlIGVycm9ycywgcG9zaXRpdmUgdmFsdWVzIGFyZSB1c2VkIGZvciBzcGVjaWFsIGJ1dCBub3JtYWwgZXZlbnRzLlxuICovXG52YXIgWl9PSyAgICAgICAgICAgID0gMDtcbnZhciBaX1NUUkVBTV9FTkQgICAgPSAxO1xuLy92YXIgWl9ORUVEX0RJQ1QgICAgID0gMjtcbi8vdmFyIFpfRVJSTk8gICAgICAgICA9IC0xO1xudmFyIFpfU1RSRUFNX0VSUk9SICA9IC0yO1xudmFyIFpfREFUQV9FUlJPUiAgICA9IC0zO1xuLy92YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuXG4vKiBjb21wcmVzc2lvbiBsZXZlbHMgKi9cbi8vdmFyIFpfTk9fQ09NUFJFU1NJT04gICAgICA9IDA7XG4vL3ZhciBaX0JFU1RfU1BFRUQgICAgICAgICAgPSAxO1xuLy92YXIgWl9CRVNUX0NPTVBSRVNTSU9OICAgID0gOTtcbnZhciBaX0RFRkFVTFRfQ09NUFJFU1NJT04gPSAtMTtcblxuXG52YXIgWl9GSUxURVJFRCAgICAgICAgICAgID0gMTtcbnZhciBaX0hVRkZNQU5fT05MWSAgICAgICAgPSAyO1xudmFyIFpfUkxFICAgICAgICAgICAgICAgICA9IDM7XG52YXIgWl9GSVhFRCAgICAgICAgICAgICAgID0gNDtcbnZhciBaX0RFRkFVTFRfU1RSQVRFR1kgICAgPSAwO1xuXG4vKiBQb3NzaWJsZSB2YWx1ZXMgb2YgdGhlIGRhdGFfdHlwZSBmaWVsZCAodGhvdWdoIHNlZSBpbmZsYXRlKCkpICovXG4vL3ZhciBaX0JJTkFSWSAgICAgICAgICAgICAgPSAwO1xuLy92YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgICA9IDE7IC8vID0gWl9URVhUXG52YXIgWl9VTktOT1dOICAgICAgICAgICAgID0gMjtcblxuXG4vKiBUaGUgZGVmbGF0ZSBjb21wcmVzc2lvbiBtZXRob2QgKi9cbnZhciBaX0RFRkxBVEVEICA9IDg7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxudmFyIE1BWF9NRU1fTEVWRUwgPSA5O1xuLyogTWF4aW11bSB2YWx1ZSBmb3IgbWVtTGV2ZWwgaW4gZGVmbGF0ZUluaXQyICovXG52YXIgTUFYX1dCSVRTID0gMTU7XG4vKiAzMksgTFo3NyB3aW5kb3cgKi9cbnZhciBERUZfTUVNX0xFVkVMID0gODtcblxuXG52YXIgTEVOR1RIX0NPREVTICA9IDI5O1xuLyogbnVtYmVyIG9mIGxlbmd0aCBjb2Rlcywgbm90IGNvdW50aW5nIHRoZSBzcGVjaWFsIEVORF9CTE9DSyBjb2RlICovXG52YXIgTElURVJBTFMgICAgICA9IDI1Njtcbi8qIG51bWJlciBvZiBsaXRlcmFsIGJ5dGVzIDAuLjI1NSAqL1xudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cbnZhciBEX0NPREVTICAgICAgID0gMzA7XG4vKiBudW1iZXIgb2YgZGlzdGFuY2UgY29kZXMgKi9cbnZhciBCTF9DT0RFUyAgICAgID0gMTk7XG4vKiBudW1iZXIgb2YgY29kZXMgdXNlZCB0byB0cmFuc2ZlciB0aGUgYml0IGxlbmd0aHMgKi9cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cbnZhciBNQVhfQklUUyAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgTUlOX01BVENIID0gMztcbnZhciBNQVhfTUFUQ0ggPSAyNTg7XG52YXIgTUlOX0xPT0tBSEVBRCA9IChNQVhfTUFUQ0ggKyBNSU5fTUFUQ0ggKyAxKTtcblxudmFyIFBSRVNFVF9ESUNUID0gMHgyMDtcblxudmFyIElOSVRfU1RBVEUgPSA0MjtcbnZhciBFWFRSQV9TVEFURSA9IDY5O1xudmFyIE5BTUVfU1RBVEUgPSA3MztcbnZhciBDT01NRU5UX1NUQVRFID0gOTE7XG52YXIgSENSQ19TVEFURSA9IDEwMztcbnZhciBCVVNZX1NUQVRFID0gMTEzO1xudmFyIEZJTklTSF9TVEFURSA9IDY2NjtcblxudmFyIEJTX05FRURfTU9SRSAgICAgID0gMTsgLyogYmxvY2sgbm90IGNvbXBsZXRlZCwgbmVlZCBtb3JlIGlucHV0IG9yIG1vcmUgb3V0cHV0ICovXG52YXIgQlNfQkxPQ0tfRE9ORSAgICAgPSAyOyAvKiBibG9jayBmbHVzaCBwZXJmb3JtZWQgKi9cbnZhciBCU19GSU5JU0hfU1RBUlRFRCA9IDM7IC8qIGZpbmlzaCBzdGFydGVkLCBuZWVkIG9ubHkgbW9yZSBvdXRwdXQgYXQgbmV4dCBkZWZsYXRlICovXG52YXIgQlNfRklOSVNIX0RPTkUgICAgPSA0OyAvKiBmaW5pc2ggZG9uZSwgYWNjZXB0IG5vIG1vcmUgaW5wdXQgb3Igb3V0cHV0ICovXG5cbnZhciBPU19DT0RFID0gMHgwMzsgLy8gVW5peCA6KSAuIERvbid0IGRldGVjdCwgdXNlIHRoaXMgZGVmYXVsdC5cblxuZnVuY3Rpb24gZXJyKHN0cm0sIGVycm9yQ29kZSkge1xuICBzdHJtLm1zZyA9IG1zZ1tlcnJvckNvZGVdO1xuICByZXR1cm4gZXJyb3JDb2RlO1xufVxuXG5mdW5jdGlvbiByYW5rKGYpIHtcbiAgcmV0dXJuICgoZikgPDwgMSkgLSAoKGYpID4gNCA/IDkgOiAwKTtcbn1cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRmx1c2ggYXMgbXVjaCBwZW5kaW5nIG91dHB1dCBhcyBwb3NzaWJsZS4gQWxsIGRlZmxhdGUoKSBvdXRwdXQgZ29lc1xuICogdGhyb3VnaCB0aGlzIGZ1bmN0aW9uIHNvIHNvbWUgYXBwbGljYXRpb25zIG1heSB3aXNoIHRvIG1vZGlmeSBpdFxuICogdG8gYXZvaWQgYWxsb2NhdGluZyBhIGxhcmdlIHN0cm0tPm91dHB1dCBidWZmZXIgYW5kIGNvcHlpbmcgaW50byBpdC5cbiAqIChTZWUgYWxzbyByZWFkX2J1ZigpKS5cbiAqL1xuZnVuY3Rpb24gZmx1c2hfcGVuZGluZyhzdHJtKSB7XG4gIHZhciBzID0gc3RybS5zdGF0ZTtcblxuICAvL190cl9mbHVzaF9iaXRzKHMpO1xuICB2YXIgbGVuID0gcy5wZW5kaW5nO1xuICBpZiAobGVuID4gc3RybS5hdmFpbF9vdXQpIHtcbiAgICBsZW4gPSBzdHJtLmF2YWlsX291dDtcbiAgfVxuICBpZiAobGVuID09PSAwKSB7IHJldHVybjsgfVxuXG4gIHV0aWxzLmFycmF5U2V0KHN0cm0ub3V0cHV0LCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmdfb3V0LCBsZW4sIHN0cm0ubmV4dF9vdXQpO1xuICBzdHJtLm5leHRfb3V0ICs9IGxlbjtcbiAgcy5wZW5kaW5nX291dCArPSBsZW47XG4gIHN0cm0udG90YWxfb3V0ICs9IGxlbjtcbiAgc3RybS5hdmFpbF9vdXQgLT0gbGVuO1xuICBzLnBlbmRpbmcgLT0gbGVuO1xuICBpZiAocy5wZW5kaW5nID09PSAwKSB7XG4gICAgcy5wZW5kaW5nX291dCA9IDA7XG4gIH1cbn1cblxuXG5mdW5jdGlvbiBmbHVzaF9ibG9ja19vbmx5KHMsIGxhc3QpIHtcbiAgdHJlZXMuX3RyX2ZsdXNoX2Jsb2NrKHMsIChzLmJsb2NrX3N0YXJ0ID49IDAgPyBzLmJsb2NrX3N0YXJ0IDogLTEpLCBzLnN0cnN0YXJ0IC0gcy5ibG9ja19zdGFydCwgbGFzdCk7XG4gIHMuYmxvY2tfc3RhcnQgPSBzLnN0cnN0YXJ0O1xuICBmbHVzaF9wZW5kaW5nKHMuc3RybSk7XG59XG5cblxuZnVuY3Rpb24gcHV0X2J5dGUocywgYikge1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IGI7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogUHV0IGEgc2hvcnQgaW4gdGhlIHBlbmRpbmcgYnVmZmVyLiBUaGUgMTYtYml0IHZhbHVlIGlzIHB1dCBpbiBNU0Igb3JkZXIuXG4gKiBJTiBhc3NlcnRpb246IHRoZSBzdHJlYW0gc3RhdGUgaXMgY29ycmVjdCBhbmQgdGhlcmUgaXMgZW5vdWdoIHJvb20gaW5cbiAqIHBlbmRpbmdfYnVmLlxuICovXG5mdW5jdGlvbiBwdXRTaG9ydE1TQihzLCBiKSB7XG4vLyAgcHV0X2J5dGUocywgKEJ5dGUpKGIgPj4gOCkpO1xuLy8gIHB1dF9ieXRlKHMsIChCeXRlKShiICYgMHhmZikpO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9IChiID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gYiAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZWFkIGEgbmV3IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGlucHV0IHN0cmVhbSwgdXBkYXRlIHRoZSBhZGxlcjMyXG4gKiBhbmQgdG90YWwgbnVtYmVyIG9mIGJ5dGVzIHJlYWQuICBBbGwgZGVmbGF0ZSgpIGlucHV0IGdvZXMgdGhyb3VnaFxuICogdGhpcyBmdW5jdGlvbiBzbyBzb21lIGFwcGxpY2F0aW9ucyBtYXkgd2lzaCB0byBtb2RpZnkgaXQgdG8gYXZvaWRcbiAqIGFsbG9jYXRpbmcgYSBsYXJnZSBzdHJtLT5pbnB1dCBidWZmZXIgYW5kIGNvcHlpbmcgZnJvbSBpdC5cbiAqIChTZWUgYWxzbyBmbHVzaF9wZW5kaW5nKCkpLlxuICovXG5mdW5jdGlvbiByZWFkX2J1ZihzdHJtLCBidWYsIHN0YXJ0LCBzaXplKSB7XG4gIHZhciBsZW4gPSBzdHJtLmF2YWlsX2luO1xuXG4gIGlmIChsZW4gPiBzaXplKSB7IGxlbiA9IHNpemU7IH1cbiAgaWYgKGxlbiA9PT0gMCkgeyByZXR1cm4gMDsgfVxuXG4gIHN0cm0uYXZhaWxfaW4gLT0gbGVuO1xuXG4gIC8vIHptZW1jcHkoYnVmLCBzdHJtLT5uZXh0X2luLCBsZW4pO1xuICB1dGlscy5hcnJheVNldChidWYsIHN0cm0uaW5wdXQsIHN0cm0ubmV4dF9pbiwgbGVuLCBzdGFydCk7XG4gIGlmIChzdHJtLnN0YXRlLndyYXAgPT09IDEpIHtcbiAgICBzdHJtLmFkbGVyID0gYWRsZXIzMihzdHJtLmFkbGVyLCBidWYsIGxlbiwgc3RhcnQpO1xuICB9XG5cbiAgZWxzZSBpZiAoc3RybS5zdGF0ZS53cmFwID09PSAyKSB7XG4gICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIGJ1ZiwgbGVuLCBzdGFydCk7XG4gIH1cblxuICBzdHJtLm5leHRfaW4gKz0gbGVuO1xuICBzdHJtLnRvdGFsX2luICs9IGxlbjtcblxuICByZXR1cm4gbGVuO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2V0IG1hdGNoX3N0YXJ0IHRvIHRoZSBsb25nZXN0IG1hdGNoIHN0YXJ0aW5nIGF0IHRoZSBnaXZlbiBzdHJpbmcgYW5kXG4gKiByZXR1cm4gaXRzIGxlbmd0aC4gTWF0Y2hlcyBzaG9ydGVyIG9yIGVxdWFsIHRvIHByZXZfbGVuZ3RoIGFyZSBkaXNjYXJkZWQsXG4gKiBpbiB3aGljaCBjYXNlIHRoZSByZXN1bHQgaXMgZXF1YWwgdG8gcHJldl9sZW5ndGggYW5kIG1hdGNoX3N0YXJ0IGlzXG4gKiBnYXJiYWdlLlxuICogSU4gYXNzZXJ0aW9uczogY3VyX21hdGNoIGlzIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluIGZvciB0aGUgY3VycmVudFxuICogICBzdHJpbmcgKHN0cnN0YXJ0KSBhbmQgaXRzIGRpc3RhbmNlIGlzIDw9IE1BWF9ESVNULCBhbmQgcHJldl9sZW5ndGggPj0gMVxuICogT1VUIGFzc2VydGlvbjogdGhlIG1hdGNoIGxlbmd0aCBpcyBub3QgZ3JlYXRlciB0aGFuIHMtPmxvb2thaGVhZC5cbiAqL1xuZnVuY3Rpb24gbG9uZ2VzdF9tYXRjaChzLCBjdXJfbWF0Y2gpIHtcbiAgdmFyIGNoYWluX2xlbmd0aCA9IHMubWF4X2NoYWluX2xlbmd0aDsgICAgICAvKiBtYXggaGFzaCBjaGFpbiBsZW5ndGggKi9cbiAgdmFyIHNjYW4gPSBzLnN0cnN0YXJ0OyAvKiBjdXJyZW50IHN0cmluZyAqL1xuICB2YXIgbWF0Y2g7ICAgICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaGVkIHN0cmluZyAqL1xuICB2YXIgbGVuOyAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCBvZiBjdXJyZW50IG1hdGNoICovXG4gIHZhciBiZXN0X2xlbiA9IHMucHJldl9sZW5ndGg7ICAgICAgICAgICAgICAvKiBiZXN0IG1hdGNoIGxlbmd0aCBzbyBmYXIgKi9cbiAgdmFyIG5pY2VfbWF0Y2ggPSBzLm5pY2VfbWF0Y2g7ICAgICAgICAgICAgIC8qIHN0b3AgaWYgbWF0Y2ggbG9uZyBlbm91Z2ggKi9cbiAgdmFyIGxpbWl0ID0gKHMuc3Ryc3RhcnQgPiAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSkgP1xuICAgICAgcy5zdHJzdGFydCAtIChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpIDogMC8qTklMKi87XG5cbiAgdmFyIF93aW4gPSBzLndpbmRvdzsgLy8gc2hvcnRjdXRcblxuICB2YXIgd21hc2sgPSBzLndfbWFzaztcbiAgdmFyIHByZXYgID0gcy5wcmV2O1xuXG4gIC8qIFN0b3Agd2hlbiBjdXJfbWF0Y2ggYmVjb21lcyA8PSBsaW1pdC4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsXG4gICAqIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmcgb2Ygd2luZG93IGluZGV4IDAuXG4gICAqL1xuXG4gIHZhciBzdHJlbmQgPSBzLnN0cnN0YXJ0ICsgTUFYX01BVENIO1xuICB2YXIgc2Nhbl9lbmQxICA9IF93aW5bc2NhbiArIGJlc3RfbGVuIC0gMV07XG4gIHZhciBzY2FuX2VuZCAgID0gX3dpbltzY2FuICsgYmVzdF9sZW5dO1xuXG4gIC8qIFRoZSBjb2RlIGlzIG9wdGltaXplZCBmb3IgSEFTSF9CSVRTID49IDggYW5kIE1BWF9NQVRDSC0yIG11bHRpcGxlIG9mIDE2LlxuICAgKiBJdCBpcyBlYXN5IHRvIGdldCByaWQgb2YgdGhpcyBvcHRpbWl6YXRpb24gaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgLy8gQXNzZXJ0KHMtPmhhc2hfYml0cyA+PSA4ICYmIE1BWF9NQVRDSCA9PSAyNTgsIFwiQ29kZSB0b28gY2xldmVyXCIpO1xuXG4gIC8qIERvIG5vdCB3YXN0ZSB0b28gbXVjaCB0aW1lIGlmIHdlIGFscmVhZHkgaGF2ZSBhIGdvb2QgbWF0Y2g6ICovXG4gIGlmIChzLnByZXZfbGVuZ3RoID49IHMuZ29vZF9tYXRjaCkge1xuICAgIGNoYWluX2xlbmd0aCA+Pj0gMjtcbiAgfVxuICAvKiBEbyBub3QgbG9vayBmb3IgbWF0Y2hlcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgaW5wdXQuIFRoaXMgaXMgbmVjZXNzYXJ5XG4gICAqIHRvIG1ha2UgZGVmbGF0ZSBkZXRlcm1pbmlzdGljLlxuICAgKi9cbiAgaWYgKG5pY2VfbWF0Y2ggPiBzLmxvb2thaGVhZCkgeyBuaWNlX21hdGNoID0gcy5sb29rYWhlYWQ7IH1cblxuICAvLyBBc3NlcnQoKHVsZylzLT5zdHJzdGFydCA8PSBzLT53aW5kb3dfc2l6ZS1NSU5fTE9PS0FIRUFELCBcIm5lZWQgbG9va2FoZWFkXCIpO1xuXG4gIGRvIHtcbiAgICAvLyBBc3NlcnQoY3VyX21hdGNoIDwgcy0+c3Ryc3RhcnQsIFwibm8gZnV0dXJlXCIpO1xuICAgIG1hdGNoID0gY3VyX21hdGNoO1xuXG4gICAgLyogU2tpcCB0byBuZXh0IG1hdGNoIGlmIHRoZSBtYXRjaCBsZW5ndGggY2Fubm90IGluY3JlYXNlXG4gICAgICogb3IgaWYgdGhlIG1hdGNoIGxlbmd0aCBpcyBsZXNzIHRoYW4gMi4gIE5vdGUgdGhhdCB0aGUgY2hlY2tzIGJlbG93XG4gICAgICogZm9yIGluc3VmZmljaWVudCBsb29rYWhlYWQgb25seSBvY2N1ciBvY2Nhc2lvbmFsbHkgZm9yIHBlcmZvcm1hbmNlXG4gICAgICogcmVhc29ucy4gIFRoZXJlZm9yZSB1bmluaXRpYWxpemVkIG1lbW9yeSB3aWxsIGJlIGFjY2Vzc2VkLCBhbmRcbiAgICAgKiBjb25kaXRpb25hbCBqdW1wcyB3aWxsIGJlIG1hZGUgdGhhdCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzLlxuICAgICAqIEhvd2V2ZXIgdGhlIGxlbmd0aCBvZiB0aGUgbWF0Y2ggaXMgbGltaXRlZCB0byB0aGUgbG9va2FoZWFkLCBzb1xuICAgICAqIHRoZSBvdXRwdXQgb2YgZGVmbGF0ZSBpcyBub3QgYWZmZWN0ZWQgYnkgdGhlIHVuaW5pdGlhbGl6ZWQgdmFsdWVzLlxuICAgICAqL1xuXG4gICAgaWYgKF93aW5bbWF0Y2ggKyBiZXN0X2xlbl0gICAgICE9PSBzY2FuX2VuZCAgfHxcbiAgICAgICAgX3dpblttYXRjaCArIGJlc3RfbGVuIC0gMV0gIT09IHNjYW5fZW5kMSB8fFxuICAgICAgICBfd2luW21hdGNoXSAgICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuXSB8fFxuICAgICAgICBfd2luWysrbWF0Y2hdICAgICAgICAgICAgICAhPT0gX3dpbltzY2FuICsgMV0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8qIFRoZSBjaGVjayBhdCBiZXN0X2xlbi0xIGNhbiBiZSByZW1vdmVkIGJlY2F1c2UgaXQgd2lsbCBiZSBtYWRlXG4gICAgICogYWdhaW4gbGF0ZXIuIChUaGlzIGhldXJpc3RpYyBpcyBub3QgYWx3YXlzIGEgd2luLilcbiAgICAgKiBJdCBpcyBub3QgbmVjZXNzYXJ5IHRvIGNvbXBhcmUgc2NhblsyXSBhbmQgbWF0Y2hbMl0gc2luY2UgdGhleVxuICAgICAqIGFyZSBhbHdheXMgZXF1YWwgd2hlbiB0aGUgb3RoZXIgYnl0ZXMgbWF0Y2gsIGdpdmVuIHRoYXRcbiAgICAgKiB0aGUgaGFzaCBrZXlzIGFyZSBlcXVhbCBhbmQgdGhhdCBIQVNIX0JJVFMgPj0gOC5cbiAgICAgKi9cbiAgICBzY2FuICs9IDI7XG4gICAgbWF0Y2grKztcbiAgICAvLyBBc3NlcnQoKnNjYW4gPT0gKm1hdGNoLCBcIm1hdGNoWzJdP1wiKTtcblxuICAgIC8qIFdlIGNoZWNrIGZvciBpbnN1ZmZpY2llbnQgbG9va2FoZWFkIG9ubHkgZXZlcnkgOHRoIGNvbXBhcmlzb247XG4gICAgICogdGhlIDI1NnRoIGNoZWNrIHdpbGwgYmUgbWFkZSBhdCBzdHJzdGFydCsyNTguXG4gICAgICovXG4gICAgZG8ge1xuICAgICAgLypqc2hpbnQgbm9lbXB0eTpmYWxzZSovXG4gICAgfSB3aGlsZSAoX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJiBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiZcbiAgICAgICAgICAgICBfd2luWysrc2Nhbl0gPT09IF93aW5bKyttYXRjaF0gJiYgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmXG4gICAgICAgICAgICAgX3dpblsrK3NjYW5dID09PSBfd2luWysrbWF0Y2hdICYmIF93aW5bKytzY2FuXSA9PT0gX3dpblsrK21hdGNoXSAmJlxuICAgICAgICAgICAgIHNjYW4gPCBzdHJlbmQpO1xuXG4gICAgLy8gQXNzZXJ0KHNjYW4gPD0gcy0+d2luZG93Kyh1bnNpZ25lZCkocy0+d2luZG93X3NpemUtMSksIFwid2lsZCBzY2FuXCIpO1xuXG4gICAgbGVuID0gTUFYX01BVENIIC0gKHN0cmVuZCAtIHNjYW4pO1xuICAgIHNjYW4gPSBzdHJlbmQgLSBNQVhfTUFUQ0g7XG5cbiAgICBpZiAobGVuID4gYmVzdF9sZW4pIHtcbiAgICAgIHMubWF0Y2hfc3RhcnQgPSBjdXJfbWF0Y2g7XG4gICAgICBiZXN0X2xlbiA9IGxlbjtcbiAgICAgIGlmIChsZW4gPj0gbmljZV9tYXRjaCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHNjYW5fZW5kMSAgPSBfd2luW3NjYW4gKyBiZXN0X2xlbiAtIDFdO1xuICAgICAgc2Nhbl9lbmQgICA9IF93aW5bc2NhbiArIGJlc3RfbGVuXTtcbiAgICB9XG4gIH0gd2hpbGUgKChjdXJfbWF0Y2ggPSBwcmV2W2N1cl9tYXRjaCAmIHdtYXNrXSkgPiBsaW1pdCAmJiAtLWNoYWluX2xlbmd0aCAhPT0gMCk7XG5cbiAgaWYgKGJlc3RfbGVuIDw9IHMubG9va2FoZWFkKSB7XG4gICAgcmV0dXJuIGJlc3RfbGVuO1xuICB9XG4gIHJldHVybiBzLmxvb2thaGVhZDtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEZpbGwgdGhlIHdpbmRvdyB3aGVuIHRoZSBsb29rYWhlYWQgYmVjb21lcyBpbnN1ZmZpY2llbnQuXG4gKiBVcGRhdGVzIHN0cnN0YXJ0IGFuZCBsb29rYWhlYWQuXG4gKlxuICogSU4gYXNzZXJ0aW9uOiBsb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEXG4gKiBPVVQgYXNzZXJ0aW9uczogc3Ryc3RhcnQgPD0gd2luZG93X3NpemUtTUlOX0xPT0tBSEVBRFxuICogICAgQXQgbGVhc3Qgb25lIGJ5dGUgaGFzIGJlZW4gcmVhZCwgb3IgYXZhaWxfaW4gPT0gMDsgcmVhZHMgYXJlXG4gKiAgICBwZXJmb3JtZWQgZm9yIGF0IGxlYXN0IHR3byBieXRlcyAocmVxdWlyZWQgZm9yIHRoZSB6aXAgdHJhbnNsYXRlX2VvbFxuICogICAgb3B0aW9uIC0tIG5vdCBzdXBwb3J0ZWQgaGVyZSkuXG4gKi9cbmZ1bmN0aW9uIGZpbGxfd2luZG93KHMpIHtcbiAgdmFyIF93X3NpemUgPSBzLndfc2l6ZTtcbiAgdmFyIHAsIG4sIG0sIG1vcmUsIHN0cjtcblxuICAvL0Fzc2VydChzLT5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFELCBcImFscmVhZHkgZW5vdWdoIGxvb2thaGVhZFwiKTtcblxuICBkbyB7XG4gICAgbW9yZSA9IHMud2luZG93X3NpemUgLSBzLmxvb2thaGVhZCAtIHMuc3Ryc3RhcnQ7XG5cbiAgICAvLyBKUyBpbnRzIGhhdmUgMzIgYml0LCBibG9jayBiZWxvdyBub3QgbmVlZGVkXG4gICAgLyogRGVhbCB3aXRoICFAIyQlIDY0SyBsaW1pdDogKi9cbiAgICAvL2lmIChzaXplb2YoaW50KSA8PSAyKSB7XG4gICAgLy8gICAgaWYgKG1vcmUgPT0gMCAmJiBzLT5zdHJzdGFydCA9PSAwICYmIHMtPmxvb2thaGVhZCA9PSAwKSB7XG4gICAgLy8gICAgICAgIG1vcmUgPSB3c2l6ZTtcbiAgICAvL1xuICAgIC8vICB9IGVsc2UgaWYgKG1vcmUgPT0gKHVuc2lnbmVkKSgtMSkpIHtcbiAgICAvLyAgICAgICAgLyogVmVyeSB1bmxpa2VseSwgYnV0IHBvc3NpYmxlIG9uIDE2IGJpdCBtYWNoaW5lIGlmXG4gICAgLy8gICAgICAgICAqIHN0cnN0YXJ0ID09IDAgJiYgbG9va2FoZWFkID09IDEgKGlucHV0IGRvbmUgYSBieXRlIGF0IHRpbWUpXG4gICAgLy8gICAgICAgICAqL1xuICAgIC8vICAgICAgICBtb3JlLS07XG4gICAgLy8gICAgfVxuICAgIC8vfVxuXG5cbiAgICAvKiBJZiB0aGUgd2luZG93IGlzIGFsbW9zdCBmdWxsIGFuZCB0aGVyZSBpcyBpbnN1ZmZpY2llbnQgbG9va2FoZWFkLFxuICAgICAqIG1vdmUgdGhlIHVwcGVyIGhhbGYgdG8gdGhlIGxvd2VyIG9uZSB0byBtYWtlIHJvb20gaW4gdGhlIHVwcGVyIGhhbGYuXG4gICAgICovXG4gICAgaWYgKHMuc3Ryc3RhcnQgPj0gX3dfc2l6ZSArIChfd19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcblxuICAgICAgdXRpbHMuYXJyYXlTZXQocy53aW5kb3csIHMud2luZG93LCBfd19zaXplLCBfd19zaXplLCAwKTtcbiAgICAgIHMubWF0Y2hfc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIHMuc3Ryc3RhcnQgLT0gX3dfc2l6ZTtcbiAgICAgIC8qIHdlIG5vdyBoYXZlIHN0cnN0YXJ0ID49IE1BWF9ESVNUICovXG4gICAgICBzLmJsb2NrX3N0YXJ0IC09IF93X3NpemU7XG5cbiAgICAgIC8qIFNsaWRlIHRoZSBoYXNoIHRhYmxlIChjb3VsZCBiZSBhdm9pZGVkIHdpdGggMzIgYml0IHZhbHVlc1xuICAgICAgIGF0IHRoZSBleHBlbnNlIG9mIG1lbW9yeSB1c2FnZSkuIFdlIHNsaWRlIGV2ZW4gd2hlbiBsZXZlbCA9PSAwXG4gICAgICAgdG8ga2VlcCB0aGUgaGFzaCB0YWJsZSBjb25zaXN0ZW50IGlmIHdlIHN3aXRjaCBiYWNrIHRvIGxldmVsID4gMFxuICAgICAgIGxhdGVyLiAoVXNpbmcgbGV2ZWwgMCBwZXJtYW5lbnRseSBpcyBub3QgYW4gb3B0aW1hbCB1c2FnZSBvZlxuICAgICAgIHpsaWIsIHNvIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhpcyBwYXRob2xvZ2ljYWwgY2FzZS4pXG4gICAgICAgKi9cblxuICAgICAgbiA9IHMuaGFzaF9zaXplO1xuICAgICAgcCA9IG47XG4gICAgICBkbyB7XG4gICAgICAgIG0gPSBzLmhlYWRbLS1wXTtcbiAgICAgICAgcy5oZWFkW3BdID0gKG0gPj0gX3dfc2l6ZSA/IG0gLSBfd19zaXplIDogMCk7XG4gICAgICB9IHdoaWxlICgtLW4pO1xuXG4gICAgICBuID0gX3dfc2l6ZTtcbiAgICAgIHAgPSBuO1xuICAgICAgZG8ge1xuICAgICAgICBtID0gcy5wcmV2Wy0tcF07XG4gICAgICAgIHMucHJldltwXSA9IChtID49IF93X3NpemUgPyBtIC0gX3dfc2l6ZSA6IDApO1xuICAgICAgICAvKiBJZiBuIGlzIG5vdCBvbiBhbnkgaGFzaCBjaGFpbiwgcHJldltuXSBpcyBnYXJiYWdlIGJ1dFxuICAgICAgICAgKiBpdHMgdmFsdWUgd2lsbCBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgKi9cbiAgICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICAgIG1vcmUgKz0gX3dfc2l6ZTtcbiAgICB9XG4gICAgaWYgKHMuc3RybS5hdmFpbF9pbiA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLyogSWYgdGhlcmUgd2FzIG5vIHNsaWRpbmc6XG4gICAgICogICAgc3Ryc3RhcnQgPD0gV1NJWkUrTUFYX0RJU1QtMSAmJiBsb29rYWhlYWQgPD0gTUlOX0xPT0tBSEVBRCAtIDEgJiZcbiAgICAgKiAgICBtb3JlID09IHdpbmRvd19zaXplIC0gbG9va2FoZWFkIC0gc3Ryc3RhcnRcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gKE1JTl9MT09LQUhFQUQtMSArIFdTSVpFICsgTUFYX0RJU1QtMSlcbiAgICAgKiA9PiBtb3JlID49IHdpbmRvd19zaXplIC0gMipXU0laRSArIDJcbiAgICAgKiBJbiB0aGUgQklHX01FTSBvciBNTUFQIGNhc2UgKG5vdCB5ZXQgc3VwcG9ydGVkKSxcbiAgICAgKiAgIHdpbmRvd19zaXplID09IGlucHV0X3NpemUgKyBNSU5fTE9PS0FIRUFEICAmJlxuICAgICAqICAgc3Ryc3RhcnQgKyBzLT5sb29rYWhlYWQgPD0gaW5wdXRfc2l6ZSA9PiBtb3JlID49IE1JTl9MT09LQUhFQUQuXG4gICAgICogT3RoZXJ3aXNlLCB3aW5kb3dfc2l6ZSA9PSAyKldTSVpFIHNvIG1vcmUgPj0gMi5cbiAgICAgKiBJZiB0aGVyZSB3YXMgc2xpZGluZywgbW9yZSA+PSBXU0laRS4gU28gaW4gYWxsIGNhc2VzLCBtb3JlID49IDIuXG4gICAgICovXG4gICAgLy9Bc3NlcnQobW9yZSA+PSAyLCBcIm1vcmUgPCAyXCIpO1xuICAgIG4gPSByZWFkX2J1ZihzLnN0cm0sIHMud2luZG93LCBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQsIG1vcmUpO1xuICAgIHMubG9va2FoZWFkICs9IG47XG5cbiAgICAvKiBJbml0aWFsaXplIHRoZSBoYXNoIHZhbHVlIG5vdyB0aGF0IHdlIGhhdmUgc29tZSBpbnB1dDogKi9cbiAgICBpZiAocy5sb29rYWhlYWQgKyBzLmluc2VydCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIHN0ciA9IHMuc3Ryc3RhcnQgLSBzLmluc2VydDtcbiAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzdHJdO1xuXG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIDFdKTsgKi9cbiAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIDFdKSAmIHMuaGFzaF9tYXNrO1xuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICBDYWxsIHVwZGF0ZV9oYXNoKCkgTUlOX01BVENILTMgbW9yZSB0aW1lc1xuLy8jZW5kaWZcbiAgICAgIHdoaWxlIChzLmluc2VydCkge1xuICAgICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3N0ciArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuXG4gICAgICAgIHMucHJldltzdHIgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHN0cjtcbiAgICAgICAgc3RyKys7XG4gICAgICAgIHMuaW5zZXJ0LS07XG4gICAgICAgIGlmIChzLmxvb2thaGVhZCArIHMuaW5zZXJ0IDwgTUlOX01BVENIKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlIHdob2xlIGlucHV0IGhhcyBsZXNzIHRoYW4gTUlOX01BVENIIGJ5dGVzLCBpbnNfaCBpcyBnYXJiYWdlLFxuICAgICAqIGJ1dCB0aGlzIGlzIG5vdCBpbXBvcnRhbnQgc2luY2Ugb25seSBsaXRlcmFsIGJ5dGVzIHdpbGwgYmUgZW1pdHRlZC5cbiAgICAgKi9cblxuICB9IHdoaWxlIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgcy5zdHJtLmF2YWlsX2luICE9PSAwKTtcblxuICAvKiBJZiB0aGUgV0lOX0lOSVQgYnl0ZXMgYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBkYXRhIGhhdmUgbmV2ZXIgYmVlblxuICAgKiB3cml0dGVuLCB0aGVuIHplcm8gdGhvc2UgYnl0ZXMgaW4gb3JkZXIgdG8gYXZvaWQgbWVtb3J5IGNoZWNrIHJlcG9ydHMgb2ZcbiAgICogdGhlIHVzZSBvZiB1bmluaXRpYWxpemVkIChvciB1bmluaXRpYWxpc2VkIGFzIEp1bGlhbiB3cml0ZXMpIGJ5dGVzIGJ5XG4gICAqIHRoZSBsb25nZXN0IG1hdGNoIHJvdXRpbmVzLiAgVXBkYXRlIHRoZSBoaWdoIHdhdGVyIG1hcmsgZm9yIHRoZSBuZXh0XG4gICAqIHRpbWUgdGhyb3VnaCBoZXJlLiAgV0lOX0lOSVQgaXMgc2V0IHRvIE1BWF9NQVRDSCBzaW5jZSB0aGUgbG9uZ2VzdCBtYXRjaFxuICAgKiByb3V0aW5lcyBhbGxvdyBzY2FubmluZyB0byBzdHJzdGFydCArIE1BWF9NQVRDSCwgaWdub3JpbmcgbG9va2FoZWFkLlxuICAgKi9cbi8vICBpZiAocy5oaWdoX3dhdGVyIDwgcy53aW5kb3dfc2l6ZSkge1xuLy8gICAgdmFyIGN1cnIgPSBzLnN0cnN0YXJ0ICsgcy5sb29rYWhlYWQ7XG4vLyAgICB2YXIgaW5pdCA9IDA7XG4vL1xuLy8gICAgaWYgKHMuaGlnaF93YXRlciA8IGN1cnIpIHtcbi8vICAgICAgLyogUHJldmlvdXMgaGlnaCB3YXRlciBtYXJrIGJlbG93IGN1cnJlbnQgZGF0YSAtLSB6ZXJvIFdJTl9JTklUXG4vLyAgICAgICAqIGJ5dGVzIG9yIHVwIHRvIGVuZCBvZiB3aW5kb3csIHdoaWNoZXZlciBpcyBsZXNzLlxuLy8gICAgICAgKi9cbi8vICAgICAgaW5pdCA9IHMud2luZG93X3NpemUgLSBjdXJyO1xuLy8gICAgICBpZiAoaW5pdCA+IFdJTl9JTklUKVxuLy8gICAgICAgIGluaXQgPSBXSU5fSU5JVDtcbi8vICAgICAgem1lbXplcm8ocy0+d2luZG93ICsgY3VyciwgKHVuc2lnbmVkKWluaXQpO1xuLy8gICAgICBzLT5oaWdoX3dhdGVyID0gY3VyciArIGluaXQ7XG4vLyAgICB9XG4vLyAgICBlbHNlIGlmIChzLT5oaWdoX3dhdGVyIDwgKHVsZyljdXJyICsgV0lOX0lOSVQpIHtcbi8vICAgICAgLyogSGlnaCB3YXRlciBtYXJrIGF0IG9yIGFib3ZlIGN1cnJlbnQgZGF0YSwgYnV0IGJlbG93IGN1cnJlbnQgZGF0YVxuLy8gICAgICAgKiBwbHVzIFdJTl9JTklUIC0tIHplcm8gb3V0IHRvIGN1cnJlbnQgZGF0YSBwbHVzIFdJTl9JTklULCBvciB1cFxuLy8gICAgICAgKiB0byBlbmQgb2Ygd2luZG93LCB3aGljaGV2ZXIgaXMgbGVzcy5cbi8vICAgICAgICovXG4vLyAgICAgIGluaXQgPSAodWxnKWN1cnIgKyBXSU5fSU5JVCAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIGlmIChpbml0ID4gcy0+d2luZG93X3NpemUgLSBzLT5oaWdoX3dhdGVyKVxuLy8gICAgICAgIGluaXQgPSBzLT53aW5kb3dfc2l6ZSAtIHMtPmhpZ2hfd2F0ZXI7XG4vLyAgICAgIHptZW16ZXJvKHMtPndpbmRvdyArIHMtPmhpZ2hfd2F0ZXIsICh1bnNpZ25lZClpbml0KTtcbi8vICAgICAgcy0+aGlnaF93YXRlciArPSBpbml0O1xuLy8gICAgfVxuLy8gIH1cbi8vXG4vLyAgQXNzZXJ0KCh1bGcpcy0+c3Ryc3RhcnQgPD0gcy0+d2luZG93X3NpemUgLSBNSU5fTE9PS0FIRUFELFxuLy8gICAgXCJub3QgZW5vdWdoIHJvb20gZm9yIHNlYXJjaFwiKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb3B5IHdpdGhvdXQgY29tcHJlc3Npb24gYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVyblxuICogdGhlIGN1cnJlbnQgYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgZGljdGlvbmFyeSBzaW5jZVxuICogdW5jb21wcmVzc2libGUgZGF0YSBpcyBwcm9iYWJseSBub3QgdXNlZnVsLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWRcbiAqIG9ubHkgZm9yIHRoZSBsZXZlbD0wIGNvbXByZXNzaW9uIG9wdGlvbi5cbiAqIE5PVEU6IHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIG9wdGltaXplZCB0byBhdm9pZCBleHRyYSBjb3B5aW5nIGZyb21cbiAqIHdpbmRvdyB0byBwZW5kaW5nX2J1Zi5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9zdG9yZWQocywgZmx1c2gpIHtcbiAgLyogU3RvcmVkIGJsb2NrcyBhcmUgbGltaXRlZCB0byAweGZmZmYgYnl0ZXMsIHBlbmRpbmdfYnVmIGlzIGxpbWl0ZWRcbiAgICogdG8gcGVuZGluZ19idWZfc2l6ZSwgYW5kIGVhY2ggc3RvcmVkIGJsb2NrIGhhcyBhIDUgYnl0ZSBoZWFkZXI6XG4gICAqL1xuICB2YXIgbWF4X2Jsb2NrX3NpemUgPSAweGZmZmY7XG5cbiAgaWYgKG1heF9ibG9ja19zaXplID4gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNSkge1xuICAgIG1heF9ibG9ja19zaXplID0gcy5wZW5kaW5nX2J1Zl9zaXplIC0gNTtcbiAgfVxuXG4gIC8qIENvcHkgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIGlucHV0IHRvIG91dHB1dDogKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIEZpbGwgdGhlIHdpbmRvdyBhcyBtdWNoIGFzIHBvc3NpYmxlOiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA8PSAxKSB7XG5cbiAgICAgIC8vQXNzZXJ0KHMtPnN0cnN0YXJ0IDwgcy0+d19zaXplK01BWF9ESVNUKHMpIHx8XG4gICAgICAvLyAgcy0+YmxvY2tfc3RhcnQgPj0gKGxvbmcpcy0+d19zaXplLCBcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICBpZiAoIShzLnN0cnN0YXJ0IDwgcy53X3NpemUgKyAocy53X3NpemUgLSBNSU5fTE9PS0FIRUFEKSB8fFxuLy8gICAgICAgIHMuYmxvY2tfc3RhcnQgPj0gcy53X3NpemUpKSB7XG4vLyAgICAgICAgdGhyb3cgIG5ldyBFcnJvcihcInNsaWRlIHRvbyBsYXRlXCIpO1xuLy8gICAgICB9XG5cbiAgICAgIGZpbGxfd2luZG93KHMpO1xuICAgICAgaWYgKHMubG9va2FoZWFkID09PSAwICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgfVxuICAgIC8vQXNzZXJ0KHMtPmJsb2NrX3N0YXJ0ID49IDBMLCBcImJsb2NrIGdvbmVcIik7XG4vLyAgICBpZiAocy5ibG9ja19zdGFydCA8IDApIHRocm93IG5ldyBFcnJvcihcImJsb2NrIGdvbmVcIik7XG5cbiAgICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICAgIHMubG9va2FoZWFkID0gMDtcblxuICAgIC8qIEVtaXQgYSBzdG9yZWQgYmxvY2sgaWYgcGVuZGluZ19idWYgd2lsbCBiZSBmdWxsOiAqL1xuICAgIHZhciBtYXhfc3RhcnQgPSBzLmJsb2NrX3N0YXJ0ICsgbWF4X2Jsb2NrX3NpemU7XG5cbiAgICBpZiAocy5zdHJzdGFydCA9PT0gMCB8fCBzLnN0cnN0YXJ0ID49IG1heF9zdGFydCkge1xuICAgICAgLyogc3Ryc3RhcnQgPT0gMCBpcyBwb3NzaWJsZSB3aGVuIHdyYXBhcm91bmQgb24gMTYtYml0IG1hY2hpbmUgKi9cbiAgICAgIHMubG9va2FoZWFkID0gcy5zdHJzdGFydCAtIG1heF9zdGFydDtcbiAgICAgIHMuc3Ryc3RhcnQgPSBtYXhfc3RhcnQ7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuXG5cbiAgICB9XG4gICAgLyogRmx1c2ggaWYgd2UgbWF5IGhhdmUgdG8gc2xpZGUsIG90aGVyd2lzZSBibG9ja19zdGFydCBtYXkgYmVjb21lXG4gICAgICogbmVnYXRpdmUgYW5kIHRoZSBkYXRhIHdpbGwgYmUgZ29uZTpcbiAgICAgKi9cbiAgICBpZiAocy5zdHJzdGFydCAtIHMuYmxvY2tfc3RhcnQgPj0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG5cbiAgcy5pbnNlcnQgPSAwO1xuXG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuXG4gIGlmIChzLnN0cnN0YXJ0ID4gcy5ibG9ja19zdGFydCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19ORUVEX01PUkU7XG59XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHJlc3MgYXMgbXVjaCBhcyBwb3NzaWJsZSBmcm9tIHRoZSBpbnB1dCBzdHJlYW0sIHJldHVybiB0aGUgY3VycmVudFxuICogYmxvY2sgc3RhdGUuXG4gKiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IHBlcmZvcm0gbGF6eSBldmFsdWF0aW9uIG9mIG1hdGNoZXMgYW5kIGluc2VydHNcbiAqIG5ldyBzdHJpbmdzIGluIHRoZSBkaWN0aW9uYXJ5IG9ubHkgZm9yIHVubWF0Y2hlZCBzdHJpbmdzIG9yIGZvciBzaG9ydFxuICogbWF0Y2hlcy4gSXQgaXMgdXNlZCBvbmx5IGZvciB0aGUgZmFzdCBjb21wcmVzc2lvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2Zhc3QocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgIC8qIGhlYWQgb2YgdGhlIGhhc2ggY2hhaW4gKi9cbiAgdmFyIGJmbHVzaDsgICAgICAgICAgIC8qIHNldCBpZiBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZCAqL1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbmV4dCBtYXRjaCwgcGx1cyBNSU5fTUFUQ0ggYnl0ZXMgdG8gaW5zZXJ0IHRoZVxuICAgICAqIHN0cmluZyBmb2xsb3dpbmcgdGhlIG5leHQgbWF0Y2guXG4gICAgICovXG4gICAgaWYgKHMubG9va2FoZWFkIDwgTUlOX0xPT0tBSEVBRCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEICYmIGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgYnJlYWs7IC8qIGZsdXNoIHRoZSBjdXJyZW50IGJsb2NrICovXG4gICAgICB9XG4gICAgfVxuXG4gICAgLyogSW5zZXJ0IHRoZSBzdHJpbmcgd2luZG93W3N0cnN0YXJ0IC4uIHN0cnN0YXJ0KzJdIGluIHRoZVxuICAgICAqIGRpY3Rpb25hcnksIGFuZCBzZXQgaGFzaF9oZWFkIHRvIHRoZSBoZWFkIG9mIHRoZSBoYXNoIGNoYWluOlxuICAgICAqL1xuICAgIGhhc2hfaGVhZCA9IDAvKk5JTCovO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzLnN0cnN0YXJ0ICsgTUlOX01BVENIIC0gMV0pICYgcy5oYXNoX21hc2s7XG4gICAgICBoYXNoX2hlYWQgPSBzLnByZXZbcy5zdHJzdGFydCAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcbiAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAvKioqL1xuICAgIH1cblxuICAgIC8qIEZpbmQgdGhlIGxvbmdlc3QgbWF0Y2gsIGRpc2NhcmRpbmcgdGhvc2UgPD0gcHJldl9sZW5ndGguXG4gICAgICogQXQgdGhpcyBwb2ludCB3ZSBoYXZlIGFsd2F5cyBtYXRjaF9sZW5ndGggPCBNSU5fTUFUQ0hcbiAgICAgKi9cbiAgICBpZiAoaGFzaF9oZWFkICE9PSAwLypOSUwqLyAmJiAoKHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQpIDw9IChzLndfc2l6ZSAtIE1JTl9MT09LQUhFQUQpKSkge1xuICAgICAgLyogVG8gc2ltcGxpZnkgdGhlIGNvZGUsIHdlIHByZXZlbnQgbWF0Y2hlcyB3aXRoIHRoZSBzdHJpbmdcbiAgICAgICAqIG9mIHdpbmRvdyBpbmRleCAwIChpbiBwYXJ0aWN1bGFyIHdlIGhhdmUgdG8gYXZvaWQgYSBtYXRjaFxuICAgICAgICogb2YgdGhlIHN0cmluZyB3aXRoIGl0c2VsZiBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0IGZpbGUpLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IGxvbmdlc3RfbWF0Y2gocywgaGFzaF9oZWFkKTtcbiAgICAgIC8qIGxvbmdlc3RfbWF0Y2goKSBzZXRzIG1hdGNoX3N0YXJ0ICovXG4gICAgfVxuICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+PSBNSU5fTUFUQ0gpIHtcbiAgICAgIC8vIGNoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQsIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoKTsgLy8gZm9yIGRlYnVnIG9ubHlcblxuICAgICAgLyoqKiBfdHJfdGFsbHlfZGlzdChzLCBzLnN0cnN0YXJ0IC0gcy5tYXRjaF9zdGFydCxcbiAgICAgICAgICAgICAgICAgICAgIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENIKTtcblxuICAgICAgcy5sb29rYWhlYWQgLT0gcy5tYXRjaF9sZW5ndGg7XG5cbiAgICAgIC8qIEluc2VydCBuZXcgc3RyaW5ncyBpbiB0aGUgaGFzaCB0YWJsZSBvbmx5IGlmIHRoZSBtYXRjaCBsZW5ndGhcbiAgICAgICAqIGlzIG5vdCB0b28gbGFyZ2UuIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAgICAgKi9cbiAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA8PSBzLm1heF9sYXp5X21hdGNoLyptYXhfaW5zZXJ0X2xlbmd0aCovICYmIHMubG9va2FoZWFkID49IE1JTl9NQVRDSCkge1xuICAgICAgICBzLm1hdGNoX2xlbmd0aC0tOyAvKiBzdHJpbmcgYXQgc3Ryc3RhcnQgYWxyZWFkeSBpbiB0YWJsZSAqL1xuICAgICAgICBkbyB7XG4gICAgICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgICAvKiBzdHJzdGFydCBuZXZlciBleGNlZWRzIFdTSVpFLU1BWF9NQVRDSCwgc28gdGhlcmUgYXJlXG4gICAgICAgICAgICogYWx3YXlzIE1JTl9NQVRDSCBieXRlcyBhaGVhZC5cbiAgICAgICAgICAgKi9cbiAgICAgICAgfSB3aGlsZSAoLS1zLm1hdGNoX2xlbmd0aCAhPT0gMCk7XG4gICAgICAgIHMuc3Ryc3RhcnQrKztcbiAgICAgIH0gZWxzZVxuICAgICAge1xuICAgICAgICBzLnN0cnN0YXJ0ICs9IHMubWF0Y2hfbGVuZ3RoO1xuICAgICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgICAgIHMuaW5zX2ggPSBzLndpbmRvd1tzLnN0cnN0YXJ0XTtcbiAgICAgICAgLyogVVBEQVRFX0hBU0gocywgcy5pbnNfaCwgcy53aW5kb3dbcy5zdHJzdGFydCsxXSk7ICovXG4gICAgICAgIHMuaW5zX2ggPSAoKHMuaW5zX2ggPDwgcy5oYXNoX3NoaWZ0KSBeIHMud2luZG93W3Muc3Ryc3RhcnQgKyAxXSkgJiBzLmhhc2hfbWFzaztcblxuLy8jaWYgTUlOX01BVENIICE9IDNcbi8vICAgICAgICAgICAgICAgIENhbGwgVVBEQVRFX0hBU0goKSBNSU5fTUFUQ0gtMyBtb3JlIHRpbWVzXG4vLyNlbmRpZlxuICAgICAgICAvKiBJZiBsb29rYWhlYWQgPCBNSU5fTUFUQ0gsIGluc19oIGlzIGdhcmJhZ2UsIGJ1dCBpdCBkb2VzIG5vdFxuICAgICAgICAgKiBtYXR0ZXIgc2luY2UgaXQgd2lsbCBiZSByZWNvbXB1dGVkIGF0IG5leHQgZGVmbGF0ZSBjYWxsLlxuICAgICAgICAgKi9cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLyogTm8gbWF0Y2gsIG91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsXCIlY1wiLCBzLndpbmRvd1tzLnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9ICgocy5zdHJzdGFydCA8IChNSU5fTUFUQ0ggLSAxKSkgPyBzLnN0cnN0YXJ0IDogTUlOX01BVENIIC0gMSk7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYW1lIGFzIGFib3ZlLCBidXQgYWNoaWV2ZXMgYmV0dGVyIGNvbXByZXNzaW9uLiBXZSB1c2UgYSBsYXp5XG4gKiBldmFsdWF0aW9uIGZvciBtYXRjaGVzOiBhIG1hdGNoIGlzIGZpbmFsbHkgYWRvcHRlZCBvbmx5IGlmIHRoZXJlIGlzXG4gKiBubyBiZXR0ZXIgbWF0Y2ggYXQgdGhlIG5leHQgd2luZG93IHBvc2l0aW9uLlxuICovXG5mdW5jdGlvbiBkZWZsYXRlX3Nsb3cocywgZmx1c2gpIHtcbiAgdmFyIGhhc2hfaGVhZDsgICAgICAgICAgLyogaGVhZCBvZiBoYXNoIGNoYWluICovXG4gIHZhciBiZmx1c2g7ICAgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cblxuICB2YXIgbWF4X2luc2VydDtcblxuICAvKiBQcm9jZXNzIHRoZSBpbnB1dCBibG9jay4gKi9cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGFsd2F5cyBoYXZlIGVub3VnaCBsb29rYWhlYWQsIGV4Y2VwdFxuICAgICAqIGF0IHRoZSBlbmQgb2YgdGhlIGlucHV0IGZpbGUuIFdlIG5lZWQgTUFYX01BVENIIGJ5dGVzXG4gICAgICogZm9yIHRoZSBuZXh0IG1hdGNoLCBwbHVzIE1JTl9NQVRDSCBieXRlcyB0byBpbnNlcnQgdGhlXG4gICAgICogc3RyaW5nIGZvbGxvd2luZyB0aGUgbmV4dCBtYXRjaC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPCBNSU5fTE9PS0FIRUFEKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8IE1JTl9MT09LQUhFQUQgJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIEluc2VydCB0aGUgc3RyaW5nIHdpbmRvd1tzdHJzdGFydCAuLiBzdHJzdGFydCsyXSBpbiB0aGVcbiAgICAgKiBkaWN0aW9uYXJ5LCBhbmQgc2V0IGhhc2hfaGVhZCB0byB0aGUgaGVhZCBvZiB0aGUgaGFzaCBjaGFpbjpcbiAgICAgKi9cbiAgICBoYXNoX2hlYWQgPSAwLypOSUwqLztcbiAgICBpZiAocy5sb29rYWhlYWQgPj0gTUlOX01BVENIKSB7XG4gICAgICAvKioqIElOU0VSVF9TVFJJTkcocywgcy5zdHJzdGFydCwgaGFzaF9oZWFkKTsgKioqL1xuICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgaGFzaF9oZWFkID0gcy5wcmV2W3Muc3Ryc3RhcnQgJiBzLndfbWFza10gPSBzLmhlYWRbcy5pbnNfaF07XG4gICAgICBzLmhlYWRbcy5pbnNfaF0gPSBzLnN0cnN0YXJ0O1xuICAgICAgLyoqKi9cbiAgICB9XG5cbiAgICAvKiBGaW5kIHRoZSBsb25nZXN0IG1hdGNoLCBkaXNjYXJkaW5nIHRob3NlIDw9IHByZXZfbGVuZ3RoLlxuICAgICAqL1xuICAgIHMucHJldl9sZW5ndGggPSBzLm1hdGNoX2xlbmd0aDtcbiAgICBzLnByZXZfbWF0Y2ggPSBzLm1hdGNoX3N0YXJ0O1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcblxuICAgIGlmIChoYXNoX2hlYWQgIT09IDAvKk5JTCovICYmIHMucHJldl9sZW5ndGggPCBzLm1heF9sYXp5X21hdGNoICYmXG4gICAgICAgIHMuc3Ryc3RhcnQgLSBoYXNoX2hlYWQgPD0gKHMud19zaXplIC0gTUlOX0xPT0tBSEVBRCkvKk1BWF9ESVNUKHMpKi8pIHtcbiAgICAgIC8qIFRvIHNpbXBsaWZ5IHRoZSBjb2RlLCB3ZSBwcmV2ZW50IG1hdGNoZXMgd2l0aCB0aGUgc3RyaW5nXG4gICAgICAgKiBvZiB3aW5kb3cgaW5kZXggMCAoaW4gcGFydGljdWxhciB3ZSBoYXZlIHRvIGF2b2lkIGEgbWF0Y2hcbiAgICAgICAqIG9mIHRoZSBzdHJpbmcgd2l0aCBpdHNlbGYgYXQgdGhlIHN0YXJ0IG9mIHRoZSBpbnB1dCBmaWxlKS5cbiAgICAgICAqL1xuICAgICAgcy5tYXRjaF9sZW5ndGggPSBsb25nZXN0X21hdGNoKHMsIGhhc2hfaGVhZCk7XG4gICAgICAvKiBsb25nZXN0X21hdGNoKCkgc2V0cyBtYXRjaF9zdGFydCAqL1xuXG4gICAgICBpZiAocy5tYXRjaF9sZW5ndGggPD0gNSAmJlxuICAgICAgICAgKHMuc3RyYXRlZ3kgPT09IFpfRklMVEVSRUQgfHwgKHMubWF0Y2hfbGVuZ3RoID09PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCAtIHMubWF0Y2hfc3RhcnQgPiA0MDk2LypUT09fRkFSKi8pKSkge1xuXG4gICAgICAgIC8qIElmIHByZXZfbWF0Y2ggaXMgYWxzbyBNSU5fTUFUQ0gsIG1hdGNoX3N0YXJ0IGlzIGdhcmJhZ2VcbiAgICAgICAgICogYnV0IHdlIHdpbGwgaWdub3JlIHRoZSBjdXJyZW50IG1hdGNoIGFueXdheS5cbiAgICAgICAgICovXG4gICAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyogSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYXQgdGhlIHByZXZpb3VzIHN0ZXAgYW5kIHRoZSBjdXJyZW50XG4gICAgICogbWF0Y2ggaXMgbm90IGJldHRlciwgb3V0cHV0IHRoZSBwcmV2aW91cyBtYXRjaDpcbiAgICAgKi9cbiAgICBpZiAocy5wcmV2X2xlbmd0aCA+PSBNSU5fTUFUQ0ggJiYgcy5tYXRjaF9sZW5ndGggPD0gcy5wcmV2X2xlbmd0aCkge1xuICAgICAgbWF4X2luc2VydCA9IHMuc3Ryc3RhcnQgKyBzLmxvb2thaGVhZCAtIE1JTl9NQVRDSDtcbiAgICAgIC8qIERvIG5vdCBpbnNlcnQgc3RyaW5ncyBpbiBoYXNoIHRhYmxlIGJleW9uZCB0aGlzLiAqL1xuXG4gICAgICAvL2NoZWNrX21hdGNoKHMsIHMuc3Ryc3RhcnQtMSwgcy5wcmV2X21hdGNoLCBzLnByZXZfbGVuZ3RoKTtcblxuICAgICAgLyoqKl90cl90YWxseV9kaXN0KHMsIHMuc3Ryc3RhcnQgLSAxIC0gcy5wcmV2X21hdGNoLFxuICAgICAgICAgICAgICAgICAgICAgcy5wcmV2X2xlbmd0aCAtIE1JTl9NQVRDSCwgYmZsdXNoKTsqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgcy5zdHJzdGFydCAtIDEgLSBzLnByZXZfbWF0Y2gsIHMucHJldl9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuICAgICAgLyogSW5zZXJ0IGluIGhhc2ggdGFibGUgYWxsIHN0cmluZ3MgdXAgdG8gdGhlIGVuZCBvZiB0aGUgbWF0Y2guXG4gICAgICAgKiBzdHJzdGFydC0xIGFuZCBzdHJzdGFydCBhcmUgYWxyZWFkeSBpbnNlcnRlZC4gSWYgdGhlcmUgaXMgbm90XG4gICAgICAgKiBlbm91Z2ggbG9va2FoZWFkLCB0aGUgbGFzdCB0d28gc3RyaW5ncyBhcmUgbm90IGluc2VydGVkIGluXG4gICAgICAgKiB0aGUgaGFzaCB0YWJsZS5cbiAgICAgICAqL1xuICAgICAgcy5sb29rYWhlYWQgLT0gcy5wcmV2X2xlbmd0aCAtIDE7XG4gICAgICBzLnByZXZfbGVuZ3RoIC09IDI7XG4gICAgICBkbyB7XG4gICAgICAgIGlmICgrK3Muc3Ryc3RhcnQgPD0gbWF4X2luc2VydCkge1xuICAgICAgICAgIC8qKiogSU5TRVJUX1NUUklORyhzLCBzLnN0cnN0YXJ0LCBoYXNoX2hlYWQpOyAqKiovXG4gICAgICAgICAgcy5pbnNfaCA9ICgocy5pbnNfaCA8PCBzLmhhc2hfc2hpZnQpIF4gcy53aW5kb3dbcy5zdHJzdGFydCArIE1JTl9NQVRDSCAtIDFdKSAmIHMuaGFzaF9tYXNrO1xuICAgICAgICAgIGhhc2hfaGVhZCA9IHMucHJldltzLnN0cnN0YXJ0ICYgcy53X21hc2tdID0gcy5oZWFkW3MuaW5zX2hdO1xuICAgICAgICAgIHMuaGVhZFtzLmluc19oXSA9IHMuc3Ryc3RhcnQ7XG4gICAgICAgICAgLyoqKi9cbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAoLS1zLnByZXZfbGVuZ3RoICE9PSAwKTtcbiAgICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgICAgIHMubWF0Y2hfbGVuZ3RoID0gTUlOX01BVENIIC0gMTtcbiAgICAgIHMuc3Ryc3RhcnQrKztcblxuICAgICAgaWYgKGJmbHVzaCkge1xuICAgICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKi9cbiAgICAgIH1cblxuICAgIH0gZWxzZSBpZiAocy5tYXRjaF9hdmFpbGFibGUpIHtcbiAgICAgIC8qIElmIHRoZXJlIHdhcyBubyBtYXRjaCBhdCB0aGUgcHJldmlvdXMgcG9zaXRpb24sIG91dHB1dCBhXG4gICAgICAgKiBzaW5nbGUgbGl0ZXJhbC4gSWYgdGhlcmUgd2FzIGEgbWF0Y2ggYnV0IHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgKiBpcyBsb25nZXIsIHRydW5jYXRlIHRoZSBwcmV2aW91cyBtYXRjaCB0byBhIHNpbmdsZSBsaXRlcmFsLlxuICAgICAgICovXG4gICAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydC0xXSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICAgIGJmbHVzaCA9IHRyZWVzLl90cl90YWxseShzLCAwLCBzLndpbmRvd1tzLnN0cnN0YXJ0IC0gMV0pO1xuXG4gICAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAgIC8qKiogRkxVU0hfQkxPQ0tfT05MWShzLCAwKSAqKiovXG4gICAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgICAvKioqL1xuICAgICAgfVxuICAgICAgcy5zdHJzdGFydCsrO1xuICAgICAgcy5sb29rYWhlYWQtLTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIFRoZXJlIGlzIG5vIHByZXZpb3VzIG1hdGNoIHRvIGNvbXBhcmUgd2l0aCwgd2FpdCBmb3JcbiAgICAgICAqIHRoZSBuZXh0IHN0ZXAgdG8gZGVjaWRlLlxuICAgICAgICovXG4gICAgICBzLm1hdGNoX2F2YWlsYWJsZSA9IDE7XG4gICAgICBzLnN0cnN0YXJ0Kys7XG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgIH1cbiAgfVxuICAvL0Fzc2VydCAoZmx1c2ggIT0gWl9OT19GTFVTSCwgXCJubyBmbHVzaD9cIik7XG4gIGlmIChzLm1hdGNoX2F2YWlsYWJsZSkge1xuICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0LTFdKSk7XG4gICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnQtMV0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydCAtIDFdKTtcblxuICAgIHMubWF0Y2hfYXZhaWxhYmxlID0gMDtcbiAgfVxuICBzLmluc2VydCA9IHMuc3Ryc3RhcnQgPCBNSU5fTUFUQ0ggLSAxID8gcy5zdHJzdGFydCA6IE1JTl9NQVRDSCAtIDE7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuXG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogRm9yIFpfUkxFLCBzaW1wbHkgbG9vayBmb3IgcnVucyBvZiBieXRlcywgZ2VuZXJhdGUgbWF0Y2hlcyBvbmx5IG9mIGRpc3RhbmNlXG4gKiBvbmUuICBEbyBub3QgbWFpbnRhaW4gYSBoYXNoIHRhYmxlLiAgKEl0IHdpbGwgYmUgcmVnZW5lcmF0ZWQgaWYgdGhpcyBydW4gb2ZcbiAqIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIFpfUkxFLilcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZV9ybGUocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAvKiBzZXQgaWYgY3VycmVudCBibG9jayBtdXN0IGJlIGZsdXNoZWQgKi9cbiAgdmFyIHByZXY7ICAgICAgICAgICAgICAvKiBieXRlIGF0IGRpc3RhbmNlIG9uZSB0byBtYXRjaCAqL1xuICB2YXIgc2Nhbiwgc3RyZW5kOyAgICAgIC8qIHNjYW4gZ29lcyB1cCB0byBzdHJlbmQgZm9yIGxlbmd0aCBvZiBydW4gKi9cblxuICB2YXIgX3dpbiA9IHMud2luZG93O1xuXG4gIGZvciAoOzspIHtcbiAgICAvKiBNYWtlIHN1cmUgdGhhdCB3ZSBhbHdheXMgaGF2ZSBlbm91Z2ggbG9va2FoZWFkLCBleGNlcHRcbiAgICAgKiBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dCBmaWxlLiBXZSBuZWVkIE1BWF9NQVRDSCBieXRlc1xuICAgICAqIGZvciB0aGUgbG9uZ2VzdCBydW4sIHBsdXMgb25lIGZvciB0aGUgdW5yb2xsZWQgbG9vcC5cbiAgICAgKi9cbiAgICBpZiAocy5sb29rYWhlYWQgPD0gTUFYX01BVENIKSB7XG4gICAgICBmaWxsX3dpbmRvdyhzKTtcbiAgICAgIGlmIChzLmxvb2thaGVhZCA8PSBNQVhfTUFUQ0ggJiYgZmx1c2ggPT09IFpfTk9fRkxVU0gpIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkgeyBicmVhazsgfSAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgIH1cblxuICAgIC8qIFNlZSBob3cgbWFueSB0aW1lcyB0aGUgcHJldmlvdXMgYnl0ZSByZXBlYXRzICovXG4gICAgcy5tYXRjaF9sZW5ndGggPSAwO1xuICAgIGlmIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0ggJiYgcy5zdHJzdGFydCA+IDApIHtcbiAgICAgIHNjYW4gPSBzLnN0cnN0YXJ0IC0gMTtcbiAgICAgIHByZXYgPSBfd2luW3NjYW5dO1xuICAgICAgaWYgKHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dKSB7XG4gICAgICAgIHN0cmVuZCA9IHMuc3Ryc3RhcnQgKyBNQVhfTUFUQ0g7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAvKmpzaGludCBub2VtcHR5OmZhbHNlKi9cbiAgICAgICAgfSB3aGlsZSAocHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiYgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmXG4gICAgICAgICAgICAgICAgIHByZXYgPT09IF93aW5bKytzY2FuXSAmJiBwcmV2ID09PSBfd2luWysrc2Nhbl0gJiZcbiAgICAgICAgICAgICAgICAgcHJldiA9PT0gX3dpblsrK3NjYW5dICYmIHByZXYgPT09IF93aW5bKytzY2FuXSAmJlxuICAgICAgICAgICAgICAgICBzY2FuIDwgc3RyZW5kKTtcbiAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBNQVhfTUFUQ0ggLSAoc3RyZW5kIC0gc2Nhbik7XG4gICAgICAgIGlmIChzLm1hdGNoX2xlbmd0aCA+IHMubG9va2FoZWFkKSB7XG4gICAgICAgICAgcy5tYXRjaF9sZW5ndGggPSBzLmxvb2thaGVhZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoc2NhbiA8PSBzLT53aW5kb3crKHVJbnQpKHMtPndpbmRvd19zaXplLTEpLCBcIndpbGQgc2NhblwiKTtcbiAgICB9XG5cbiAgICAvKiBFbWl0IG1hdGNoIGlmIGhhdmUgcnVuIG9mIE1JTl9NQVRDSCBvciBsb25nZXIsIGVsc2UgZW1pdCBsaXRlcmFsICovXG4gICAgaWYgKHMubWF0Y2hfbGVuZ3RoID49IE1JTl9NQVRDSCkge1xuICAgICAgLy9jaGVja19tYXRjaChzLCBzLnN0cnN0YXJ0LCBzLnN0cnN0YXJ0IC0gMSwgcy5tYXRjaF9sZW5ndGgpO1xuXG4gICAgICAvKioqIF90cl90YWxseV9kaXN0KHMsIDEsIHMubWF0Y2hfbGVuZ3RoIC0gTUlOX01BVENILCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMSwgcy5tYXRjaF9sZW5ndGggLSBNSU5fTUFUQ0gpO1xuXG4gICAgICBzLmxvb2thaGVhZCAtPSBzLm1hdGNoX2xlbmd0aDtcbiAgICAgIHMuc3Ryc3RhcnQgKz0gcy5tYXRjaF9sZW5ndGg7XG4gICAgICBzLm1hdGNoX2xlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8qIE5vIG1hdGNoLCBvdXRwdXQgYSBsaXRlcmFsIGJ5dGUgKi9cbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLFwiJWNcIiwgcy0+d2luZG93W3MtPnN0cnN0YXJ0XSkpO1xuICAgICAgLyoqKiBfdHJfdGFsbHlfbGl0KHMsIHMud2luZG93W3Muc3Ryc3RhcnRdLCBiZmx1c2gpOyAqKiovXG4gICAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuXG4gICAgICBzLmxvb2thaGVhZC0tO1xuICAgICAgcy5zdHJzdGFydCsrO1xuICAgIH1cbiAgICBpZiAoYmZsdXNoKSB7XG4gICAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDApOyAqKiovXG4gICAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBCU19ORUVEX01PUkU7XG4gICAgICB9XG4gICAgICAvKioqL1xuICAgIH1cbiAgfVxuICBzLmluc2VydCA9IDA7XG4gIGlmIChmbHVzaCA9PT0gWl9GSU5JU0gpIHtcbiAgICAvKioqIEZMVVNIX0JMT0NLKHMsIDEpOyAqKiovXG4gICAgZmx1c2hfYmxvY2tfb25seShzLCB0cnVlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX0ZJTklTSF9TVEFSVEVEO1xuICAgIH1cbiAgICAvKioqL1xuICAgIHJldHVybiBCU19GSU5JU0hfRE9ORTtcbiAgfVxuICBpZiAocy5sYXN0X2xpdCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIGZhbHNlKTtcbiAgICBpZiAocy5zdHJtLmF2YWlsX291dCA9PT0gMCkge1xuICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICB9XG4gICAgLyoqKi9cbiAgfVxuICByZXR1cm4gQlNfQkxPQ0tfRE9ORTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGb3IgWl9IVUZGTUFOX09OTFksIGRvIG5vdCBsb29rIGZvciBtYXRjaGVzLiAgRG8gbm90IG1haW50YWluIGEgaGFzaCB0YWJsZS5cbiAqIChJdCB3aWxsIGJlIHJlZ2VuZXJhdGVkIGlmIHRoaXMgcnVuIG9mIGRlZmxhdGUgc3dpdGNoZXMgYXdheSBmcm9tIEh1ZmZtYW4uKVxuICovXG5mdW5jdGlvbiBkZWZsYXRlX2h1ZmYocywgZmx1c2gpIHtcbiAgdmFyIGJmbHVzaDsgICAgICAgICAgICAgLyogc2V0IGlmIGN1cnJlbnQgYmxvY2sgbXVzdCBiZSBmbHVzaGVkICovXG5cbiAgZm9yICg7Oykge1xuICAgIC8qIE1ha2Ugc3VyZSB0aGF0IHdlIGhhdmUgYSBsaXRlcmFsIHRvIHdyaXRlLiAqL1xuICAgIGlmIChzLmxvb2thaGVhZCA9PT0gMCkge1xuICAgICAgZmlsbF93aW5kb3cocyk7XG4gICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX05PX0ZMVVNIKSB7XG4gICAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgICAgfVxuICAgICAgICBicmVhazsgICAgICAvKiBmbHVzaCB0aGUgY3VycmVudCBibG9jayAqL1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qIE91dHB1dCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgIHMubWF0Y2hfbGVuZ3RoID0gMDtcbiAgICAvL1RyYWNldnYoKHN0ZGVycixcIiVjXCIsIHMtPndpbmRvd1tzLT5zdHJzdGFydF0pKTtcbiAgICAvKioqIF90cl90YWxseV9saXQocywgcy53aW5kb3dbcy5zdHJzdGFydF0sIGJmbHVzaCk7ICoqKi9cbiAgICBiZmx1c2ggPSB0cmVlcy5fdHJfdGFsbHkocywgMCwgcy53aW5kb3dbcy5zdHJzdGFydF0pO1xuICAgIHMubG9va2FoZWFkLS07XG4gICAgcy5zdHJzdGFydCsrO1xuICAgIGlmIChiZmx1c2gpIHtcbiAgICAgIC8qKiogRkxVU0hfQkxPQ0socywgMCk7ICoqKi9cbiAgICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgICAgaWYgKHMuc3RybS5hdmFpbF9vdXQgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIEJTX05FRURfTU9SRTtcbiAgICAgIH1cbiAgICAgIC8qKiovXG4gICAgfVxuICB9XG4gIHMuaW5zZXJ0ID0gMDtcbiAgaWYgKGZsdXNoID09PSBaX0ZJTklTSCkge1xuICAgIC8qKiogRkxVU0hfQkxPQ0socywgMSk7ICoqKi9cbiAgICBmbHVzaF9ibG9ja19vbmx5KHMsIHRydWUpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfRklOSVNIX1NUQVJURUQ7XG4gICAgfVxuICAgIC8qKiovXG4gICAgcmV0dXJuIEJTX0ZJTklTSF9ET05FO1xuICB9XG4gIGlmIChzLmxhc3RfbGl0KSB7XG4gICAgLyoqKiBGTFVTSF9CTE9DSyhzLCAwKTsgKioqL1xuICAgIGZsdXNoX2Jsb2NrX29ubHkocywgZmFsc2UpO1xuICAgIGlmIChzLnN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICByZXR1cm4gQlNfTkVFRF9NT1JFO1xuICAgIH1cbiAgICAvKioqL1xuICB9XG4gIHJldHVybiBCU19CTE9DS19ET05FO1xufVxuXG4vKiBWYWx1ZXMgZm9yIG1heF9sYXp5X21hdGNoLCBnb29kX21hdGNoIGFuZCBtYXhfY2hhaW5fbGVuZ3RoLCBkZXBlbmRpbmcgb25cbiAqIHRoZSBkZXNpcmVkIHBhY2sgbGV2ZWwgKDAuLjkpLiBUaGUgdmFsdWVzIGdpdmVuIGJlbG93IGhhdmUgYmVlbiB0dW5lZCB0b1xuICogZXhjbHVkZSB3b3JzdCBjYXNlIHBlcmZvcm1hbmNlIGZvciBwYXRob2xvZ2ljYWwgZmlsZXMuIEJldHRlciB2YWx1ZXMgbWF5IGJlXG4gKiBmb3VuZCBmb3Igc3BlY2lmaWMgZmlsZXMuXG4gKi9cbmZ1bmN0aW9uIENvbmZpZyhnb29kX2xlbmd0aCwgbWF4X2xhenksIG5pY2VfbGVuZ3RoLCBtYXhfY2hhaW4sIGZ1bmMpIHtcbiAgdGhpcy5nb29kX2xlbmd0aCA9IGdvb2RfbGVuZ3RoO1xuICB0aGlzLm1heF9sYXp5ID0gbWF4X2xhenk7XG4gIHRoaXMubmljZV9sZW5ndGggPSBuaWNlX2xlbmd0aDtcbiAgdGhpcy5tYXhfY2hhaW4gPSBtYXhfY2hhaW47XG4gIHRoaXMuZnVuYyA9IGZ1bmM7XG59XG5cbnZhciBjb25maWd1cmF0aW9uX3RhYmxlO1xuXG5jb25maWd1cmF0aW9uX3RhYmxlID0gW1xuICAvKiAgICAgIGdvb2QgbGF6eSBuaWNlIGNoYWluICovXG4gIG5ldyBDb25maWcoMCwgMCwgMCwgMCwgZGVmbGF0ZV9zdG9yZWQpLCAgICAgICAgICAvKiAwIHN0b3JlIG9ubHkgKi9cbiAgbmV3IENvbmZpZyg0LCA0LCA4LCA0LCBkZWZsYXRlX2Zhc3QpLCAgICAgICAgICAgIC8qIDEgbWF4IHNwZWVkLCBubyBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg0LCA1LCAxNiwgOCwgZGVmbGF0ZV9mYXN0KSwgICAgICAgICAgIC8qIDIgKi9cbiAgbmV3IENvbmZpZyg0LCA2LCAzMiwgMzIsIGRlZmxhdGVfZmFzdCksICAgICAgICAgIC8qIDMgKi9cblxuICBuZXcgQ29uZmlnKDQsIDQsIDE2LCAxNiwgZGVmbGF0ZV9zbG93KSwgICAgICAgICAgLyogNCBsYXp5IG1hdGNoZXMgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMzIsIDMyLCBkZWZsYXRlX3Nsb3cpLCAgICAgICAgIC8qIDUgKi9cbiAgbmV3IENvbmZpZyg4LCAxNiwgMTI4LCAxMjgsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDYgKi9cbiAgbmV3IENvbmZpZyg4LCAzMiwgMTI4LCAyNTYsIGRlZmxhdGVfc2xvdyksICAgICAgIC8qIDcgKi9cbiAgbmV3IENvbmZpZygzMiwgMTI4LCAyNTgsIDEwMjQsIGRlZmxhdGVfc2xvdyksICAgIC8qIDggKi9cbiAgbmV3IENvbmZpZygzMiwgMjU4LCAyNTgsIDQwOTYsIGRlZmxhdGVfc2xvdykgICAgIC8qIDkgbWF4IGNvbXByZXNzaW9uICovXG5dO1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogSW5pdGlhbGl6ZSB0aGUgXCJsb25nZXN0IG1hdGNoXCIgcm91dGluZXMgZm9yIGEgbmV3IHpsaWIgc3RyZWFtXG4gKi9cbmZ1bmN0aW9uIGxtX2luaXQocykge1xuICBzLndpbmRvd19zaXplID0gMiAqIHMud19zaXplO1xuXG4gIC8qKiogQ0xFQVJfSEFTSChzKTsgKioqL1xuICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgLyogU2V0IHRoZSBkZWZhdWx0IGNvbmZpZ3VyYXRpb24gcGFyYW1ldGVyczpcbiAgICovXG4gIHMubWF4X2xhenlfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9sYXp5O1xuICBzLmdvb2RfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmdvb2RfbGVuZ3RoO1xuICBzLm5pY2VfbWF0Y2ggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm5pY2VfbGVuZ3RoO1xuICBzLm1heF9jaGFpbl9sZW5ndGggPSBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLm1heF9jaGFpbjtcblxuICBzLnN0cnN0YXJ0ID0gMDtcbiAgcy5ibG9ja19zdGFydCA9IDA7XG4gIHMubG9va2FoZWFkID0gMDtcbiAgcy5pbnNlcnQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHMuaW5zX2ggPSAwO1xufVxuXG5cbmZ1bmN0aW9uIERlZmxhdGVTdGF0ZSgpIHtcbiAgdGhpcy5zdHJtID0gbnVsbDsgICAgICAgICAgICAvKiBwb2ludGVyIGJhY2sgdG8gdGhpcyB6bGliIHN0cmVhbSAqL1xuICB0aGlzLnN0YXR1cyA9IDA7ICAgICAgICAgICAgLyogYXMgdGhlIG5hbWUgaW1wbGllcyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmID0gbnVsbDsgICAgICAvKiBvdXRwdXQgc3RpbGwgcGVuZGluZyAqL1xuICB0aGlzLnBlbmRpbmdfYnVmX3NpemUgPSAwOyAgLyogc2l6ZSBvZiBwZW5kaW5nX2J1ZiAqL1xuICB0aGlzLnBlbmRpbmdfb3V0ID0gMDsgICAgICAgLyogbmV4dCBwZW5kaW5nIGJ5dGUgdG8gb3V0cHV0IHRvIHRoZSBzdHJlYW0gKi9cbiAgdGhpcy5wZW5kaW5nID0gMDsgICAgICAgICAgIC8qIG5iIG9mIGJ5dGVzIGluIHRoZSBwZW5kaW5nIGJ1ZmZlciAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmd6aGVhZCA9IG51bGw7ICAgICAgICAgLyogZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gdG8gd3JpdGUgKi9cbiAgdGhpcy5nemluZGV4ID0gMDsgICAgICAgICAgIC8qIHdoZXJlIGluIGV4dHJhLCBuYW1lLCBvciBjb21tZW50ICovXG4gIHRoaXMubWV0aG9kID0gWl9ERUZMQVRFRDsgLyogY2FuIG9ubHkgYmUgREVGTEFURUQgKi9cbiAgdGhpcy5sYXN0X2ZsdXNoID0gLTE7ICAgLyogdmFsdWUgb2YgZmx1c2ggcGFyYW0gZm9yIHByZXZpb3VzIGRlZmxhdGUgY2FsbCAqL1xuXG4gIHRoaXMud19zaXplID0gMDsgIC8qIExaNzcgd2luZG93IHNpemUgKDMySyBieSBkZWZhdWx0KSAqL1xuICB0aGlzLndfYml0cyA9IDA7ICAvKiBsb2cyKHdfc2l6ZSkgICg4Li4xNikgKi9cbiAgdGhpcy53X21hc2sgPSAwOyAgLyogd19zaXplIC0gMSAqL1xuXG4gIHRoaXMud2luZG93ID0gbnVsbDtcbiAgLyogU2xpZGluZyB3aW5kb3cuIElucHV0IGJ5dGVzIGFyZSByZWFkIGludG8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSB3aW5kb3csXG4gICAqIGFuZCBtb3ZlIHRvIHRoZSBmaXJzdCBoYWxmIGxhdGVyIHRvIGtlZXAgYSBkaWN0aW9uYXJ5IG9mIGF0IGxlYXN0IHdTaXplXG4gICAqIGJ5dGVzLiBXaXRoIHRoaXMgb3JnYW5pemF0aW9uLCBtYXRjaGVzIGFyZSBsaW1pdGVkIHRvIGEgZGlzdGFuY2Ugb2ZcbiAgICogd1NpemUtTUFYX01BVENIIGJ5dGVzLCBidXQgdGhpcyBlbnN1cmVzIHRoYXQgSU8gaXMgYWx3YXlzXG4gICAqIHBlcmZvcm1lZCB3aXRoIGEgbGVuZ3RoIG11bHRpcGxlIG9mIHRoZSBibG9jayBzaXplLlxuICAgKi9cblxuICB0aGlzLndpbmRvd19zaXplID0gMDtcbiAgLyogQWN0dWFsIHNpemUgb2Ygd2luZG93OiAyKndTaXplLCBleGNlcHQgd2hlbiB0aGUgdXNlciBpbnB1dCBidWZmZXJcbiAgICogaXMgZGlyZWN0bHkgdXNlZCBhcyBzbGlkaW5nIHdpbmRvdy5cbiAgICovXG5cbiAgdGhpcy5wcmV2ID0gbnVsbDtcbiAgLyogTGluayB0byBvbGRlciBzdHJpbmcgd2l0aCBzYW1lIGhhc2ggaW5kZXguIFRvIGxpbWl0IHRoZSBzaXplIG9mIHRoaXNcbiAgICogYXJyYXkgdG8gNjRLLCB0aGlzIGxpbmsgaXMgbWFpbnRhaW5lZCBvbmx5IGZvciB0aGUgbGFzdCAzMksgc3RyaW5ncy5cbiAgICogQW4gaW5kZXggaW4gdGhpcyBhcnJheSBpcyB0aHVzIGEgd2luZG93IGluZGV4IG1vZHVsbyAzMksuXG4gICAqL1xuXG4gIHRoaXMuaGVhZCA9IG51bGw7ICAgLyogSGVhZHMgb2YgdGhlIGhhc2ggY2hhaW5zIG9yIE5JTC4gKi9cblxuICB0aGlzLmluc19oID0gMDsgICAgICAgLyogaGFzaCBpbmRleCBvZiBzdHJpbmcgdG8gYmUgaW5zZXJ0ZWQgKi9cbiAgdGhpcy5oYXNoX3NpemUgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiBoYXNoIHRhYmxlICovXG4gIHRoaXMuaGFzaF9iaXRzID0gMDsgICAvKiBsb2cyKGhhc2hfc2l6ZSkgKi9cbiAgdGhpcy5oYXNoX21hc2sgPSAwOyAgIC8qIGhhc2hfc2l6ZS0xICovXG5cbiAgdGhpcy5oYXNoX3NoaWZ0ID0gMDtcbiAgLyogTnVtYmVyIG9mIGJpdHMgYnkgd2hpY2ggaW5zX2ggbXVzdCBiZSBzaGlmdGVkIGF0IGVhY2ggaW5wdXRcbiAgICogc3RlcC4gSXQgbXVzdCBiZSBzdWNoIHRoYXQgYWZ0ZXIgTUlOX01BVENIIHN0ZXBzLCB0aGUgb2xkZXN0XG4gICAqIGJ5dGUgbm8gbG9uZ2VyIHRha2VzIHBhcnQgaW4gdGhlIGhhc2gga2V5LCB0aGF0IGlzOlxuICAgKiAgIGhhc2hfc2hpZnQgKiBNSU5fTUFUQ0ggPj0gaGFzaF9iaXRzXG4gICAqL1xuXG4gIHRoaXMuYmxvY2tfc3RhcnQgPSAwO1xuICAvKiBXaW5kb3cgcG9zaXRpb24gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgY3VycmVudCBvdXRwdXQgYmxvY2suIEdldHNcbiAgICogbmVnYXRpdmUgd2hlbiB0aGUgd2luZG93IGlzIG1vdmVkIGJhY2t3YXJkcy5cbiAgICovXG5cbiAgdGhpcy5tYXRjaF9sZW5ndGggPSAwOyAgICAgIC8qIGxlbmd0aCBvZiBiZXN0IG1hdGNoICovXG4gIHRoaXMucHJldl9tYXRjaCA9IDA7ICAgICAgICAvKiBwcmV2aW91cyBtYXRjaCAqL1xuICB0aGlzLm1hdGNoX2F2YWlsYWJsZSA9IDA7ICAgLyogc2V0IGlmIHByZXZpb3VzIG1hdGNoIGV4aXN0cyAqL1xuICB0aGlzLnN0cnN0YXJ0ID0gMDsgICAgICAgICAgLyogc3RhcnQgb2Ygc3RyaW5nIHRvIGluc2VydCAqL1xuICB0aGlzLm1hdGNoX3N0YXJ0ID0gMDsgICAgICAgLyogc3RhcnQgb2YgbWF0Y2hpbmcgc3RyaW5nICovXG4gIHRoaXMubG9va2FoZWFkID0gMDsgICAgICAgICAvKiBudW1iZXIgb2YgdmFsaWQgYnl0ZXMgYWhlYWQgaW4gd2luZG93ICovXG5cbiAgdGhpcy5wcmV2X2xlbmd0aCA9IDA7XG4gIC8qIExlbmd0aCBvZiB0aGUgYmVzdCBtYXRjaCBhdCBwcmV2aW91cyBzdGVwLiBNYXRjaGVzIG5vdCBncmVhdGVyIHRoYW4gdGhpc1xuICAgKiBhcmUgZGlzY2FyZGVkLiBUaGlzIGlzIHVzZWQgaW4gdGhlIGxhenkgbWF0Y2ggZXZhbHVhdGlvbi5cbiAgICovXG5cbiAgdGhpcy5tYXhfY2hhaW5fbGVuZ3RoID0gMDtcbiAgLyogVG8gc3BlZWQgdXAgZGVmbGF0aW9uLCBoYXNoIGNoYWlucyBhcmUgbmV2ZXIgc2VhcmNoZWQgYmV5b25kIHRoaXNcbiAgICogbGVuZ3RoLiAgQSBoaWdoZXIgbGltaXQgaW1wcm92ZXMgY29tcHJlc3Npb24gcmF0aW8gYnV0IGRlZ3JhZGVzIHRoZVxuICAgKiBzcGVlZC5cbiAgICovXG5cbiAgdGhpcy5tYXhfbGF6eV9tYXRjaCA9IDA7XG4gIC8qIEF0dGVtcHQgdG8gZmluZCBhIGJldHRlciBtYXRjaCBvbmx5IHdoZW4gdGhlIGN1cnJlbnQgbWF0Y2ggaXMgc3RyaWN0bHlcbiAgICogc21hbGxlciB0aGFuIHRoaXMgdmFsdWUuIFRoaXMgbWVjaGFuaXNtIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb25cbiAgICogbGV2ZWxzID49IDQuXG4gICAqL1xuICAvLyBUaGF0J3MgYWxpYXMgdG8gbWF4X2xhenlfbWF0Y2gsIGRvbid0IHVzZSBkaXJlY3RseVxuICAvL3RoaXMubWF4X2luc2VydF9sZW5ndGggPSAwO1xuICAvKiBJbnNlcnQgbmV3IHN0cmluZ3MgaW4gdGhlIGhhc2ggdGFibGUgb25seSBpZiB0aGUgbWF0Y2ggbGVuZ3RoIGlzIG5vdFxuICAgKiBncmVhdGVyIHRoYW4gdGhpcyBsZW5ndGguIFRoaXMgc2F2ZXMgdGltZSBidXQgZGVncmFkZXMgY29tcHJlc3Npb24uXG4gICAqIG1heF9pbnNlcnRfbGVuZ3RoIGlzIHVzZWQgb25seSBmb3IgY29tcHJlc3Npb24gbGV2ZWxzIDw9IDMuXG4gICAqL1xuXG4gIHRoaXMubGV2ZWwgPSAwOyAgICAgLyogY29tcHJlc3Npb24gbGV2ZWwgKDEuLjkpICovXG4gIHRoaXMuc3RyYXRlZ3kgPSAwOyAgLyogZmF2b3Igb3IgZm9yY2UgSHVmZm1hbiBjb2RpbmcqL1xuXG4gIHRoaXMuZ29vZF9tYXRjaCA9IDA7XG4gIC8qIFVzZSBhIGZhc3RlciBzZWFyY2ggd2hlbiB0aGUgcHJldmlvdXMgbWF0Y2ggaXMgbG9uZ2VyIHRoYW4gdGhpcyAqL1xuXG4gIHRoaXMubmljZV9tYXRjaCA9IDA7IC8qIFN0b3Agc2VhcmNoaW5nIHdoZW4gY3VycmVudCBtYXRjaCBleGNlZWRzIHRoaXMgKi9cblxuICAgICAgICAgICAgICAvKiB1c2VkIGJ5IHRyZWVzLmM6ICovXG5cbiAgLyogRGlkbid0IHVzZSBjdF9kYXRhIHR5cGVkZWYgYmVsb3cgdG8gc3VwcHJlc3MgY29tcGlsZXIgd2FybmluZyAqL1xuXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgZHluX2x0cmVlW0hFQVBfU0laRV07ICAgLyogbGl0ZXJhbCBhbmQgbGVuZ3RoIHRyZWUgKi9cbiAgLy8gc3RydWN0IGN0X2RhdGFfcyBkeW5fZHRyZWVbMipEX0NPREVTKzFdOyAvKiBkaXN0YW5jZSB0cmVlICovXG4gIC8vIHN0cnVjdCBjdF9kYXRhX3MgYmxfdHJlZVsyKkJMX0NPREVTKzFdOyAgLyogSHVmZm1hbiB0cmVlIGZvciBiaXQgbGVuZ3RocyAqL1xuXG4gIC8vIFVzZSBmbGF0IGFycmF5IG9mIERPVUJMRSBzaXplLCB3aXRoIGludGVybGVhdmVkIGZhdGEsXG4gIC8vIGJlY2F1c2UgSlMgZG9lcyBub3Qgc3VwcG9ydCBlZmZlY3RpdmVcbiAgdGhpcy5keW5fbHRyZWUgID0gbmV3IHV0aWxzLkJ1ZjE2KEhFQVBfU0laRSAqIDIpO1xuICB0aGlzLmR5bl9kdHJlZSAgPSBuZXcgdXRpbHMuQnVmMTYoKDIgKiBEX0NPREVTICsgMSkgKiAyKTtcbiAgdGhpcy5ibF90cmVlICAgID0gbmV3IHV0aWxzLkJ1ZjE2KCgyICogQkxfQ09ERVMgKyAxKSAqIDIpO1xuICB6ZXJvKHRoaXMuZHluX2x0cmVlKTtcbiAgemVybyh0aGlzLmR5bl9kdHJlZSk7XG4gIHplcm8odGhpcy5ibF90cmVlKTtcblxuICB0aGlzLmxfZGVzYyAgID0gbnVsbDsgICAgICAgICAvKiBkZXNjLiBmb3IgbGl0ZXJhbCB0cmVlICovXG4gIHRoaXMuZF9kZXNjICAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBkaXN0YW5jZSB0cmVlICovXG4gIHRoaXMuYmxfZGVzYyAgPSBudWxsOyAgICAgICAgIC8qIGRlc2MuIGZvciBiaXQgbGVuZ3RoIHRyZWUgKi9cblxuICAvL3VzaCBibF9jb3VudFtNQVhfQklUUysxXTtcbiAgdGhpcy5ibF9jb3VudCA9IG5ldyB1dGlscy5CdWYxNihNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvL2ludCBoZWFwWzIqTF9DT0RFUysxXTsgICAgICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgdGhpcy5oZWFwID0gbmV3IHV0aWxzLkJ1ZjE2KDIgKiBMX0NPREVTICsgMSk7ICAvKiBoZWFwIHVzZWQgdG8gYnVpbGQgdGhlIEh1ZmZtYW4gdHJlZXMgKi9cbiAgemVybyh0aGlzLmhlYXApO1xuXG4gIHRoaXMuaGVhcF9sZW4gPSAwOyAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaGVhcCAqL1xuICB0aGlzLmhlYXBfbWF4ID0gMDsgICAgICAgICAgICAgICAvKiBlbGVtZW50IG9mIGxhcmdlc3QgZnJlcXVlbmN5ICovXG4gIC8qIFRoZSBzb25zIG9mIGhlYXBbbl0gYXJlIGhlYXBbMipuXSBhbmQgaGVhcFsyKm4rMV0uIGhlYXBbMF0gaXMgbm90IHVzZWQuXG4gICAqIFRoZSBzYW1lIGhlYXAgYXJyYXkgaXMgdXNlZCB0byBidWlsZCBhbGwgdHJlZXMuXG4gICAqL1xuXG4gIHRoaXMuZGVwdGggPSBuZXcgdXRpbHMuQnVmMTYoMiAqIExfQ09ERVMgKyAxKTsgLy91Y2ggZGVwdGhbMipMX0NPREVTKzFdO1xuICB6ZXJvKHRoaXMuZGVwdGgpO1xuICAvKiBEZXB0aCBvZiBlYWNoIHN1YnRyZWUgdXNlZCBhcyB0aWUgYnJlYWtlciBmb3IgdHJlZXMgb2YgZXF1YWwgZnJlcXVlbmN5XG4gICAqL1xuXG4gIHRoaXMubF9idWYgPSAwOyAgICAgICAgICAvKiBidWZmZXIgaW5kZXggZm9yIGxpdGVyYWxzIG9yIGxlbmd0aHMgKi9cblxuICB0aGlzLmxpdF9idWZzaXplID0gMDtcbiAgLyogU2l6ZSBvZiBtYXRjaCBidWZmZXIgZm9yIGxpdGVyYWxzL2xlbmd0aHMuICBUaGVyZSBhcmUgNCByZWFzb25zIGZvclxuICAgKiBsaW1pdGluZyBsaXRfYnVmc2l6ZSB0byA2NEs6XG4gICAqICAgLSBmcmVxdWVuY2llcyBjYW4gYmUga2VwdCBpbiAxNiBiaXQgY291bnRlcnNcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciB0aGUgZmlyc3QgYmxvY2ssIGFsbCBpbnB1dFxuICAgKiAgICAgZGF0YSBpcyBzdGlsbCBpbiB0aGUgd2luZG93IHNvIHdlIGNhbiBzdGlsbCBlbWl0IGEgc3RvcmVkIGJsb2NrIGV2ZW5cbiAgICogICAgIHdoZW4gaW5wdXQgY29tZXMgZnJvbSBzdGFuZGFyZCBpbnB1dC4gIChUaGlzIGNhbiBhbHNvIGJlIGRvbmUgZm9yXG4gICAqICAgICBhbGwgYmxvY2tzIGlmIGxpdF9idWZzaXplIGlzIG5vdCBncmVhdGVyIHRoYW4gMzJLLilcbiAgICogICAtIGlmIGNvbXByZXNzaW9uIGlzIG5vdCBzdWNjZXNzZnVsIGZvciBhIGZpbGUgc21hbGxlciB0aGFuIDY0Sywgd2UgY2FuXG4gICAqICAgICBldmVuIGVtaXQgYSBzdG9yZWQgZmlsZSBpbnN0ZWFkIG9mIGEgc3RvcmVkIGJsb2NrIChzYXZpbmcgNSBieXRlcykuXG4gICAqICAgICBUaGlzIGlzIGFwcGxpY2FibGUgb25seSBmb3IgemlwIChub3QgZ3ppcCBvciB6bGliKS5cbiAgICogICAtIGNyZWF0aW5nIG5ldyBIdWZmbWFuIHRyZWVzIGxlc3MgZnJlcXVlbnRseSBtYXkgbm90IHByb3ZpZGUgZmFzdFxuICAgKiAgICAgYWRhcHRhdGlvbiB0byBjaGFuZ2VzIGluIHRoZSBpbnB1dCBkYXRhIHN0YXRpc3RpY3MuIChUYWtlIGZvclxuICAgKiAgICAgZXhhbXBsZSBhIGJpbmFyeSBmaWxlIHdpdGggcG9vcmx5IGNvbXByZXNzaWJsZSBjb2RlIGZvbGxvd2VkIGJ5XG4gICAqICAgICBhIGhpZ2hseSBjb21wcmVzc2libGUgc3RyaW5nIHRhYmxlLikgU21hbGxlciBidWZmZXIgc2l6ZXMgZ2l2ZVxuICAgKiAgICAgZmFzdCBhZGFwdGF0aW9uIGJ1dCBoYXZlIG9mIGNvdXJzZSB0aGUgb3ZlcmhlYWQgb2YgdHJhbnNtaXR0aW5nXG4gICAqICAgICB0cmVlcyBtb3JlIGZyZXF1ZW50bHkuXG4gICAqICAgLSBJIGNhbid0IGNvdW50IGFib3ZlIDRcbiAgICovXG5cbiAgdGhpcy5sYXN0X2xpdCA9IDA7ICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuXG4gIHRoaXMuZF9idWYgPSAwO1xuICAvKiBCdWZmZXIgaW5kZXggZm9yIGRpc3RhbmNlcy4gVG8gc2ltcGxpZnkgdGhlIGNvZGUsIGRfYnVmIGFuZCBsX2J1ZiBoYXZlXG4gICAqIHRoZSBzYW1lIG51bWJlciBvZiBlbGVtZW50cy4gVG8gdXNlIGRpZmZlcmVudCBsZW5ndGhzLCBhbiBleHRyYSBmbGFnXG4gICAqIGFycmF5IHdvdWxkIGJlIG5lY2Vzc2FyeS5cbiAgICovXG5cbiAgdGhpcy5vcHRfbGVuID0gMDsgICAgICAgLyogYml0IGxlbmd0aCBvZiBjdXJyZW50IGJsb2NrIHdpdGggb3B0aW1hbCB0cmVlcyAqL1xuICB0aGlzLnN0YXRpY19sZW4gPSAwOyAgICAvKiBiaXQgbGVuZ3RoIG9mIGN1cnJlbnQgYmxvY2sgd2l0aCBzdGF0aWMgdHJlZXMgKi9cbiAgdGhpcy5tYXRjaGVzID0gMDsgICAgICAgLyogbnVtYmVyIG9mIHN0cmluZyBtYXRjaGVzIGluIGN1cnJlbnQgYmxvY2sgKi9cbiAgdGhpcy5pbnNlcnQgPSAwOyAgICAgICAgLyogYnl0ZXMgYXQgZW5kIG9mIHdpbmRvdyBsZWZ0IHRvIGluc2VydCAqL1xuXG5cbiAgdGhpcy5iaV9idWYgPSAwO1xuICAvKiBPdXRwdXQgYnVmZmVyLiBiaXRzIGFyZSBpbnNlcnRlZCBzdGFydGluZyBhdCB0aGUgYm90dG9tIChsZWFzdFxuICAgKiBzaWduaWZpY2FudCBiaXRzKS5cbiAgICovXG4gIHRoaXMuYmlfdmFsaWQgPSAwO1xuICAvKiBOdW1iZXIgb2YgdmFsaWQgYml0cyBpbiBiaV9idWYuICBBbGwgYml0cyBhYm92ZSB0aGUgbGFzdCB2YWxpZCBiaXRcbiAgICogYXJlIGFsd2F5cyB6ZXJvLlxuICAgKi9cblxuICAvLyBVc2VkIGZvciB3aW5kb3cgbWVtb3J5IGluaXQuIFdlIHNhZmVseSBpZ25vcmUgaXQgZm9yIEpTLiBUaGF0IG1ha2VzXG4gIC8vIHNlbnNlIG9ubHkgZm9yIHBvaW50ZXJzIGFuZCBtZW1vcnkgY2hlY2sgdG9vbHMuXG4gIC8vdGhpcy5oaWdoX3dhdGVyID0gMDtcbiAgLyogSGlnaCB3YXRlciBtYXJrIG9mZnNldCBpbiB3aW5kb3cgZm9yIGluaXRpYWxpemVkIGJ5dGVzIC0tIGJ5dGVzIGFib3ZlXG4gICAqIHRoaXMgYXJlIHNldCB0byB6ZXJvIGluIG9yZGVyIHRvIGF2b2lkIG1lbW9yeSBjaGVjayB3YXJuaW5ncyB3aGVuXG4gICAqIGxvbmdlc3QgbWF0Y2ggcm91dGluZXMgYWNjZXNzIGJ5dGVzIHBhc3QgdGhlIGlucHV0LiAgVGhpcyBpcyB0aGVuXG4gICAqIHVwZGF0ZWQgdG8gdGhlIG5ldyBoaWdoIHdhdGVyIG1hcmsuXG4gICAqL1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgcztcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IDA7XG4gIHN0cm0uZGF0YV90eXBlID0gWl9VTktOT1dOO1xuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICBzLnBlbmRpbmcgPSAwO1xuICBzLnBlbmRpbmdfb3V0ID0gMDtcblxuICBpZiAocy53cmFwIDwgMCkge1xuICAgIHMud3JhcCA9IC1zLndyYXA7XG4gICAgLyogd2FzIG1hZGUgbmVnYXRpdmUgYnkgZGVmbGF0ZSguLi4sIFpfRklOSVNIKTsgKi9cbiAgfVxuICBzLnN0YXR1cyA9IChzLndyYXAgPyBJTklUX1NUQVRFIDogQlVTWV9TVEFURSk7XG4gIHN0cm0uYWRsZXIgPSAocy53cmFwID09PSAyKSA/XG4gICAgMCAgLy8gY3JjMzIoMCwgWl9OVUxMLCAwKVxuICA6XG4gICAgMTsgLy8gYWRsZXIzMigwLCBaX05VTEwsIDApXG4gIHMubGFzdF9mbHVzaCA9IFpfTk9fRkxVU0g7XG4gIHRyZWVzLl90cl9pbml0KHMpO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlUmVzZXQoc3RybSkge1xuICB2YXIgcmV0ID0gZGVmbGF0ZVJlc2V0S2VlcChzdHJtKTtcbiAgaWYgKHJldCA9PT0gWl9PSykge1xuICAgIGxtX2luaXQoc3RybS5zdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlU2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBpZiAoc3RybS5zdGF0ZS53cmFwICE9PSAyKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdHJtLnN0YXRlLmd6aGVhZCA9IGhlYWQ7XG4gIHJldHVybiBaX09LO1xufVxuXG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0MihzdHJtLCBsZXZlbCwgbWV0aG9kLCB3aW5kb3dCaXRzLCBtZW1MZXZlbCwgc3RyYXRlZ3kpIHtcbiAgaWYgKCFzdHJtKSB7IC8vID09PSBaX05VTExcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgdmFyIHdyYXAgPSAxO1xuXG4gIGlmIChsZXZlbCA9PT0gWl9ERUZBVUxUX0NPTVBSRVNTSU9OKSB7XG4gICAgbGV2ZWwgPSA2O1xuICB9XG5cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7IC8qIHN1cHByZXNzIHpsaWIgd3JhcHBlciAqL1xuICAgIHdyYXAgPSAwO1xuICAgIHdpbmRvd0JpdHMgPSAtd2luZG93Qml0cztcbiAgfVxuXG4gIGVsc2UgaWYgKHdpbmRvd0JpdHMgPiAxNSkge1xuICAgIHdyYXAgPSAyOyAgICAgICAgICAgLyogd3JpdGUgZ3ppcCB3cmFwcGVyIGluc3RlYWQgKi9cbiAgICB3aW5kb3dCaXRzIC09IDE2O1xuICB9XG5cblxuICBpZiAobWVtTGV2ZWwgPCAxIHx8IG1lbUxldmVsID4gTUFYX01FTV9MRVZFTCB8fCBtZXRob2QgIT09IFpfREVGTEFURUQgfHxcbiAgICB3aW5kb3dCaXRzIDwgOCB8fCB3aW5kb3dCaXRzID4gMTUgfHwgbGV2ZWwgPCAwIHx8IGxldmVsID4gOSB8fFxuICAgIHN0cmF0ZWd5IDwgMCB8fCBzdHJhdGVneSA+IFpfRklYRUQpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG5cbiAgaWYgKHdpbmRvd0JpdHMgPT09IDgpIHtcbiAgICB3aW5kb3dCaXRzID0gOTtcbiAgfVxuICAvKiB1bnRpbCAyNTYtYnl0ZSB3aW5kb3cgYnVnIGZpeGVkICovXG5cbiAgdmFyIHMgPSBuZXcgRGVmbGF0ZVN0YXRlKCk7XG5cbiAgc3RybS5zdGF0ZSA9IHM7XG4gIHMuc3RybSA9IHN0cm07XG5cbiAgcy53cmFwID0gd3JhcDtcbiAgcy5nemhlYWQgPSBudWxsO1xuICBzLndfYml0cyA9IHdpbmRvd0JpdHM7XG4gIHMud19zaXplID0gMSA8PCBzLndfYml0cztcbiAgcy53X21hc2sgPSBzLndfc2l6ZSAtIDE7XG5cbiAgcy5oYXNoX2JpdHMgPSBtZW1MZXZlbCArIDc7XG4gIHMuaGFzaF9zaXplID0gMSA8PCBzLmhhc2hfYml0cztcbiAgcy5oYXNoX21hc2sgPSBzLmhhc2hfc2l6ZSAtIDE7XG4gIHMuaGFzaF9zaGlmdCA9IH5+KChzLmhhc2hfYml0cyArIE1JTl9NQVRDSCAtIDEpIC8gTUlOX01BVENIKTtcblxuICBzLndpbmRvdyA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplICogMik7XG4gIHMuaGVhZCA9IG5ldyB1dGlscy5CdWYxNihzLmhhc2hfc2l6ZSk7XG4gIHMucHJldiA9IG5ldyB1dGlscy5CdWYxNihzLndfc2l6ZSk7XG5cbiAgLy8gRG9uJ3QgbmVlZCBtZW0gaW5pdCBtYWdpYyBmb3IgSlMuXG4gIC8vcy5oaWdoX3dhdGVyID0gMDsgIC8qIG5vdGhpbmcgd3JpdHRlbiB0byBzLT53aW5kb3cgeWV0ICovXG5cbiAgcy5saXRfYnVmc2l6ZSA9IDEgPDwgKG1lbUxldmVsICsgNik7IC8qIDE2SyBlbGVtZW50cyBieSBkZWZhdWx0ICovXG5cbiAgcy5wZW5kaW5nX2J1Zl9zaXplID0gcy5saXRfYnVmc2l6ZSAqIDQ7XG5cbiAgLy9vdmVybGF5ID0gKHVzaGYgKikgWkFMTE9DKHN0cm0sIHMtPmxpdF9idWZzaXplLCBzaXplb2YodXNoKSsyKTtcbiAgLy9zLT5wZW5kaW5nX2J1ZiA9ICh1Y2hmICopIG92ZXJsYXk7XG4gIHMucGVuZGluZ19idWYgPSBuZXcgdXRpbHMuQnVmOChzLnBlbmRpbmdfYnVmX3NpemUpO1xuXG4gIC8vIEl0IGlzIG9mZnNldCBmcm9tIGBzLnBlbmRpbmdfYnVmYCAoc2l6ZSBpcyBgcy5saXRfYnVmc2l6ZSAqIDJgKVxuICAvL3MtPmRfYnVmID0gb3ZlcmxheSArIHMtPmxpdF9idWZzaXplL3NpemVvZih1c2gpO1xuICBzLmRfYnVmID0gMSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgLy9zLT5sX2J1ZiA9IHMtPnBlbmRpbmdfYnVmICsgKDErc2l6ZW9mKHVzaCkpKnMtPmxpdF9idWZzaXplO1xuICBzLmxfYnVmID0gKDEgKyAyKSAqIHMubGl0X2J1ZnNpemU7XG5cbiAgcy5sZXZlbCA9IGxldmVsO1xuICBzLnN0cmF0ZWd5ID0gc3RyYXRlZ3k7XG4gIHMubWV0aG9kID0gbWV0aG9kO1xuXG4gIHJldHVybiBkZWZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVJbml0KHN0cm0sIGxldmVsKSB7XG4gIHJldHVybiBkZWZsYXRlSW5pdDIoc3RybSwgbGV2ZWwsIFpfREVGTEFURUQsIE1BWF9XQklUUywgREVGX01FTV9MRVZFTCwgWl9ERUZBVUxUX1NUUkFURUdZKTtcbn1cblxuXG5mdW5jdGlvbiBkZWZsYXRlKHN0cm0sIGZsdXNoKSB7XG4gIHZhciBvbGRfZmx1c2gsIHM7XG4gIHZhciBiZWcsIHZhbDsgLy8gZm9yIGd6aXAgaGVhZGVyIHdyaXRlIG9ubHlcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgfHxcbiAgICBmbHVzaCA+IFpfQkxPQ0sgfHwgZmx1c2ggPCAwKSB7XG4gICAgcmV0dXJuIHN0cm0gPyBlcnIoc3RybSwgWl9TVFJFQU1fRVJST1IpIDogWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICBzID0gc3RybS5zdGF0ZTtcblxuICBpZiAoIXN0cm0ub3V0cHV0IHx8XG4gICAgICAoIXN0cm0uaW5wdXQgJiYgc3RybS5hdmFpbF9pbiAhPT0gMCkgfHxcbiAgICAgIChzLnN0YXR1cyA9PT0gRklOSVNIX1NUQVRFICYmIGZsdXNoICE9PSBaX0ZJTklTSCkpIHtcbiAgICByZXR1cm4gZXJyKHN0cm0sIChzdHJtLmF2YWlsX291dCA9PT0gMCkgPyBaX0JVRl9FUlJPUiA6IFpfU1RSRUFNX0VSUk9SKTtcbiAgfVxuXG4gIHMuc3RybSA9IHN0cm07IC8qIGp1c3QgaW4gY2FzZSAqL1xuICBvbGRfZmx1c2ggPSBzLmxhc3RfZmx1c2g7XG4gIHMubGFzdF9mbHVzaCA9IGZsdXNoO1xuXG4gIC8qIFdyaXRlIHRoZSBoZWFkZXIgKi9cbiAgaWYgKHMuc3RhdHVzID09PSBJTklUX1NUQVRFKSB7XG5cbiAgICBpZiAocy53cmFwID09PSAyKSB7IC8vIEdaSVAgaGVhZGVyXG4gICAgICBzdHJtLmFkbGVyID0gMDsgIC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICBwdXRfYnl0ZShzLCAzMSk7XG4gICAgICBwdXRfYnl0ZShzLCAxMzkpO1xuICAgICAgcHV0X2J5dGUocywgOCk7XG4gICAgICBpZiAoIXMuZ3poZWFkKSB7IC8vIHMtPmd6aGVhZCA9PSBaX05VTExcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCAwKTtcbiAgICAgICAgcHV0X2J5dGUocywgMCk7XG4gICAgICAgIHB1dF9ieXRlKHMsIDApO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIE9TX0NPREUpO1xuICAgICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRleHQgPyAxIDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAocy5nemhlYWQuaGNyYyA/IDIgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgICghcy5nemhlYWQuZXh0cmEgPyAwIDogNCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLm5hbWUgPyAwIDogOCkgK1xuICAgICAgICAgICAgICAgICAgICAoIXMuZ3poZWFkLmNvbW1lbnQgPyAwIDogMTYpXG4gICAgICAgICk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLnRpbWUgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHMuZ3poZWFkLnRpbWUgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHB1dF9ieXRlKHMsIChzLmd6aGVhZC50aW1lID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBwdXRfYnl0ZShzLCBzLmxldmVsID09PSA5ID8gMiA6XG4gICAgICAgICAgICAgICAgICAgIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyID9cbiAgICAgICAgICAgICAgICAgICAgIDQgOiAwKSk7XG4gICAgICAgIHB1dF9ieXRlKHMsIHMuZ3poZWFkLm9zICYgMHhmZik7XG4gICAgICAgIGlmIChzLmd6aGVhZC5leHRyYSAmJiBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYS5sZW5ndGggJiAweGZmKTtcbiAgICAgICAgICBwdXRfYnl0ZShzLCAocy5nemhlYWQuZXh0cmEubGVuZ3RoID4+IDgpICYgMHhmZik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMpIHtcbiAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IEVYVFJBX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIC8vIERFRkxBVEUgaGVhZGVyXG4gICAge1xuICAgICAgdmFyIGhlYWRlciA9IChaX0RFRkxBVEVEICsgKChzLndfYml0cyAtIDgpIDw8IDQpKSA8PCA4O1xuICAgICAgdmFyIGxldmVsX2ZsYWdzID0gLTE7XG5cbiAgICAgIGlmIChzLnN0cmF0ZWd5ID49IFpfSFVGRk1BTl9PTkxZIHx8IHMubGV2ZWwgPCAyKSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocy5sZXZlbCA8IDYpIHtcbiAgICAgICAgbGV2ZWxfZmxhZ3MgPSAxO1xuICAgICAgfSBlbHNlIGlmIChzLmxldmVsID09PSA2KSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldmVsX2ZsYWdzID0gMztcbiAgICAgIH1cbiAgICAgIGhlYWRlciB8PSAobGV2ZWxfZmxhZ3MgPDwgNik7XG4gICAgICBpZiAocy5zdHJzdGFydCAhPT0gMCkgeyBoZWFkZXIgfD0gUFJFU0VUX0RJQ1Q7IH1cbiAgICAgIGhlYWRlciArPSAzMSAtIChoZWFkZXIgJSAzMSk7XG5cbiAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIHB1dFNob3J0TVNCKHMsIGhlYWRlcik7XG5cbiAgICAgIC8qIFNhdmUgdGhlIGFkbGVyMzIgb2YgdGhlIHByZXNldCBkaWN0aW9uYXJ5OiAqL1xuICAgICAgaWYgKHMuc3Ryc3RhcnQgIT09IDApIHtcbiAgICAgICAgcHV0U2hvcnRNU0Iocywgc3RybS5hZGxlciA+Pj4gMTYpO1xuICAgICAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSAxOyAvLyBhZGxlcjMyKDBMLCBaX05VTEwsIDApO1xuICAgIH1cbiAgfVxuXG4vLyNpZmRlZiBHWklQXG4gIGlmIChzLnN0YXR1cyA9PT0gRVhUUkFfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuZXh0cmEvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuXG4gICAgICB3aGlsZSAocy5nemluZGV4IDwgKHMuZ3poZWFkLmV4dHJhLmxlbmd0aCAmIDB4ZmZmZikpIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCBzLmd6aGVhZC5leHRyYVtzLmd6aW5kZXhdICYgMHhmZik7XG4gICAgICAgIHMuZ3ppbmRleCsrO1xuICAgICAgfVxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAocy5nemluZGV4ID09PSBzLmd6aGVhZC5leHRyYS5sZW5ndGgpIHtcbiAgICAgICAgcy5nemluZGV4ID0gMDtcbiAgICAgICAgcy5zdGF0dXMgPSBOQU1FX1NUQVRFO1xuICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHMuc3RhdHVzID0gTkFNRV9TVEFURTtcbiAgICB9XG4gIH1cbiAgaWYgKHMuc3RhdHVzID09PSBOQU1FX1NUQVRFKSB7XG4gICAgaWYgKHMuZ3poZWFkLm5hbWUvKiAhPSBaX05VTEwqLykge1xuICAgICAgYmVnID0gcy5wZW5kaW5nOyAgLyogc3RhcnQgb2YgYnl0ZXMgdG8gdXBkYXRlIGNyYyAqL1xuICAgICAgLy9pbnQgdmFsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIGlmIChzLnBlbmRpbmcgPT09IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICAgICAgc3RybS5hZGxlciA9IGNyYzMyKHN0cm0uYWRsZXIsIHMucGVuZGluZ19idWYsIHMucGVuZGluZyAtIGJlZywgYmVnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmx1c2hfcGVuZGluZyhzdHJtKTtcbiAgICAgICAgICBiZWcgPSBzLnBlbmRpbmc7XG4gICAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgICB2YWwgPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEpTIHNwZWNpZmljOiBsaXR0bGUgbWFnaWMgdG8gYWRkIHplcm8gdGVybWluYXRvciB0byBlbmQgb2Ygc3RyaW5nXG4gICAgICAgIGlmIChzLmd6aW5kZXggPCBzLmd6aGVhZC5uYW1lLmxlbmd0aCkge1xuICAgICAgICAgIHZhbCA9IHMuZ3poZWFkLm5hbWUuY2hhckNvZGVBdChzLmd6aW5kZXgrKykgJiAweGZmO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcHV0X2J5dGUocywgdmFsKTtcbiAgICAgIH0gd2hpbGUgKHZhbCAhPT0gMCk7XG5cbiAgICAgIGlmIChzLmd6aGVhZC5oY3JjICYmIHMucGVuZGluZyA+IGJlZykge1xuICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgfVxuICAgICAgaWYgKHZhbCA9PT0gMCkge1xuICAgICAgICBzLmd6aW5kZXggPSAwO1xuICAgICAgICBzLnN0YXR1cyA9IENPTU1FTlRfU1RBVEU7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcy5zdGF0dXMgPSBDT01NRU5UX1NUQVRFO1xuICAgIH1cbiAgfVxuICBpZiAocy5zdGF0dXMgPT09IENPTU1FTlRfU1RBVEUpIHtcbiAgICBpZiAocy5nemhlYWQuY29tbWVudC8qICE9IFpfTlVMTCovKSB7XG4gICAgICBiZWcgPSBzLnBlbmRpbmc7ICAvKiBzdGFydCBvZiBieXRlcyB0byB1cGRhdGUgY3JjICovXG4gICAgICAvL2ludCB2YWw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgaWYgKHMucGVuZGluZyA9PT0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgICAgICBzdHJtLmFkbGVyID0gY3JjMzIoc3RybS5hZGxlciwgcy5wZW5kaW5nX2J1Ziwgcy5wZW5kaW5nIC0gYmVnLCBiZWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgICAgIGJlZyA9IHMucGVuZGluZztcbiAgICAgICAgICBpZiAocy5wZW5kaW5nID09PSBzLnBlbmRpbmdfYnVmX3NpemUpIHtcbiAgICAgICAgICAgIHZhbCA9IDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSlMgc3BlY2lmaWM6IGxpdHRsZSBtYWdpYyB0byBhZGQgemVybyB0ZXJtaW5hdG9yIHRvIGVuZCBvZiBzdHJpbmdcbiAgICAgICAgaWYgKHMuZ3ppbmRleCA8IHMuZ3poZWFkLmNvbW1lbnQubGVuZ3RoKSB7XG4gICAgICAgICAgdmFsID0gcy5nemhlYWQuY29tbWVudC5jaGFyQ29kZUF0KHMuZ3ppbmRleCsrKSAmIDB4ZmY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICBwdXRfYnl0ZShzLCB2YWwpO1xuICAgICAgfSB3aGlsZSAodmFsICE9PSAwKTtcblxuICAgICAgaWYgKHMuZ3poZWFkLmhjcmMgJiYgcy5wZW5kaW5nID4gYmVnKSB7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBjcmMzMihzdHJtLmFkbGVyLCBzLnBlbmRpbmdfYnVmLCBzLnBlbmRpbmcgLSBiZWcsIGJlZyk7XG4gICAgICB9XG4gICAgICBpZiAodmFsID09PSAwKSB7XG4gICAgICAgIHMuc3RhdHVzID0gSENSQ19TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEhDUkNfU1RBVEU7XG4gICAgfVxuICB9XG4gIGlmIChzLnN0YXR1cyA9PT0gSENSQ19TVEFURSkge1xuICAgIGlmIChzLmd6aGVhZC5oY3JjKSB7XG4gICAgICBpZiAocy5wZW5kaW5nICsgMiA+IHMucGVuZGluZ19idWZfc2l6ZSkge1xuICAgICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgfVxuICAgICAgaWYgKHMucGVuZGluZyArIDIgPD0gcy5wZW5kaW5nX2J1Zl9zaXplKSB7XG4gICAgICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICAgICAgcHV0X2J5dGUocywgKHN0cm0uYWRsZXIgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgc3RybS5hZGxlciA9IDA7IC8vY3JjMzIoMEwsIFpfTlVMTCwgMCk7XG4gICAgICAgIHMuc3RhdHVzID0gQlVTWV9TVEFURTtcbiAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBzLnN0YXR1cyA9IEJVU1lfU1RBVEU7XG4gICAgfVxuICB9XG4vLyNlbmRpZlxuXG4gIC8qIEZsdXNoIGFzIG11Y2ggcGVuZGluZyBvdXRwdXQgYXMgcG9zc2libGUgKi9cbiAgaWYgKHMucGVuZGluZyAhPT0gMCkge1xuICAgIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAvKiBTaW5jZSBhdmFpbF9vdXQgaXMgMCwgZGVmbGF0ZSB3aWxsIGJlIGNhbGxlZCBhZ2FpbiB3aXRoXG4gICAgICAgKiBtb3JlIG91dHB1dCBzcGFjZSwgYnV0IHBvc3NpYmx5IHdpdGggYm90aCBwZW5kaW5nIGFuZFxuICAgICAgICogYXZhaWxfaW4gZXF1YWwgdG8gemVyby4gVGhlcmUgd29uJ3QgYmUgYW55dGhpbmcgdG8gZG8sXG4gICAgICAgKiBidXQgdGhpcyBpcyBub3QgYW4gZXJyb3Igc2l0dWF0aW9uIHNvIG1ha2Ugc3VyZSB3ZVxuICAgICAgICogcmV0dXJuIE9LIGluc3RlYWQgb2YgQlVGX0VSUk9SIGF0IG5leHQgY2FsbCBvZiBkZWZsYXRlOlxuICAgICAgICovXG4gICAgICBzLmxhc3RfZmx1c2ggPSAtMTtcbiAgICAgIHJldHVybiBaX09LO1xuICAgIH1cblxuICAgIC8qIE1ha2Ugc3VyZSB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZG8gYW5kIGF2b2lkIGR1cGxpY2F0ZSBjb25zZWN1dGl2ZVxuICAgICAqIGZsdXNoZXMuIEZvciByZXBlYXRlZCBhbmQgdXNlbGVzcyBjYWxscyB3aXRoIFpfRklOSVNILCB3ZSBrZWVwXG4gICAgICogcmV0dXJuaW5nIFpfU1RSRUFNX0VORCBpbnN0ZWFkIG9mIFpfQlVGX0VSUk9SLlxuICAgICAqL1xuICB9IGVsc2UgaWYgKHN0cm0uYXZhaWxfaW4gPT09IDAgJiYgcmFuayhmbHVzaCkgPD0gcmFuayhvbGRfZmx1c2gpICYmXG4gICAgZmx1c2ggIT09IFpfRklOSVNIKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBVc2VyIG11c3Qgbm90IHByb3ZpZGUgbW9yZSBpbnB1dCBhZnRlciB0aGUgZmlyc3QgRklOSVNIOiAqL1xuICBpZiAocy5zdGF0dXMgPT09IEZJTklTSF9TVEFURSAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX0JVRl9FUlJPUik7XG4gIH1cblxuICAvKiBTdGFydCBhIG5ldyBibG9jayBvciBjb250aW51ZSB0aGUgY3VycmVudCBvbmUuXG4gICAqL1xuICBpZiAoc3RybS5hdmFpbF9pbiAhPT0gMCB8fCBzLmxvb2thaGVhZCAhPT0gMCB8fFxuICAgIChmbHVzaCAhPT0gWl9OT19GTFVTSCAmJiBzLnN0YXR1cyAhPT0gRklOSVNIX1NUQVRFKSkge1xuICAgIHZhciBic3RhdGUgPSAocy5zdHJhdGVneSA9PT0gWl9IVUZGTUFOX09OTFkpID8gZGVmbGF0ZV9odWZmKHMsIGZsdXNoKSA6XG4gICAgICAocy5zdHJhdGVneSA9PT0gWl9STEUgPyBkZWZsYXRlX3JsZShzLCBmbHVzaCkgOlxuICAgICAgICBjb25maWd1cmF0aW9uX3RhYmxlW3MubGV2ZWxdLmZ1bmMocywgZmx1c2gpKTtcblxuICAgIGlmIChic3RhdGUgPT09IEJTX0ZJTklTSF9TVEFSVEVEIHx8IGJzdGF0ZSA9PT0gQlNfRklOSVNIX0RPTkUpIHtcbiAgICAgIHMuc3RhdHVzID0gRklOSVNIX1NUQVRFO1xuICAgIH1cbiAgICBpZiAoYnN0YXRlID09PSBCU19ORUVEX01PUkUgfHwgYnN0YXRlID09PSBCU19GSU5JU0hfU1RBUlRFRCkge1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xO1xuICAgICAgICAvKiBhdm9pZCBCVUZfRVJST1IgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgIH1cbiAgICAgIHJldHVybiBaX09LO1xuICAgICAgLyogSWYgZmx1c2ggIT0gWl9OT19GTFVTSCAmJiBhdmFpbF9vdXQgPT0gMCwgdGhlIG5leHQgY2FsbFxuICAgICAgICogb2YgZGVmbGF0ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGZsdXNoIHBhcmFtZXRlciB0byBtYWtlIHN1cmVcbiAgICAgICAqIHRoYXQgdGhlIGZsdXNoIGlzIGNvbXBsZXRlLiBTbyB3ZSBkb24ndCBoYXZlIHRvIG91dHB1dCBhblxuICAgICAgICogZW1wdHkgYmxvY2sgaGVyZSwgdGhpcyB3aWxsIGJlIGRvbmUgYXQgbmV4dCBjYWxsLiBUaGlzIGFsc29cbiAgICAgICAqIGVuc3VyZXMgdGhhdCBmb3IgYSB2ZXJ5IHNtYWxsIG91dHB1dCBidWZmZXIsIHdlIGVtaXQgYXQgbW9zdFxuICAgICAgICogb25lIGVtcHR5IGJsb2NrLlxuICAgICAgICovXG4gICAgfVxuICAgIGlmIChic3RhdGUgPT09IEJTX0JMT0NLX0RPTkUpIHtcbiAgICAgIGlmIChmbHVzaCA9PT0gWl9QQVJUSUFMX0ZMVVNIKSB7XG4gICAgICAgIHRyZWVzLl90cl9hbGlnbihzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGZsdXNoICE9PSBaX0JMT0NLKSB7IC8qIEZVTExfRkxVU0ggb3IgU1lOQ19GTFVTSCAqL1xuXG4gICAgICAgIHRyZWVzLl90cl9zdG9yZWRfYmxvY2socywgMCwgMCwgZmFsc2UpO1xuICAgICAgICAvKiBGb3IgYSBmdWxsIGZsdXNoLCB0aGlzIGVtcHR5IGJsb2NrIHdpbGwgYmUgcmVjb2duaXplZFxuICAgICAgICAgKiBhcyBhIHNwZWNpYWwgbWFya2VyIGJ5IGluZmxhdGVfc3luYygpLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGZsdXNoID09PSBaX0ZVTExfRkxVU0gpIHtcbiAgICAgICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi8gICAgICAgICAgICAgLyogZm9yZ2V0IGhpc3RvcnkgKi9cbiAgICAgICAgICB6ZXJvKHMuaGVhZCk7IC8vIEZpbGwgd2l0aCBOSUwgKD0gMCk7XG5cbiAgICAgICAgICBpZiAocy5sb29rYWhlYWQgPT09IDApIHtcbiAgICAgICAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICAgICAgICBzLmluc2VydCA9IDA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmbHVzaF9wZW5kaW5nKHN0cm0pO1xuICAgICAgaWYgKHN0cm0uYXZhaWxfb3V0ID09PSAwKSB7XG4gICAgICAgIHMubGFzdF9mbHVzaCA9IC0xOyAvKiBhdm9pZCBCVUZfRVJST1IgYXQgbmV4dCBjYWxsLCBzZWUgYWJvdmUgKi9cbiAgICAgICAgcmV0dXJuIFpfT0s7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0KHN0cm0tPmF2YWlsX291dCA+IDAsIFwiYnVnMlwiKTtcbiAgLy9pZiAoc3RybS5hdmFpbF9vdXQgPD0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJidWcyXCIpO31cblxuICBpZiAoZmx1c2ggIT09IFpfRklOSVNIKSB7IHJldHVybiBaX09LOyB9XG4gIGlmIChzLndyYXAgPD0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRU5EOyB9XG5cbiAgLyogV3JpdGUgdGhlIHRyYWlsZXIgKi9cbiAgaWYgKHMud3JhcCA9PT0gMikge1xuICAgIHB1dF9ieXRlKHMsIHN0cm0uYWRsZXIgJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS5hZGxlciA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLmFkbGVyID4+IDI0KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIHN0cm0udG90YWxfaW4gJiAweGZmKTtcbiAgICBwdXRfYnl0ZShzLCAoc3RybS50b3RhbF9pbiA+PiA4KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDE2KSAmIDB4ZmYpO1xuICAgIHB1dF9ieXRlKHMsIChzdHJtLnRvdGFsX2luID4+IDI0KSAmIDB4ZmYpO1xuICB9XG4gIGVsc2VcbiAge1xuICAgIHB1dFNob3J0TVNCKHMsIHN0cm0uYWRsZXIgPj4+IDE2KTtcbiAgICBwdXRTaG9ydE1TQihzLCBzdHJtLmFkbGVyICYgMHhmZmZmKTtcbiAgfVxuXG4gIGZsdXNoX3BlbmRpbmcoc3RybSk7XG4gIC8qIElmIGF2YWlsX291dCBpcyB6ZXJvLCB0aGUgYXBwbGljYXRpb24gd2lsbCBjYWxsIGRlZmxhdGUgYWdhaW5cbiAgICogdG8gZmx1c2ggdGhlIHJlc3QuXG4gICAqL1xuICBpZiAocy53cmFwID4gMCkgeyBzLndyYXAgPSAtcy53cmFwOyB9XG4gIC8qIHdyaXRlIHRoZSB0cmFpbGVyIG9ubHkgb25jZSEgKi9cbiAgcmV0dXJuIHMucGVuZGluZyAhPT0gMCA/IFpfT0sgOiBaX1NUUkVBTV9FTkQ7XG59XG5cbmZ1bmN0aW9uIGRlZmxhdGVFbmQoc3RybSkge1xuICB2YXIgc3RhdHVzO1xuXG4gIGlmICghc3RybS8qPT0gWl9OVUxMKi8gfHwgIXN0cm0uc3RhdGUvKj09IFpfTlVMTCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgc3RhdHVzID0gc3RybS5zdGF0ZS5zdGF0dXM7XG4gIGlmIChzdGF0dXMgIT09IElOSVRfU1RBVEUgJiZcbiAgICBzdGF0dXMgIT09IEVYVFJBX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBOQU1FX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBDT01NRU5UX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBIQ1JDX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBCVVNZX1NUQVRFICYmXG4gICAgc3RhdHVzICE9PSBGSU5JU0hfU1RBVEVcbiAgKSB7XG4gICAgcmV0dXJuIGVycihzdHJtLCBaX1NUUkVBTV9FUlJPUik7XG4gIH1cblxuICBzdHJtLnN0YXRlID0gbnVsbDtcblxuICByZXR1cm4gc3RhdHVzID09PSBCVVNZX1NUQVRFID8gZXJyKHN0cm0sIFpfREFUQV9FUlJPUikgOiBaX09LO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemVzIHRoZSBjb21wcmVzc2lvbiBkaWN0aW9uYXJ5IGZyb20gdGhlIGdpdmVuIGJ5dGVcbiAqIHNlcXVlbmNlIHdpdGhvdXQgcHJvZHVjaW5nIGFueSBjb21wcmVzc2VkIG91dHB1dC5cbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzO1xuICB2YXIgc3RyLCBuO1xuICB2YXIgd3JhcDtcbiAgdmFyIGF2YWlsO1xuICB2YXIgbmV4dDtcbiAgdmFyIGlucHV0O1xuICB2YXIgdG1wRGljdDtcblxuICBpZiAoIXN0cm0vKj09IFpfTlVMTCovIHx8ICFzdHJtLnN0YXRlLyo9PSBaX05VTEwqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHMgPSBzdHJtLnN0YXRlO1xuICB3cmFwID0gcy53cmFwO1xuXG4gIGlmICh3cmFwID09PSAyIHx8ICh3cmFwID09PSAxICYmIHMuc3RhdHVzICE9PSBJTklUX1NUQVRFKSB8fCBzLmxvb2thaGVhZCkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIC8qIHdoZW4gdXNpbmcgemxpYiB3cmFwcGVycywgY29tcHV0ZSBBZGxlci0zMiBmb3IgcHJvdmlkZWQgZGljdGlvbmFyeSAqL1xuICBpZiAod3JhcCA9PT0gMSkge1xuICAgIC8qIGFkbGVyMzIoc3RybS0+YWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIHN0cm0uYWRsZXIgPSBhZGxlcjMyKHN0cm0uYWRsZXIsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICB9XG5cbiAgcy53cmFwID0gMDsgICAvKiBhdm9pZCBjb21wdXRpbmcgQWRsZXItMzIgaW4gcmVhZF9idWYgKi9cblxuICAvKiBpZiBkaWN0aW9uYXJ5IHdvdWxkIGZpbGwgd2luZG93LCBqdXN0IHJlcGxhY2UgdGhlIGhpc3RvcnkgKi9cbiAgaWYgKGRpY3RMZW5ndGggPj0gcy53X3NpemUpIHtcbiAgICBpZiAod3JhcCA9PT0gMCkgeyAgICAgICAgICAgIC8qIGFscmVhZHkgZW1wdHkgb3RoZXJ3aXNlICovXG4gICAgICAvKioqIENMRUFSX0hBU0gocyk7ICoqKi9cbiAgICAgIHplcm8ocy5oZWFkKTsgLy8gRmlsbCB3aXRoIE5JTCAoPSAwKTtcbiAgICAgIHMuc3Ryc3RhcnQgPSAwO1xuICAgICAgcy5ibG9ja19zdGFydCA9IDA7XG4gICAgICBzLmluc2VydCA9IDA7XG4gICAgfVxuICAgIC8qIHVzZSB0aGUgdGFpbCAqL1xuICAgIC8vIGRpY3Rpb25hcnkgPSBkaWN0aW9uYXJ5LnNsaWNlKGRpY3RMZW5ndGggLSBzLndfc2l6ZSk7XG4gICAgdG1wRGljdCA9IG5ldyB1dGlscy5CdWY4KHMud19zaXplKTtcbiAgICB1dGlscy5hcnJheVNldCh0bXBEaWN0LCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoIC0gcy53X3NpemUsIHMud19zaXplLCAwKTtcbiAgICBkaWN0aW9uYXJ5ID0gdG1wRGljdDtcbiAgICBkaWN0TGVuZ3RoID0gcy53X3NpemU7XG4gIH1cbiAgLyogaW5zZXJ0IGRpY3Rpb25hcnkgaW50byB3aW5kb3cgYW5kIGhhc2ggKi9cbiAgYXZhaWwgPSBzdHJtLmF2YWlsX2luO1xuICBuZXh0ID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIHN0cm0uYXZhaWxfaW4gPSBkaWN0TGVuZ3RoO1xuICBzdHJtLm5leHRfaW4gPSAwO1xuICBzdHJtLmlucHV0ID0gZGljdGlvbmFyeTtcbiAgZmlsbF93aW5kb3cocyk7XG4gIHdoaWxlIChzLmxvb2thaGVhZCA+PSBNSU5fTUFUQ0gpIHtcbiAgICBzdHIgPSBzLnN0cnN0YXJ0O1xuICAgIG4gPSBzLmxvb2thaGVhZCAtIChNSU5fTUFUQ0ggLSAxKTtcbiAgICBkbyB7XG4gICAgICAvKiBVUERBVEVfSEFTSChzLCBzLT5pbnNfaCwgcy0+d2luZG93W3N0ciArIE1JTl9NQVRDSC0xXSk7ICovXG4gICAgICBzLmluc19oID0gKChzLmluc19oIDw8IHMuaGFzaF9zaGlmdCkgXiBzLndpbmRvd1tzdHIgKyBNSU5fTUFUQ0ggLSAxXSkgJiBzLmhhc2hfbWFzaztcblxuICAgICAgcy5wcmV2W3N0ciAmIHMud19tYXNrXSA9IHMuaGVhZFtzLmluc19oXTtcblxuICAgICAgcy5oZWFkW3MuaW5zX2hdID0gc3RyO1xuICAgICAgc3RyKys7XG4gICAgfSB3aGlsZSAoLS1uKTtcbiAgICBzLnN0cnN0YXJ0ID0gc3RyO1xuICAgIHMubG9va2FoZWFkID0gTUlOX01BVENIIC0gMTtcbiAgICBmaWxsX3dpbmRvdyhzKTtcbiAgfVxuICBzLnN0cnN0YXJ0ICs9IHMubG9va2FoZWFkO1xuICBzLmJsb2NrX3N0YXJ0ID0gcy5zdHJzdGFydDtcbiAgcy5pbnNlcnQgPSBzLmxvb2thaGVhZDtcbiAgcy5sb29rYWhlYWQgPSAwO1xuICBzLm1hdGNoX2xlbmd0aCA9IHMucHJldl9sZW5ndGggPSBNSU5fTUFUQ0ggLSAxO1xuICBzLm1hdGNoX2F2YWlsYWJsZSA9IDA7XG4gIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gIHN0cm0uaW5wdXQgPSBpbnB1dDtcbiAgc3RybS5hdmFpbF9pbiA9IGF2YWlsO1xuICBzLndyYXAgPSB3cmFwO1xuICByZXR1cm4gWl9PSztcbn1cblxuXG5leHBvcnRzLmRlZmxhdGVJbml0ID0gZGVmbGF0ZUluaXQ7XG5leHBvcnRzLmRlZmxhdGVJbml0MiA9IGRlZmxhdGVJbml0MjtcbmV4cG9ydHMuZGVmbGF0ZVJlc2V0ID0gZGVmbGF0ZVJlc2V0O1xuZXhwb3J0cy5kZWZsYXRlUmVzZXRLZWVwID0gZGVmbGF0ZVJlc2V0S2VlcDtcbmV4cG9ydHMuZGVmbGF0ZVNldEhlYWRlciA9IGRlZmxhdGVTZXRIZWFkZXI7XG5leHBvcnRzLmRlZmxhdGUgPSBkZWZsYXRlO1xuZXhwb3J0cy5kZWZsYXRlRW5kID0gZGVmbGF0ZUVuZDtcbmV4cG9ydHMuZGVmbGF0ZVNldERpY3Rpb25hcnkgPSBkZWZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuZGVmbGF0ZUluZm8gPSAncGFrbyBkZWZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5kZWZsYXRlQm91bmQgPSBkZWZsYXRlQm91bmQ7XG5leHBvcnRzLmRlZmxhdGVDb3B5ID0gZGVmbGF0ZUNvcHk7XG5leHBvcnRzLmRlZmxhdGVQYXJhbXMgPSBkZWZsYXRlUGFyYW1zO1xuZXhwb3J0cy5kZWZsYXRlUGVuZGluZyA9IGRlZmxhdGVQZW5kaW5nO1xuZXhwb3J0cy5kZWZsYXRlUHJpbWUgPSBkZWZsYXRlUHJpbWU7XG5leHBvcnRzLmRlZmxhdGVUdW5lID0gZGVmbGF0ZVR1bmU7XG4qL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8vIFNlZSBzdGF0ZSBkZWZzIGZyb20gaW5mbGF0ZS5qc1xudmFyIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgVFlQRSA9IDEyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIHR5cGUgYml0cywgaW5jbHVkaW5nIGxhc3QtZmxhZyBiaXQgKi9cblxuLypcbiAgIERlY29kZSBsaXRlcmFsLCBsZW5ndGgsIGFuZCBkaXN0YW5jZSBjb2RlcyBhbmQgd3JpdGUgb3V0IHRoZSByZXN1bHRpbmdcbiAgIGxpdGVyYWwgYW5kIG1hdGNoIGJ5dGVzIHVudGlsIGVpdGhlciBub3QgZW5vdWdoIGlucHV0IG9yIG91dHB1dCBpc1xuICAgYXZhaWxhYmxlLCBhbiBlbmQtb2YtYmxvY2sgaXMgZW5jb3VudGVyZWQsIG9yIGEgZGF0YSBlcnJvciBpcyBlbmNvdW50ZXJlZC5cbiAgIFdoZW4gbGFyZ2UgZW5vdWdoIGlucHV0IGFuZCBvdXRwdXQgYnVmZmVycyBhcmUgc3VwcGxpZWQgdG8gaW5mbGF0ZSgpLCBmb3JcbiAgIGV4YW1wbGUsIGEgMTZLIGlucHV0IGJ1ZmZlciBhbmQgYSA2NEsgb3V0cHV0IGJ1ZmZlciwgbW9yZSB0aGFuIDk1JSBvZiB0aGVcbiAgIGluZmxhdGUgZXhlY3V0aW9uIHRpbWUgaXMgc3BlbnQgaW4gdGhpcyByb3V0aW5lLlxuXG4gICBFbnRyeSBhc3N1bXB0aW9uczpcblxuICAgICAgICBzdGF0ZS5tb2RlID09PSBMRU5cbiAgICAgICAgc3RybS5hdmFpbF9pbiA+PSA2XG4gICAgICAgIHN0cm0uYXZhaWxfb3V0ID49IDI1OFxuICAgICAgICBzdGFydCA+PSBzdHJtLmF2YWlsX291dFxuICAgICAgICBzdGF0ZS5iaXRzIDwgOFxuXG4gICBPbiByZXR1cm4sIHN0YXRlLm1vZGUgaXMgb25lIG9mOlxuXG4gICAgICAgIExFTiAtLSByYW4gb3V0IG9mIGVub3VnaCBvdXRwdXQgc3BhY2Ugb3IgZW5vdWdoIGF2YWlsYWJsZSBpbnB1dFxuICAgICAgICBUWVBFIC0tIHJlYWNoZWQgZW5kIG9mIGJsb2NrIGNvZGUsIGluZmxhdGUoKSB0byBpbnRlcnByZXQgbmV4dCBibG9ja1xuICAgICAgICBCQUQgLS0gZXJyb3IgaW4gYmxvY2sgZGF0YVxuXG4gICBOb3RlczpcblxuICAgIC0gVGhlIG1heGltdW0gaW5wdXQgYml0cyB1c2VkIGJ5IGEgbGVuZ3RoL2Rpc3RhbmNlIHBhaXIgaXMgMTUgYml0cyBmb3IgdGhlXG4gICAgICBsZW5ndGggY29kZSwgNSBiaXRzIGZvciB0aGUgbGVuZ3RoIGV4dHJhLCAxNSBiaXRzIGZvciB0aGUgZGlzdGFuY2UgY29kZSxcbiAgICAgIGFuZCAxMyBiaXRzIGZvciB0aGUgZGlzdGFuY2UgZXh0cmEuICBUaGlzIHRvdGFscyA0OCBiaXRzLCBvciBzaXggYnl0ZXMuXG4gICAgICBUaGVyZWZvcmUgaWYgc3RybS5hdmFpbF9pbiA+PSA2LCB0aGVuIHRoZXJlIGlzIGVub3VnaCBpbnB1dCB0byBhdm9pZFxuICAgICAgY2hlY2tpbmcgZm9yIGF2YWlsYWJsZSBpbnB1dCB3aGlsZSBkZWNvZGluZy5cblxuICAgIC0gVGhlIG1heGltdW0gYnl0ZXMgdGhhdCBhIHNpbmdsZSBsZW5ndGgvZGlzdGFuY2UgcGFpciBjYW4gb3V0cHV0IGlzIDI1OFxuICAgICAgYnl0ZXMsIHdoaWNoIGlzIHRoZSBtYXhpbXVtIGxlbmd0aCB0aGF0IGNhbiBiZSBjb2RlZC4gIGluZmxhdGVfZmFzdCgpXG4gICAgICByZXF1aXJlcyBzdHJtLmF2YWlsX291dCA+PSAyNTggZm9yIGVhY2ggbG9vcCB0byBhdm9pZCBjaGVja2luZyBmb3JcbiAgICAgIG91dHB1dCBzcGFjZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbnZhciB1dGlscyAgICAgICAgID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG52YXIgYWRsZXIzMiAgICAgICA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xudmFyIGNyYzMyICAgICAgICAgPSByZXF1aXJlKCcuL2NyYzMyJyk7XG52YXIgaW5mbGF0ZV9mYXN0ICA9IHJlcXVpcmUoJy4vaW5mZmFzdCcpO1xudmFyIGluZmxhdGVfdGFibGUgPSByZXF1aXJlKCcuL2luZnRyZWVzJyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICAgIGNhc2UgSEVBRDpcbiAgICAgICAgaWYgKHN0YXRlLndyYXAgPT09IDApIHtcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKHN0YXRlLndyYXAgJiAyKSAmJiBob2xkID09PSAweDhiMWYpIHsgIC8qIGd6aXAgaGVhZGVyICovXG4gICAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG5cbiAgICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICAgIGhvbGQgPSAwO1xuICAgICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gRkxBR1M7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuZmxhZ3MgPSAwOyAgICAgICAgICAgLyogZXhwZWN0IHpsaWIgaGVhZGVyICovXG4gICAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3RhdGUud3JhcCAmIDEpIHx8ICAgLyogY2hlY2sgaWYgemxpYiBoZWFkZXIgYWxsb3dlZCAqL1xuICAgICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgaGVhZGVyIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoaG9sZCAmIDB4MGYpLypCSVRTKDQpKi8gIT09IFpfREVGTEFURUQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNDtcbiAgICAgICAgYml0cyAtPSA0O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIGxlbiA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDg7XG4gICAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICAgIHN0YXRlLndiaXRzID0gbGVuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCB3aW5kb3cgc2l6ZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5kbWF4ID0gMSA8PCBsZW47XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDEvKmFkbGVyMzIoMEwsIFpfTlVMTCwgMCkqLztcbiAgICAgICAgc3RhdGUubW9kZSA9IGhvbGQgJiAweDIwMCA/IERJQ1RJRCA6IFRZUEU7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRkxBR1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5mbGFncyA9IGhvbGQ7XG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gY29tcHJlc3Npb24gbWV0aG9kJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4ZTAwMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGV4dCA9ICgoaG9sZCA+PiA4KSAmIDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRJTUU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgIGhidWZbM10gPSAoaG9sZCA+Pj4gMjQpICYgMHhmZjtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCA0LCAwKTtcbiAgICAgICAgICAvLz09PVxuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgT1M6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgICBzdGF0ZS5oZWFkLm9zID0gKGhvbGQgPj4gOCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYTEVOO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYTEVOOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbGVuID0gaG9sZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbnVsbC8qWl9OVUxMKi87XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIEVYVFJBOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgIGlmIChjb3B5ID4gaGF2ZSkgeyBjb3B5ID0gaGF2ZTsgfVxuICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5oZWFkLmV4dHJhX2xlbiAtIHN0YXRlLmxlbmd0aDtcbiAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIHVudHlwZWQgYXJyYXkgZm9yIG1vcmUgY29udmVuaWVudCBwcm9jZXNzaW5nIGxhdGVyXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG5ldyBBcnJheShzdGF0ZS5oZWFkLmV4dHJhX2xlbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdXRpbHMuYXJyYXlTZXQoXG4gICAgICAgICAgICAgICAgc3RhdGUuaGVhZC5leHRyYSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgICAgIC8vIGV4dHJhIGZpZWxkIGlzIGxpbWl0ZWQgdG8gNjU1MzYgYnl0ZXNcbiAgICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICAgIGNvcHksXG4gICAgICAgICAgICAgICAgLypsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gPyBzdGF0ZS5oZWFkLmV4dHJhX21heCA6IGNvcHksKi9cbiAgICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgLy96bWVtY3B5KHN0YXRlLmhlYWQuZXh0cmEgKyBsZW4sIG5leHQsXG4gICAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgICAvLyAgICAgICAgc3RhdGUuaGVhZC5leHRyYV9tYXggLSBsZW4gOiBjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTkFNRTtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOQU1FOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA4MDApIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAvLyBUT0RPOiAyIG9yIDEgYnl0ZXM/XG4gICAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGVhZCAmJiBsZW4gJiZcbiAgICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdGUuaGVhZCkge1xuICAgICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09NTUVOVDpcbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgY29weSA9IDA7XG4gICAgICAgICAgZG8ge1xuICAgICAgICAgICAgbGVuID0gaW5wdXRbbmV4dCArIGNvcHkrK107XG4gICAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgICAgKHN0YXRlLmxlbmd0aCA8IDY1NTM2IC8qc3RhdGUuaGVhZC5jb21tX21heCovKSkge1xuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmNvbW1lbnQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gd2hpbGUgKGxlbiAmJiBjb3B5IDwgaGF2ZSk7XG4gICAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgaWYgKGxlbikgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgICAgc3RhdGUuaGVhZC5jb21tZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBIQ1JDOlxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCAxNikge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdoZWFkZXIgY3JjIG1pc21hdGNoJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmhjcmMgPSAoKHN0YXRlLmZsYWdzID4+IDkpICYgMSk7XG4gICAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIERJQ1RJRDpcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IHpzd2FwMzIoaG9sZCk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gRElDVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBESUNUOlxuICAgICAgICBpZiAoc3RhdGUuaGF2ZWRpY3QgPT09IDApIHtcbiAgICAgICAgICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gICAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX291dCA9IGxlZnQ7XG4gICAgICAgICAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgICBzdGF0ZS5ob2xkID0gaG9sZDtcbiAgICAgICAgICBzdGF0ZS5iaXRzID0gYml0cztcbiAgICAgICAgICAvLy0tLVxuICAgICAgICAgIHJldHVybiBaX05FRURfRElDVDtcbiAgICAgICAgfVxuICAgICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIFRZUEU6XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9CTE9DSyB8fCBmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBUWVBFRE86XG4gICAgICAgIGlmIChzdGF0ZS5sYXN0KSB7XG4gICAgICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sYXN0ID0gKGhvbGQgJiAweDAxKS8qQklUUygxKSovO1xuICAgICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gMTtcbiAgICAgICAgYml0cyAtPSAxO1xuICAgICAgICAvLy0tLS8vXG5cbiAgICAgICAgc3dpdGNoICgoaG9sZCAmIDB4MDMpLypCSVRTKDIpKi8pIHtcbiAgICAgICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIHN0b3JlZCBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTogICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGZpeGVkIGJsb2NrICovXG4gICAgICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBmaXhlZCBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgZHluYW1pYyBjb2RlcyBibG9jayVzXFxuXCIsXG4gICAgICAgICAgICAvLyAgICAgICAgc3RhdGUubGFzdCA/IFwiIChsYXN0KVwiIDogXCJcIikpO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU1RPUkVEOlxuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vIC8qIGdvIHRvIGJ5dGUgYm91bmRhcnkgKi9cbiAgICAgICAgaG9sZCA+Pj49IGJpdHMgJiA3O1xuICAgICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoKGhvbGQgJiAweGZmZmYpICE9PSAoKGhvbGQgPj4+IDE2KSBeIDB4ZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIHN0b3JlZCBibG9jayBsZW5ndGhzJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGxlbmd0aCAldVxcblwiLFxuICAgICAgICAvLyAgICAgICAgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09QWV87XG4gICAgICAgIGlmIChmbHVzaCA9PT0gWl9UUkVFUykgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBDT1BZXzpcbiAgICAgICAgc3RhdGUubW9kZSA9IENPUFk7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09QWTpcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgICBpZiAoY29weSA+IGhhdmUpIHsgY29weSA9IGhhdmU7IH1cbiAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAvLy0tLSB6bWVtY3B5KHB1dCwgbmV4dCwgY29weSk7IC0tLVxuICAgICAgICAgIHV0aWxzLmFycmF5U2V0KG91dHB1dCwgaW5wdXQsIG5leHQsIGNvcHksIHB1dCk7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIGhhdmUgLT0gY29weTtcbiAgICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICAgIHB1dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgc3RvcmVkIGVuZFxcblwiKSk7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVEFCTEU6XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgICAgd2hpbGUgKGJpdHMgPCAxNCkge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5ubGVuID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMjU3O1xuICAgICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gNTtcbiAgICAgICAgYml0cyAtPSA1O1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLm5kaXN0ID0gKGhvbGQgJiAweDFmKS8qQklUUyg1KSovICsgMTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoNSkgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICAgIGJpdHMgLT0gNTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAgIC8vLS0tIERST1BCSVRTKDQpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgICBiaXRzIC09IDQ7XG4gICAgICAgIC8vLS0tLy9cbi8vI2lmbmRlZiBQS1pJUF9CVUdfV09SS0FST1VORFxuICAgICAgICBpZiAoc3RhdGUubmxlbiA+IDI4NiB8fCBzdGF0ZS5uZGlzdCA+IDMwKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgdGFibGUgc2l6ZXMgb2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5oYXZlID0gMDtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOTEVOUzpcbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMykge1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAzO1xuICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vc3RhdGUubmV4dCA9IHN0YXRlLmNvZGVzO1xuICAgICAgICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuICAgICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgICAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5bjtcbiAgICAgICAgc3RhdGUubGVuYml0cyA9IDc7XG5cbiAgICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgICByZXQgPSBpbmZsYXRlX3RhYmxlKENPREVTLCBzdGF0ZS5sZW5zLCAwLCAxOSwgc3RhdGUubGVuY29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSBsZW5ndGhzIHNldCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIGNvZGUgbGVuZ3RocyBva1xcblwiKSk7XG4gICAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ09ERUxFTlM7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICAgIHdoaWxlIChzdGF0ZS5oYXZlIDwgc3RhdGUubmxlbiArIHN0YXRlLm5kaXN0KSB7XG4gICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgc3RhdGUubGVuc1tzdGF0ZS5oYXZlKytdID0gaGVyZV92YWw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhlcmVfdmFsID09PSAxNikge1xuICAgICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgICAgbiA9IGhlcmVfYml0cyArIDI7XG4gICAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdCc7XG4gICAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDMpOy8vQklUUygyKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMikgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaGVyZV92YWwgPT09IDE3KSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDMpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDMgKyAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgIC8vPT09IE5FRURCSVRTKGhlcmUuYml0cyArIDcpO1xuICAgICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgICAgY29weSA9IDExICsgKGhvbGQgJiAweDdmKTsvL0JJVFMoNyk7XG4gICAgICAgICAgICAgIC8vLS0tIERST1BCSVRTKDcpIC0tLS8vXG4gICAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgICBiaXRzIC09IDc7XG4gICAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGF0ZS5oYXZlICsgY29weSA+IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICAgIHN0YXRlLmxlbnNbc3RhdGUuaGF2ZSsrXSA9IGxlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKiBoYW5kbGUgZXJyb3IgYnJlYWtzIGluIHdoaWxlICovXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgICAvKiBjaGVjayBmb3IgZW5kLW9mLWJsb2NrIGNvZGUgKGJldHRlciBoYXZlIG9uZSkgKi9cbiAgICAgICAgaWYgKHN0YXRlLmxlbnNbMjU2XSA9PT0gMCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8qIGJ1aWxkIGNvZGUgdGFibGVzIC0tIG5vdGU6IGRvIG5vdCBjaGFuZ2UgdGhlIGxlbmJpdHMgb3IgZGlzdGJpdHNcbiAgICAgICAgICAgdmFsdWVzIGhlcmUgKDkgYW5kIDYpIHdpdGhvdXQgcmVhZGluZyB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSA5O1xuXG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmxlbmJpdHMgfTtcbiAgICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgICAgLy8gV2UgaGF2ZSBzZXBhcmF0ZSB0YWJsZXMgJiBubyBwb2ludGVycy4gMiBjb21tZW50ZWQgbGluZXMgYmVsb3cgbm90IG5lZWRlZC5cbiAgICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAgIC8vIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IDY7XG4gICAgICAgIC8vc3RhdGUuZGlzdGNvZGUuY29weShzdGF0ZS5jb2Rlcyk7XG4gICAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgICBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLmRpc3RkeW47XG4gICAgICAgIG9wdHMgPSB7IGJpdHM6IHN0YXRlLmRpc3RiaXRzIH07XG4gICAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAgIC8vIHN0YXRlLm5leHRfaW5kZXggPSBvcHRzLnRhYmxlX2luZGV4O1xuICAgICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgICAgLy8gc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5uZXh0O1xuXG4gICAgICAgIGlmIChyZXQpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgJ2luZmxhdGU6ICAgICAgIGNvZGVzIG9rXFxuJykpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOXztcbiAgICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIExFTl86XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOOlxuICAgICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgICAgLy8tLS0gUkVTVE9SRSgpIC0tLVxuICAgICAgICAgIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICAgIHN0cm0ubmV4dF9pbiA9IG5leHQ7XG4gICAgICAgICAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gICAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgICAgc3RhdGUuYml0cyA9IGJpdHM7XG4gICAgICAgICAgLy8tLS1cbiAgICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgICAgLy8tLS0gTE9BRCgpIC0tLVxuICAgICAgICAgIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gICAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgICAgbGVmdCA9IHN0cm0uYXZhaWxfb3V0O1xuICAgICAgICAgIG5leHQgPSBzdHJtLm5leHRfaW47XG4gICAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICAgIGhhdmUgPSBzdHJtLmF2YWlsX2luO1xuICAgICAgICAgIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICAgICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAgIC8vLS0tXG5cbiAgICAgICAgICBpZiAoc3RhdGUubW9kZSA9PT0gVFlQRSkge1xuICAgICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5iYWNrID0gMDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoaGVyZV9iaXRzIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICAgIGxhc3RfYml0cyA9IGhlcmVfYml0cztcbiAgICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2xhc3RfdmFsICtcbiAgICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgICAgLy8tLS0gUFVMTEJZVEUoKSAtLS0vL1xuICAgICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgICAgYml0cyAtPSBsYXN0X2JpdHM7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICAgIHN0YXRlLmxlbmd0aCA9IGhlcmVfdmFsO1xuICAgICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBoZXJlLnZhbCA+PSAweDIwICYmIGhlcmUudmFsIDwgMHg3ZiA/XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsICclYydcXG5cIiA6XG4gICAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBMSVQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiAzMikge1xuICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZW5kIG9mIGJsb2NrXFxuXCIpKTtcbiAgICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IFRZUEU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTkVYVDtcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBMRU5FWFQ6XG4gICAgICAgIGlmIChzdGF0ZS5leHRyYSkge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgc3RhdGUubGVuZ3RoICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IHN0YXRlLmV4dHJhO1xuICAgICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIHN0YXRlLmJhY2sgKz0gc3RhdGUuZXh0cmE7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICAgIHN0YXRlLndhcyA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1Q7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgICAgbGFzdF9vcCA9IGhlcmVfb3A7XG4gICAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBoZXJlID0gc3RhdGUuZGlzdGNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICAgIGlmICgobGFzdF9iaXRzICsgaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgICAgaG9sZCA+Pj49IGxhc3RfYml0cztcbiAgICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBsYXN0X2JpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGhlcmVfYml0cztcbiAgICAgICAgaWYgKGhlcmVfb3AgJiA2NCkge1xuICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5vZmZzZXQgPSBoZXJlX3ZhbDtcbiAgICAgICAgc3RhdGUuZXh0cmEgPSAoaGVyZV9vcCkgJiAxNTtcbiAgICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgRElTVEVYVDpcbiAgICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICAgIG4gPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgICBzdGF0ZS5vZmZzZXQgKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUyhzdGF0ZS5leHRyYSkgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgfVxuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IHN0YXRlLmRtYXgpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuLy8jZW5kaWZcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBkaXN0YW5jZSAldVxcblwiLCBzdGF0ZS5vZmZzZXQpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IE1BVENIO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIE1BVENIOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gY29weSkgeyAgICAgICAgIC8qIGNvcHkgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICBjb3B5ID0gc3RhdGUub2Zmc2V0IC0gY29weTtcbiAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2FuZSkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuLy8gKCEpIFRoaXMgYmxvY2sgaXMgZGlzYWJsZWQgaW4gemxpYiBkZWZhdWx0cyxcbi8vIGRvbid0IGVuYWJsZSBpdCBmb3IgYmluYXJ5IGNvbXBhdGliaWxpdHlcbi8vI2lmZGVmIElORkxBVEVfQUxMT1dfSU5WQUxJRF9ESVNUQU5DRV9UT09GQVJfQVJSUlxuLy8gICAgICAgICAgVHJhY2UoKHN0ZGVyciwgXCJpbmZsYXRlLmMgdG9vIGZhclxcblwiKSk7XG4vLyAgICAgICAgICBjb3B5IC09IHN0YXRlLndoYXZlO1xuLy8gICAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuLy8gICAgICAgICAgaWYgKGNvcHkgPiBsZWZ0KSB7IGNvcHkgPSBsZWZ0OyB9XG4vLyAgICAgICAgICBsZWZ0IC09IGNvcHk7XG4vLyAgICAgICAgICBzdGF0ZS5sZW5ndGggLT0gY29weTtcbi8vICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IDA7XG4vLyAgICAgICAgICB9IHdoaWxlICgtLWNvcHkpO1xuLy8gICAgICAgICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgeyBzdGF0ZS5tb2RlID0gTEVOOyB9XG4vLyAgICAgICAgICBicmVhaztcbi8vI2VuZGlmXG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUud25leHQpIHtcbiAgICAgICAgICAgIGNvcHkgLT0gc3RhdGUud25leHQ7XG4gICAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb3B5ID4gc3RhdGUubGVuZ3RoKSB7IGNvcHkgPSBzdGF0ZS5sZW5ndGg7IH1cbiAgICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBjb3B5IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgICAgZnJvbSA9IHB1dCAtIHN0YXRlLm9mZnNldDtcbiAgICAgICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBsZWZ0IC09IGNvcHk7XG4gICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICBkbyB7XG4gICAgICAgICAgb3V0cHV0W3B1dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHsgc3RhdGUubW9kZSA9IExFTjsgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTElUOlxuICAgICAgICBpZiAobGVmdCA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgb3V0cHV0W3B1dCsrXSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgbGVmdC0tO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTEVOO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ0hFQ0s6XG4gICAgICAgIGlmIChzdGF0ZS53cmFwKSB7XG4gICAgICAgICAgLy89PT0gTkVFREJJVFMoMzIpO1xuICAgICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgLy8gVXNlICd8JyBpbnN0ZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgICBob2xkIHw9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIF9vdXQgLT0gbGVmdDtcbiAgICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICAgIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gICAgICAgICAgaWYgKF9vdXQpIHtcbiAgICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgICAgLypVUERBVEUoc3RhdGUuY2hlY2ssIHB1dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAgICAgICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHB1dCAtIF9vdXQpKTtcblxuICAgICAgICAgIH1cbiAgICAgICAgICBfb3V0ID0gbGVmdDtcbiAgICAgICAgICAvLyBOQjogY3JjMzIgc3RvcmVkIGFzIHNpZ25lZCAzMi1iaXQgaW50LCB6c3dhcDMyIHJldHVybnMgc2lnbmVkIHRvb1xuICAgICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgZGF0YSBjaGVjayc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgICAgYml0cyA9IDA7XG4gICAgICAgICAgLy89PT0vL1xuICAgICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBMRU5HVEg7XG4gICAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgTEVOR1RIOlxuICAgICAgICBpZiAoc3RhdGUud3JhcCAmJiBzdGF0ZS5mbGFncykge1xuICAgICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgICB3aGlsZSAoYml0cyA8IDMyKSB7XG4gICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgaWYgKGhvbGQgIT09IChzdGF0ZS50b3RhbCAmIDB4ZmZmZmZmZmYpKSB7XG4gICAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgICBob2xkID0gMDtcbiAgICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGxlbmd0aCBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1vZGUgPSBET05FO1xuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlIERPTkU6XG4gICAgICAgIHJldCA9IFpfU1RSRUFNX0VORDtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBCQUQ6XG4gICAgICAgIHJldCA9IFpfREFUQV9FUlJPUjtcbiAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgY2FzZSBNRU06XG4gICAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICAgIGNhc2UgU1lOQzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICAgIH1cbiAgfVxuXG4gIC8vIGluZl9sZWF2ZSA8LSBoZXJlIGlzIHJlYWwgcGxhY2UgZm9yIFwiZ290byBpbmZfbGVhdmVcIiwgZW11bGF0ZWQgdmlhIFwiYnJlYWsgaW5mX2xlYXZlXCJcblxuICAvKlxuICAgICBSZXR1cm4gZnJvbSBpbmZsYXRlKCksIHVwZGF0aW5nIHRoZSB0b3RhbCBjb3VudHMgYW5kIHRoZSBjaGVjayB2YWx1ZS5cbiAgICAgSWYgdGhlcmUgd2FzIG5vIHByb2dyZXNzIGR1cmluZyB0aGUgaW5mbGF0ZSgpIGNhbGwsIHJldHVybiBhIGJ1ZmZlclxuICAgICBlcnJvci4gIENhbGwgdXBkYXRld2luZG93KCkgdG8gY3JlYXRlIGFuZC9vciB1cGRhdGUgdGhlIHdpbmRvdyBzdGF0ZS5cbiAgICAgTm90ZTogYSBtZW1vcnkgZXJyb3IgZnJvbSBpbmZsYXRlKCkgaXMgbm9uLXJlY292ZXJhYmxlLlxuICAgKi9cblxuICAvLy0tLSBSRVNUT1JFKCkgLS0tXG4gIHN0cm0ubmV4dF9vdXQgPSBwdXQ7XG4gIHN0cm0uYXZhaWxfb3V0ID0gbGVmdDtcbiAgc3RybS5uZXh0X2luID0gbmV4dDtcbiAgc3RybS5hdmFpbF9pbiA9IGhhdmU7XG4gIHN0YXRlLmhvbGQgPSBob2xkO1xuICBzdGF0ZS5iaXRzID0gYml0cztcbiAgLy8tLS1cblxuICBpZiAoc3RhdGUud3NpemUgfHwgKF9vdXQgIT09IHN0cm0uYXZhaWxfb3V0ICYmIHN0YXRlLm1vZGUgPCBCQUQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA8IENIRUNLIHx8IGZsdXNoICE9PSBaX0ZJTklTSCkpKSB7XG4gICAgaWYgKHVwZGF0ZXdpbmRvdyhzdHJtLCBzdHJtLm91dHB1dCwgc3RybS5uZXh0X291dCwgX291dCAtIHN0cm0uYXZhaWxfb3V0KSkge1xuICAgICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgX2luIC09IHN0cm0uYXZhaWxfaW47XG4gIF9vdXQgLT0gc3RybS5hdmFpbF9vdXQ7XG4gIHN0cm0udG90YWxfaW4gKz0gX2luO1xuICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICBpZiAoc3RhdGUud3JhcCAmJiBfb3V0KSB7XG4gICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0gLypVUERBVEUoc3RhdGUuY2hlY2ssIHN0cm0ubmV4dF9vdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgKHN0YXRlLmZsYWdzID8gY3JjMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgc3RybS5uZXh0X291dCAtIF9vdXQpIDogYWRsZXIzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkpO1xuICB9XG4gIHN0cm0uZGF0YV90eXBlID0gc3RhdGUuYml0cyArIChzdGF0ZS5sYXN0ID8gNjQgOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBUWVBFID8gMTI4IDogMCkgK1xuICAgICAgICAgICAgICAgICAgICAoc3RhdGUubW9kZSA9PT0gTEVOXyB8fCBzdGF0ZS5tb2RlID09PSBDT1BZXyA/IDI1NiA6IDApO1xuICBpZiAoKChfaW4gPT09IDAgJiYgX291dCA9PT0gMCkgfHwgZmx1c2ggPT09IFpfRklOSVNIKSAmJiByZXQgPT09IFpfT0spIHtcbiAgICByZXQgPSBaX0JVRl9FUlJPUjtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlRW5kKHN0cm0pIHtcblxuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUgLyp8fCBzdHJtLT56ZnJlZSA9PSAoZnJlZV9mdW5jKTAqLykge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIGlmIChzdGF0ZS53aW5kb3cpIHtcbiAgICBzdGF0ZS53aW5kb3cgPSBudWxsO1xuICB9XG4gIHN0cm0uc3RhdGUgPSBudWxsO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZUdldEhlYWRlcihzdHJtLCBoZWFkKSB7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gfHwgIXN0cm0uc3RhdGUpIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKChzdGF0ZS53cmFwICYgMikgPT09IDApIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG5cbiAgLyogc2F2ZSBoZWFkZXIgc3RydWN0dXJlICovXG4gIHN0YXRlLmhlYWQgPSBoZWFkO1xuICBoZWFkLmRvbmUgPSBmYWxzZTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVTZXREaWN0aW9uYXJ5KHN0cm0sIGRpY3Rpb25hcnkpIHtcbiAgdmFyIGRpY3RMZW5ndGggPSBkaWN0aW9uYXJ5Lmxlbmd0aDtcblxuICB2YXIgc3RhdGU7XG4gIHZhciBkaWN0aWQ7XG4gIHZhciByZXQ7XG5cbiAgLyogY2hlY2sgc3RhdGUgKi9cbiAgaWYgKCFzdHJtIC8qID09IFpfTlVMTCAqLyB8fCAhc3RybS5zdGF0ZSAvKiA9PSBaX05VTEwgKi8pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcblxuICBpZiAoc3RhdGUud3JhcCAhPT0gMCAmJiBzdGF0ZS5tb2RlICE9PSBESUNUKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGNvcnJlY3QgZGljdGlvbmFyeSBpZGVudGlmaWVyICovXG4gIGlmIChzdGF0ZS5tb2RlID09PSBESUNUKSB7XG4gICAgZGljdGlkID0gMTsgLyogYWRsZXIzMigwLCBudWxsLCAwKSovXG4gICAgLyogZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgpOyAqL1xuICAgIGRpY3RpZCA9IGFkbGVyMzIoZGljdGlkLCBkaWN0aW9uYXJ5LCBkaWN0TGVuZ3RoLCAwKTtcbiAgICBpZiAoZGljdGlkICE9PSBzdGF0ZS5jaGVjaykge1xuICAgICAgcmV0dXJuIFpfREFUQV9FUlJPUjtcbiAgICB9XG4gIH1cbiAgLyogY29weSBkaWN0aW9uYXJ5IHRvIHdpbmRvdyB1c2luZyB1cGRhdGV3aW5kb3coKSwgd2hpY2ggd2lsbCBhbWVuZCB0aGVcbiAgIGV4aXN0aW5nIGRpY3Rpb25hcnkgaWYgYXBwcm9wcmlhdGUgKi9cbiAgcmV0ID0gdXBkYXRld2luZG93KHN0cm0sIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIGRpY3RMZW5ndGgpO1xuICBpZiAocmV0KSB7XG4gICAgc3RhdGUubW9kZSA9IE1FTTtcbiAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gIH1cbiAgc3RhdGUuaGF2ZWRpY3QgPSAxO1xuICAvLyBUcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgIGRpY3Rpb25hcnkgc2V0XFxuXCIpKTtcbiAgcmV0dXJuIFpfT0s7XG59XG5cbmV4cG9ydHMuaW5mbGF0ZVJlc2V0ID0gaW5mbGF0ZVJlc2V0O1xuZXhwb3J0cy5pbmZsYXRlUmVzZXQyID0gaW5mbGF0ZVJlc2V0MjtcbmV4cG9ydHMuaW5mbGF0ZVJlc2V0S2VlcCA9IGluZmxhdGVSZXNldEtlZXA7XG5leHBvcnRzLmluZmxhdGVJbml0ID0gaW5mbGF0ZUluaXQ7XG5leHBvcnRzLmluZmxhdGVJbml0MiA9IGluZmxhdGVJbml0MjtcbmV4cG9ydHMuaW5mbGF0ZSA9IGluZmxhdGU7XG5leHBvcnRzLmluZmxhdGVFbmQgPSBpbmZsYXRlRW5kO1xuZXhwb3J0cy5pbmZsYXRlR2V0SGVhZGVyID0gaW5mbGF0ZUdldEhlYWRlcjtcbmV4cG9ydHMuaW5mbGF0ZVNldERpY3Rpb25hcnkgPSBpbmZsYXRlU2V0RGljdGlvbmFyeTtcbmV4cG9ydHMuaW5mbGF0ZUluZm8gPSAncGFrbyBpbmZsYXRlIChmcm9tIE5vZGVjYSBwcm9qZWN0KSc7XG5cbi8qIE5vdCBpbXBsZW1lbnRlZFxuZXhwb3J0cy5pbmZsYXRlQ29weSA9IGluZmxhdGVDb3B5O1xuZXhwb3J0cy5pbmZsYXRlR2V0RGljdGlvbmFyeSA9IGluZmxhdGVHZXREaWN0aW9uYXJ5O1xuZXhwb3J0cy5pbmZsYXRlTWFyayA9IGluZmxhdGVNYXJrO1xuZXhwb3J0cy5pbmZsYXRlUHJpbWUgPSBpbmZsYXRlUHJpbWU7XG5leHBvcnRzLmluZmxhdGVTeW5jID0gaW5mbGF0ZVN5bmM7XG5leHBvcnRzLmluZmxhdGVTeW5jUG9pbnQgPSBpbmZsYXRlU3luY1BvaW50O1xuZXhwb3J0cy5pbmZsYXRlVW5kZXJtaW5lID0gaW5mbGF0ZVVuZGVybWluZTtcbiovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMvY29tbW9uJyk7XG5cbnZhciBNQVhCSVRTID0gMTU7XG52YXIgRU5PVUdIX0xFTlMgPSA4NTI7XG52YXIgRU5PVUdIX0RJU1RTID0gNTkyO1xuLy92YXIgRU5PVUdIID0gKEVOT1VHSF9MRU5TK0VOT1VHSF9ESVNUUyk7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG52YXIgbGJhc2UgPSBbIC8qIExlbmd0aCBjb2RlcyAyNTcuLjI4NSBiYXNlICovXG4gIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTMsIDE1LCAxNywgMTksIDIzLCAyNywgMzEsXG4gIDM1LCA0MywgNTEsIDU5LCA2NywgODMsIDk5LCAxMTUsIDEzMSwgMTYzLCAxOTUsIDIyNywgMjU4LCAwLCAwXG5dO1xuXG52YXIgbGV4dCA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxNywgMTcsIDE4LCAxOCwgMTgsIDE4LFxuICAxOSwgMTksIDE5LCAxOSwgMjAsIDIwLCAyMCwgMjAsIDIxLCAyMSwgMjEsIDIxLCAxNiwgNzIsIDc4XG5dO1xuXG52YXIgZGJhc2UgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGJhc2UgKi9cbiAgMSwgMiwgMywgNCwgNSwgNywgOSwgMTMsIDE3LCAyNSwgMzMsIDQ5LCA2NSwgOTcsIDEyOSwgMTkzLFxuICAyNTcsIDM4NSwgNTEzLCA3NjksIDEwMjUsIDE1MzcsIDIwNDksIDMwNzMsIDQwOTcsIDYxNDUsXG4gIDgxOTMsIDEyMjg5LCAxNjM4NSwgMjQ1NzcsIDAsIDBcbl07XG5cbnZhciBkZXh0ID0gWyAvKiBEaXN0YW5jZSBjb2RlcyAwLi4yOSBleHRyYSAqL1xuICAxNiwgMTYsIDE2LCAxNiwgMTcsIDE3LCAxOCwgMTgsIDE5LCAxOSwgMjAsIDIwLCAyMSwgMjEsIDIyLCAyMixcbiAgMjMsIDIzLCAyNCwgMjQsIDI1LCAyNSwgMjYsIDI2LCAyNywgMjcsXG4gIDI4LCAyOCwgMjksIDI5LCA2NCwgNjRcbl07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIDI6ICAgICAgJ25lZWQgZGljdGlvbmFyeScsICAgICAvKiBaX05FRURfRElDVCAgICAgICAyICAqL1xuICAxOiAgICAgICdzdHJlYW0gZW5kJywgICAgICAgICAgLyogWl9TVFJFQU1fRU5EICAgICAgMSAgKi9cbiAgMDogICAgICAnJywgICAgICAgICAgICAgICAgICAgIC8qIFpfT0sgICAgICAgICAgICAgIDAgICovXG4gICctMSc6ICAgJ2ZpbGUgZXJyb3InLCAgICAgICAgICAvKiBaX0VSUk5PICAgICAgICAgKC0xKSAqL1xuICAnLTInOiAgICdzdHJlYW0gZXJyb3InLCAgICAgICAgLyogWl9TVFJFQU1fRVJST1IgICgtMikgKi9cbiAgJy0zJzogICAnZGF0YSBlcnJvcicsICAgICAgICAgIC8qIFpfREFUQV9FUlJPUiAgICAoLTMpICovXG4gICctNCc6ICAgJ2luc3VmZmljaWVudCBtZW1vcnknLCAvKiBaX01FTV9FUlJPUiAgICAgKC00KSAqL1xuICAnLTUnOiAgICdidWZmZXIgZXJyb3InLCAgICAgICAgLyogWl9CVUZfRVJST1IgICAgICgtNSkgKi9cbiAgJy02JzogICAnaW5jb21wYXRpYmxlIHZlcnNpb24nIC8qIFpfVkVSU0lPTl9FUlJPUiAoLTYpICovXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyAoQykgMTk5NS0yMDEzIEplYW4tbG91cCBHYWlsbHkgYW5kIE1hcmsgQWRsZXJcbi8vIChDKSAyMDE0LTIwMTcgVml0YWx5IFB1enJpbiBhbmQgQW5kcmV5IFR1cGl0c2luXG4vL1xuLy8gVGhpcyBzb2Z0d2FyZSBpcyBwcm92aWRlZCAnYXMtaXMnLCB3aXRob3V0IGFueSBleHByZXNzIG9yIGltcGxpZWRcbi8vIHdhcnJhbnR5LiBJbiBubyBldmVudCB3aWxsIHRoZSBhdXRob3JzIGJlIGhlbGQgbGlhYmxlIGZvciBhbnkgZGFtYWdlc1xuLy8gYXJpc2luZyBmcm9tIHRoZSB1c2Ugb2YgdGhpcyBzb2Z0d2FyZS5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGdyYW50ZWQgdG8gYW55b25lIHRvIHVzZSB0aGlzIHNvZnR3YXJlIGZvciBhbnkgcHVycG9zZSxcbi8vIGluY2x1ZGluZyBjb21tZXJjaWFsIGFwcGxpY2F0aW9ucywgYW5kIHRvIGFsdGVyIGl0IGFuZCByZWRpc3RyaWJ1dGUgaXRcbi8vIGZyZWVseSwgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIHJlc3RyaWN0aW9uczpcbi8vXG4vLyAxLiBUaGUgb3JpZ2luIG9mIHRoaXMgc29mdHdhcmUgbXVzdCBub3QgYmUgbWlzcmVwcmVzZW50ZWQ7IHlvdSBtdXN0IG5vdFxuLy8gICBjbGFpbSB0aGF0IHlvdSB3cm90ZSB0aGUgb3JpZ2luYWwgc29mdHdhcmUuIElmIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZVxuLy8gICBpbiBhIHByb2R1Y3QsIGFuIGFja25vd2xlZGdtZW50IGluIHRoZSBwcm9kdWN0IGRvY3VtZW50YXRpb24gd291bGQgYmVcbi8vICAgYXBwcmVjaWF0ZWQgYnV0IGlzIG5vdCByZXF1aXJlZC5cbi8vIDIuIEFsdGVyZWQgc291cmNlIHZlcnNpb25zIG11c3QgYmUgcGxhaW5seSBtYXJrZWQgYXMgc3VjaCwgYW5kIG11c3Qgbm90IGJlXG4vLyAgIG1pc3JlcHJlc2VudGVkIGFzIGJlaW5nIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS5cbi8vIDMuIFRoaXMgbm90aWNlIG1heSBub3QgYmUgcmVtb3ZlZCBvciBhbHRlcmVkIGZyb20gYW55IHNvdXJjZSBkaXN0cmlidXRpb24uXG5cbi8qIGVzbGludC1kaXNhYmxlIHNwYWNlLXVuYXJ5LW9wcyAqL1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscy9jb21tb24nKTtcblxuLyogUHVibGljIGNvbnN0YW50cyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuLy92YXIgWl9GSUxURVJFRCAgICAgICAgICA9IDE7XG4vL3ZhciBaX0hVRkZNQU5fT05MWSAgICAgID0gMjtcbi8vdmFyIFpfUkxFICAgICAgICAgICAgICAgPSAzO1xudmFyIFpfRklYRUQgICAgICAgICAgICAgICA9IDQ7XG4vL3ZhciBaX0RFRkFVTFRfU1RSQVRFR1kgID0gMDtcblxuLyogUG9zc2libGUgdmFsdWVzIG9mIHRoZSBkYXRhX3R5cGUgZmllbGQgKHRob3VnaCBzZWUgaW5mbGF0ZSgpKSAqL1xudmFyIFpfQklOQVJZICAgICAgICAgICAgICA9IDA7XG52YXIgWl9URVhUICAgICAgICAgICAgICAgID0gMTtcbi8vdmFyIFpfQVNDSUkgICAgICAgICAgICAgPSAxOyAvLyA9IFpfVEVYVFxudmFyIFpfVU5LTk9XTiAgICAgICAgICAgICA9IDI7XG5cbi8qPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG5cblxuZnVuY3Rpb24gemVybyhidWYpIHsgdmFyIGxlbiA9IGJ1Zi5sZW5ndGg7IHdoaWxlICgtLWxlbiA+PSAwKSB7IGJ1ZltsZW5dID0gMDsgfSB9XG5cbi8vIEZyb20genV0aWwuaFxuXG52YXIgU1RPUkVEX0JMT0NLID0gMDtcbnZhciBTVEFUSUNfVFJFRVMgPSAxO1xudmFyIERZTl9UUkVFUyAgICA9IDI7XG4vKiBUaGUgdGhyZWUga2luZHMgb2YgYmxvY2sgdHlwZSAqL1xuXG52YXIgTUlOX01BVENIICAgID0gMztcbnZhciBNQVhfTUFUQ0ggICAgPSAyNTg7XG4vKiBUaGUgbWluaW11bSBhbmQgbWF4aW11bSBtYXRjaCBsZW5ndGhzICovXG5cbi8vIEZyb20gZGVmbGF0ZS5oXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEludGVybmFsIGNvbXByZXNzaW9uIHN0YXRlLlxuICovXG5cbnZhciBMRU5HVEhfQ09ERVMgID0gMjk7XG4vKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGVzLCBub3QgY291bnRpbmcgdGhlIHNwZWNpYWwgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIExJVEVSQUxTICAgICAgPSAyNTY7XG4vKiBudW1iZXIgb2YgbGl0ZXJhbCBieXRlcyAwLi4yNTUgKi9cblxudmFyIExfQ09ERVMgICAgICAgPSBMSVRFUkFMUyArIDEgKyBMRU5HVEhfQ09ERVM7XG4vKiBudW1iZXIgb2YgTGl0ZXJhbCBvciBMZW5ndGggY29kZXMsIGluY2x1ZGluZyB0aGUgRU5EX0JMT0NLIGNvZGUgKi9cblxudmFyIERfQ09ERVMgICAgICAgPSAzMDtcbi8qIG51bWJlciBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuXG52YXIgQkxfQ09ERVMgICAgICA9IDE5O1xuLyogbnVtYmVyIG9mIGNvZGVzIHVzZWQgdG8gdHJhbnNmZXIgdGhlIGJpdCBsZW5ndGhzICovXG5cbnZhciBIRUFQX1NJWkUgICAgID0gMiAqIExfQ09ERVMgKyAxO1xuLyogbWF4aW11bSBoZWFwIHNpemUgKi9cblxudmFyIE1BWF9CSVRTICAgICAgPSAxNTtcbi8qIEFsbCBjb2RlcyBtdXN0IG5vdCBleGNlZWQgTUFYX0JJVFMgYml0cyAqL1xuXG52YXIgQnVmX3NpemUgICAgICA9IDE2O1xuLyogc2l6ZSBvZiBiaXQgYnVmZmVyIGluIGJpX2J1ZiAqL1xuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RhbnRzXG4gKi9cblxudmFyIE1BWF9CTF9CSVRTID0gNztcbi8qIEJpdCBsZW5ndGggY29kZXMgbXVzdCBub3QgZXhjZWVkIE1BWF9CTF9CSVRTIGJpdHMgKi9cblxudmFyIEVORF9CTE9DSyAgID0gMjU2O1xuLyogZW5kIG9mIGJsb2NrIGxpdGVyYWwgY29kZSAqL1xuXG52YXIgUkVQXzNfNiAgICAgPSAxNjtcbi8qIHJlcGVhdCBwcmV2aW91cyBiaXQgbGVuZ3RoIDMtNiB0aW1lcyAoMiBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfM18xMCAgID0gMTc7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAzLTEwIHRpbWVzICAoMyBiaXRzIG9mIHJlcGVhdCBjb3VudCkgKi9cblxudmFyIFJFUFpfMTFfMTM4ID0gMTg7XG4vKiByZXBlYXQgYSB6ZXJvIGxlbmd0aCAxMS0xMzggdGltZXMgICg3IGJpdHMgb2YgcmVwZWF0IGNvdW50KSAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nLGFycmF5LWJyYWNrZXQtc3BhY2luZyAqL1xudmFyIGV4dHJhX2xiaXRzID0gICAvKiBleHRyYSBiaXRzIGZvciBlYWNoIGxlbmd0aCBjb2RlICovXG4gIFswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDBdO1xuXG52YXIgZXh0cmFfZGJpdHMgPSAgIC8qIGV4dHJhIGJpdHMgZm9yIGVhY2ggZGlzdGFuY2UgY29kZSAqL1xuICBbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxM107XG5cbnZhciBleHRyYV9ibGJpdHMgPSAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBiaXQgbGVuZ3RoIGNvZGUgKi9cbiAgWzAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMCwwLDAsMiwzLDddO1xuXG52YXIgYmxfb3JkZXIgPVxuICBbMTYsMTcsMTgsMCw4LDcsOSw2LDEwLDUsMTEsNCwxMiwzLDEzLDIsMTQsMSwxNV07XG4vKiBlc2xpbnQtZW5hYmxlIGNvbW1hLXNwYWNpbmcsYXJyYXktYnJhY2tldC1zcGFjaW5nICovXG5cbi8qIFRoZSBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzIGFyZSBzZW50IGluIG9yZGVyIG9mIGRlY3JlYXNpbmdcbiAqIHByb2JhYmlsaXR5LCB0byBhdm9pZCB0cmFuc21pdHRpbmcgdGhlIGxlbmd0aHMgZm9yIHVudXNlZCBiaXQgbGVuZ3RoIGNvZGVzLlxuICovXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogTG9jYWwgZGF0YS4gVGhlc2UgYXJlIGluaXRpYWxpemVkIG9ubHkgb25jZS5cbiAqL1xuXG4vLyBXZSBwcmUtZmlsbCBhcnJheXMgd2l0aCAwIHRvIGF2b2lkIHVuaW5pdGlhbGl6ZWQgZ2Fwc1xuXG52YXIgRElTVF9DT0RFX0xFTiA9IDUxMjsgLyogc2VlIGRlZmluaXRpb24gb2YgYXJyYXkgZGlzdF9jb2RlIGJlbG93ICovXG5cbi8vICEhISEgVXNlIGZsYXQgYXJyYXkgaW5zdGVhZCBvZiBzdHJ1Y3R1cmUsIEZyZXEgPSBpKjIsIExlbiA9IGkqMisxXG52YXIgc3RhdGljX2x0cmVlICA9IG5ldyBBcnJheSgoTF9DT0RFUyArIDIpICogMik7XG56ZXJvKHN0YXRpY19sdHJlZSk7XG4vKiBUaGUgc3RhdGljIGxpdGVyYWwgdHJlZS4gU2luY2UgdGhlIGJpdCBsZW5ndGhzIGFyZSBpbXBvc2VkLCB0aGVyZSBpcyBub1xuICogbmVlZCBmb3IgdGhlIExfQ09ERVMgZXh0cmEgY29kZXMgdXNlZCBkdXJpbmcgaGVhcCBjb25zdHJ1Y3Rpb24uIEhvd2V2ZXJcbiAqIFRoZSBjb2RlcyAyODYgYW5kIDI4NyBhcmUgbmVlZGVkIHRvIGJ1aWxkIGEgY2Fub25pY2FsIHRyZWUgKHNlZSBfdHJfaW5pdFxuICogYmVsb3cpLlxuICovXG5cbnZhciBzdGF0aWNfZHRyZWUgID0gbmV3IEFycmF5KERfQ09ERVMgKiAyKTtcbnplcm8oc3RhdGljX2R0cmVlKTtcbi8qIFRoZSBzdGF0aWMgZGlzdGFuY2UgdHJlZS4gKEFjdHVhbGx5IGEgdHJpdmlhbCB0cmVlIHNpbmNlIGFsbCBjb2RlcyB1c2VcbiAqIDUgYml0cy4pXG4gKi9cblxudmFyIF9kaXN0X2NvZGUgICAgPSBuZXcgQXJyYXkoRElTVF9DT0RFX0xFTik7XG56ZXJvKF9kaXN0X2NvZGUpO1xuLyogRGlzdGFuY2UgY29kZXMuIFRoZSBmaXJzdCAyNTYgdmFsdWVzIGNvcnJlc3BvbmQgdG8gdGhlIGRpc3RhbmNlc1xuICogMyAuLiAyNTgsIHRoZSBsYXN0IDI1NiB2YWx1ZXMgY29ycmVzcG9uZCB0byB0aGUgdG9wIDggYml0cyBvZlxuICogdGhlIDE1IGJpdCBkaXN0YW5jZXMuXG4gKi9cblxudmFyIF9sZW5ndGhfY29kZSAgPSBuZXcgQXJyYXkoTUFYX01BVENIIC0gTUlOX01BVENIICsgMSk7XG56ZXJvKF9sZW5ndGhfY29kZSk7XG4vKiBsZW5ndGggY29kZSBmb3IgZWFjaCBub3JtYWxpemVkIG1hdGNoIGxlbmd0aCAoMCA9PSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2xlbmd0aCAgID0gbmV3IEFycmF5KExFTkdUSF9DT0RFUyk7XG56ZXJvKGJhc2VfbGVuZ3RoKTtcbi8qIEZpcnN0IG5vcm1hbGl6ZWQgbGVuZ3RoIGZvciBlYWNoIGNvZGUgKDAgPSBNSU5fTUFUQ0gpICovXG5cbnZhciBiYXNlX2Rpc3QgICAgID0gbmV3IEFycmF5KERfQ09ERVMpO1xuemVybyhiYXNlX2Rpc3QpO1xuLyogRmlyc3Qgbm9ybWFsaXplZCBkaXN0YW5jZSBmb3IgZWFjaCBjb2RlICgwID0gZGlzdGFuY2Ugb2YgMSkgKi9cblxuXG5mdW5jdGlvbiBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfdHJlZSwgZXh0cmFfYml0cywgZXh0cmFfYmFzZSwgZWxlbXMsIG1heF9sZW5ndGgpIHtcblxuICB0aGlzLnN0YXRpY190cmVlICA9IHN0YXRpY190cmVlOyAgLyogc3RhdGljIHRyZWUgb3IgTlVMTCAqL1xuICB0aGlzLmV4dHJhX2JpdHMgICA9IGV4dHJhX2JpdHM7ICAgLyogZXh0cmEgYml0cyBmb3IgZWFjaCBjb2RlIG9yIE5VTEwgKi9cbiAgdGhpcy5leHRyYV9iYXNlICAgPSBleHRyYV9iYXNlOyAgIC8qIGJhc2UgaW5kZXggZm9yIGV4dHJhX2JpdHMgKi9cbiAgdGhpcy5lbGVtcyAgICAgICAgPSBlbGVtczsgICAgICAgIC8qIG1heCBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHRyZWUgKi9cbiAgdGhpcy5tYXhfbGVuZ3RoICAgPSBtYXhfbGVuZ3RoOyAgIC8qIG1heCBiaXQgbGVuZ3RoIGZvciB0aGUgY29kZXMgKi9cblxuICAvLyBzaG93IGlmIGBzdGF0aWNfdHJlZWAgaGFzIGRhdGEgb3IgZHVtbXkgLSBuZWVkZWQgZm9yIG1vbm9tb3JwaGljIG9iamVjdHNcbiAgdGhpcy5oYXNfc3RyZWUgICAgPSBzdGF0aWNfdHJlZSAmJiBzdGF0aWNfdHJlZS5sZW5ndGg7XG59XG5cblxudmFyIHN0YXRpY19sX2Rlc2M7XG52YXIgc3RhdGljX2RfZGVzYztcbnZhciBzdGF0aWNfYmxfZGVzYztcblxuXG5mdW5jdGlvbiBUcmVlRGVzYyhkeW5fdHJlZSwgc3RhdF9kZXNjKSB7XG4gIHRoaXMuZHluX3RyZWUgPSBkeW5fdHJlZTsgICAgIC8qIHRoZSBkeW5hbWljIHRyZWUgKi9cbiAgdGhpcy5tYXhfY29kZSA9IDA7ICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4gIHRoaXMuc3RhdF9kZXNjID0gc3RhdF9kZXNjOyAgIC8qIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRpYyB0cmVlICovXG59XG5cblxuXG5mdW5jdGlvbiBkX2NvZGUoZGlzdCkge1xuICByZXR1cm4gZGlzdCA8IDI1NiA/IF9kaXN0X2NvZGVbZGlzdF0gOiBfZGlzdF9jb2RlWzI1NiArIChkaXN0ID4+PiA3KV07XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBPdXRwdXQgYSBzaG9ydCBMU0IgZmlyc3Qgb24gdGhlIHN0cmVhbS5cbiAqIElOIGFzc2VydGlvbjogdGhlcmUgaXMgZW5vdWdoIHJvb20gaW4gcGVuZGluZ0J1Zi5cbiAqL1xuZnVuY3Rpb24gcHV0X3Nob3J0KHMsIHcpIHtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh3KSAmIDB4ZmYpKTtcbi8vICAgIHB1dF9ieXRlKHMsICh1Y2gpKCh1c2gpKHcpID4+IDgpKTtcbiAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSAodykgJiAweGZmO1xuICBzLnBlbmRpbmdfYnVmW3MucGVuZGluZysrXSA9ICh3ID4+PiA4KSAmIDB4ZmY7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgdmFsdWUgb24gYSBnaXZlbiBudW1iZXIgb2YgYml0cy5cbiAqIElOIGFzc2VydGlvbjogbGVuZ3RoIDw9IDE2IGFuZCB2YWx1ZSBmaXRzIGluIGxlbmd0aCBiaXRzLlxuICovXG5mdW5jdGlvbiBzZW5kX2JpdHMocywgdmFsdWUsIGxlbmd0aCkge1xuICBpZiAocy5iaV92YWxpZCA+IChCdWZfc2l6ZSAtIGxlbmd0aCkpIHtcbiAgICBzLmJpX2J1ZiB8PSAodmFsdWUgPDwgcy5iaV92YWxpZCkgJiAweGZmZmY7XG4gICAgcHV0X3Nob3J0KHMsIHMuYmlfYnVmKTtcbiAgICBzLmJpX2J1ZiA9IHZhbHVlID4+IChCdWZfc2l6ZSAtIHMuYmlfdmFsaWQpO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoIC0gQnVmX3NpemU7XG4gIH0gZWxzZSB7XG4gICAgcy5iaV9idWYgfD0gKHZhbHVlIDw8IHMuYmlfdmFsaWQpICYgMHhmZmZmO1xuICAgIHMuYmlfdmFsaWQgKz0gbGVuZ3RoO1xuICB9XG59XG5cblxuZnVuY3Rpb24gc2VuZF9jb2RlKHMsIGMsIHRyZWUpIHtcbiAgc2VuZF9iaXRzKHMsIHRyZWVbYyAqIDJdLyouQ29kZSovLCB0cmVlW2MgKiAyICsgMV0vKi5MZW4qLyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBSZXZlcnNlIHRoZSBmaXJzdCBsZW4gYml0cyBvZiBhIGNvZGUsIHVzaW5nIHN0cmFpZ2h0Zm9yd2FyZCBjb2RlIChhIGZhc3RlclxuICogbWV0aG9kIHdvdWxkIHVzZSBhIHRhYmxlKVxuICogSU4gYXNzZXJ0aW9uOiAxIDw9IGxlbiA8PSAxNVxuICovXG5mdW5jdGlvbiBiaV9yZXZlcnNlKGNvZGUsIGxlbikge1xuICB2YXIgcmVzID0gMDtcbiAgZG8ge1xuICAgIHJlcyB8PSBjb2RlICYgMTtcbiAgICBjb2RlID4+Pj0gMTtcbiAgICByZXMgPDw9IDE7XG4gIH0gd2hpbGUgKC0tbGVuID4gMCk7XG4gIHJldHVybiByZXMgPj4+IDE7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciwga2VlcGluZyBhdCBtb3N0IDcgYml0cyBpbiBpdC5cbiAqL1xuZnVuY3Rpb24gYmlfZmx1c2gocykge1xuICBpZiAocy5iaV92YWxpZCA9PT0gMTYpIHtcbiAgICBwdXRfc2hvcnQocywgcy5iaV9idWYpO1xuICAgIHMuYmlfYnVmID0gMDtcbiAgICBzLmJpX3ZhbGlkID0gMDtcblxuICB9IGVsc2UgaWYgKHMuYmlfdmFsaWQgPj0gOCkge1xuICAgIHMucGVuZGluZ19idWZbcy5wZW5kaW5nKytdID0gcy5iaV9idWYgJiAweGZmO1xuICAgIHMuYmlfYnVmID4+PSA4O1xuICAgIHMuYmlfdmFsaWQgLT0gODtcbiAgfVxufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29tcHV0ZSB0aGUgb3B0aW1hbCBiaXQgbGVuZ3RocyBmb3IgYSB0cmVlIGFuZCB1cGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGhcbiAqIGZvciB0aGUgY3VycmVudCBibG9jay5cbiAqIElOIGFzc2VydGlvbjogdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldCwgaGVhcFtoZWFwX21heF0gYW5kXG4gKiAgICBhYm92ZSBhcmUgdGhlIHRyZWUgbm9kZXMgc29ydGVkIGJ5IGluY3JlYXNpbmcgZnJlcXVlbmN5LlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZCBsZW4gaXMgc2V0IHRvIHRoZSBvcHRpbWFsIGJpdCBsZW5ndGgsIHRoZVxuICogICAgIGFycmF5IGJsX2NvdW50IGNvbnRhaW5zIHRoZSBmcmVxdWVuY2llcyBmb3IgZWFjaCBiaXQgbGVuZ3RoLlxuICogICAgIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzIGFsc28gdXBkYXRlZCBpZiBzdHJlZSBpc1xuICogICAgIG5vdCBudWxsLlxuICovXG5mdW5jdGlvbiBnZW5fYml0bGVuKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAgICAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICAgICAgICAgPSBkZXNjLmR5bl90cmVlO1xuICB2YXIgbWF4X2NvZGUgICAgICAgID0gZGVzYy5tYXhfY29kZTtcbiAgdmFyIHN0cmVlICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZXh0cmEgICAgICAgICAgID0gZGVzYy5zdGF0X2Rlc2MuZXh0cmFfYml0cztcbiAgdmFyIGJhc2UgICAgICAgICAgICA9IGRlc2Muc3RhdF9kZXNjLmV4dHJhX2Jhc2U7XG4gIHZhciBtYXhfbGVuZ3RoICAgICAgPSBkZXNjLnN0YXRfZGVzYy5tYXhfbGVuZ3RoO1xuICB2YXIgaDsgICAgICAgICAgICAgIC8qIGhlYXAgaW5kZXggKi9cbiAgdmFyIG4sIG07ICAgICAgICAgICAvKiBpdGVyYXRlIG92ZXIgdGhlIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIGJpdHM7ICAgICAgICAgICAvKiBiaXQgbGVuZ3RoICovXG4gIHZhciB4Yml0czsgICAgICAgICAgLyogZXh0cmEgYml0cyAqL1xuICB2YXIgZjsgICAgICAgICAgICAgIC8qIGZyZXF1ZW5jeSAqL1xuICB2YXIgb3ZlcmZsb3cgPSAwOyAgIC8qIG51bWJlciBvZiBlbGVtZW50cyB3aXRoIGJpdCBsZW5ndGggdG9vIGxhcmdlICovXG5cbiAgZm9yIChiaXRzID0gMDsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgcy5ibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICAvKiBJbiBhIGZpcnN0IHBhc3MsIGNvbXB1dGUgdGhlIG9wdGltYWwgYml0IGxlbmd0aHMgKHdoaWNoIG1heVxuICAgKiBvdmVyZmxvdyBpbiB0aGUgY2FzZSBvZiB0aGUgYml0IGxlbmd0aCB0cmVlKS5cbiAgICovXG4gIHRyZWVbcy5oZWFwW3MuaGVhcF9tYXhdICogMiArIDFdLyouTGVuKi8gPSAwOyAvKiByb290IG9mIHRoZSBoZWFwICovXG5cbiAgZm9yIChoID0gcy5oZWFwX21heCArIDE7IGggPCBIRUFQX1NJWkU7IGgrKykge1xuICAgIG4gPSBzLmhlYXBbaF07XG4gICAgYml0cyA9IHRyZWVbdHJlZVtuICogMiArIDFdLyouRGFkKi8gKiAyICsgMV0vKi5MZW4qLyArIDE7XG4gICAgaWYgKGJpdHMgPiBtYXhfbGVuZ3RoKSB7XG4gICAgICBiaXRzID0gbWF4X2xlbmd0aDtcbiAgICAgIG92ZXJmbG93Kys7XG4gICAgfVxuICAgIHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gYml0cztcbiAgICAvKiBXZSBvdmVyd3JpdGUgdHJlZVtuXS5EYWQgd2hpY2ggaXMgbm8gbG9uZ2VyIG5lZWRlZCAqL1xuXG4gICAgaWYgKG4gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfSAvKiBub3QgYSBsZWFmIG5vZGUgKi9cblxuICAgIHMuYmxfY291bnRbYml0c10rKztcbiAgICB4Yml0cyA9IDA7XG4gICAgaWYgKG4gPj0gYmFzZSkge1xuICAgICAgeGJpdHMgPSBleHRyYVtuIC0gYmFzZV07XG4gICAgfVxuICAgIGYgPSB0cmVlW24gKiAyXS8qLkZyZXEqLztcbiAgICBzLm9wdF9sZW4gKz0gZiAqIChiaXRzICsgeGJpdHMpO1xuICAgIGlmIChoYXNfc3RyZWUpIHtcbiAgICAgIHMuc3RhdGljX2xlbiArPSBmICogKHN0cmVlW24gKiAyICsgMV0vKi5MZW4qLyArIHhiaXRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKG92ZXJmbG93ID09PSAwKSB7IHJldHVybjsgfVxuXG4gIC8vIFRyYWNlKChzdGRlcnIsXCJcXG5iaXQgbGVuZ3RoIG92ZXJmbG93XFxuXCIpKTtcbiAgLyogVGhpcyBoYXBwZW5zIGZvciBleGFtcGxlIG9uIG9iajIgYW5kIHBpYyBvZiB0aGUgQ2FsZ2FyeSBjb3JwdXMgKi9cblxuICAvKiBGaW5kIHRoZSBmaXJzdCBiaXQgbGVuZ3RoIHdoaWNoIGNvdWxkIGluY3JlYXNlOiAqL1xuICBkbyB7XG4gICAgYml0cyA9IG1heF9sZW5ndGggLSAxO1xuICAgIHdoaWxlIChzLmJsX2NvdW50W2JpdHNdID09PSAwKSB7IGJpdHMtLTsgfVxuICAgIHMuYmxfY291bnRbYml0c10tLTsgICAgICAvKiBtb3ZlIG9uZSBsZWFmIGRvd24gdGhlIHRyZWUgKi9cbiAgICBzLmJsX2NvdW50W2JpdHMgKyAxXSArPSAyOyAvKiBtb3ZlIG9uZSBvdmVyZmxvdyBpdGVtIGFzIGl0cyBicm90aGVyICovXG4gICAgcy5ibF9jb3VudFttYXhfbGVuZ3RoXS0tO1xuICAgIC8qIFRoZSBicm90aGVyIG9mIHRoZSBvdmVyZmxvdyBpdGVtIGFsc28gbW92ZXMgb25lIHN0ZXAgdXAsXG4gICAgICogYnV0IHRoaXMgZG9lcyBub3QgYWZmZWN0IGJsX2NvdW50W21heF9sZW5ndGhdXG4gICAgICovXG4gICAgb3ZlcmZsb3cgLT0gMjtcbiAgfSB3aGlsZSAob3ZlcmZsb3cgPiAwKTtcblxuICAvKiBOb3cgcmVjb21wdXRlIGFsbCBiaXQgbGVuZ3Rocywgc2Nhbm5pbmcgaW4gaW5jcmVhc2luZyBmcmVxdWVuY3kuXG4gICAqIGggaXMgc3RpbGwgZXF1YWwgdG8gSEVBUF9TSVpFLiAoSXQgaXMgc2ltcGxlciB0byByZWNvbnN0cnVjdCBhbGxcbiAgICogbGVuZ3RocyBpbnN0ZWFkIG9mIGZpeGluZyBvbmx5IHRoZSB3cm9uZyBvbmVzLiBUaGlzIGlkZWEgaXMgdGFrZW5cbiAgICogZnJvbSAnYXInIHdyaXR0ZW4gYnkgSGFydWhpa28gT2t1bXVyYS4pXG4gICAqL1xuICBmb3IgKGJpdHMgPSBtYXhfbGVuZ3RoOyBiaXRzICE9PSAwOyBiaXRzLS0pIHtcbiAgICBuID0gcy5ibF9jb3VudFtiaXRzXTtcbiAgICB3aGlsZSAobiAhPT0gMCkge1xuICAgICAgbSA9IHMuaGVhcFstLWhdO1xuICAgICAgaWYgKG0gPiBtYXhfY29kZSkgeyBjb250aW51ZTsgfVxuICAgICAgaWYgKHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovICE9PSBiaXRzKSB7XG4gICAgICAgIC8vIFRyYWNlKChzdGRlcnIsXCJjb2RlICVkIGJpdHMgJWQtPiVkXFxuXCIsIG0sIHRyZWVbbV0uTGVuLCBiaXRzKSk7XG4gICAgICAgIHMub3B0X2xlbiArPSAoYml0cyAtIHRyZWVbbSAqIDIgKyAxXS8qLkxlbiovKSAqIHRyZWVbbSAqIDJdLyouRnJlcSovO1xuICAgICAgICB0cmVlW20gKiAyICsgMV0vKi5MZW4qLyA9IGJpdHM7XG4gICAgICB9XG4gICAgICBuLS07XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBHZW5lcmF0ZSB0aGUgY29kZXMgZm9yIGEgZ2l2ZW4gdHJlZSBhbmQgYml0IGNvdW50cyAod2hpY2ggbmVlZCBub3QgYmVcbiAqIG9wdGltYWwpLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgYXJyYXkgYmxfY291bnQgY29udGFpbnMgdGhlIGJpdCBsZW5ndGggc3RhdGlzdGljcyBmb3JcbiAqIHRoZSBnaXZlbiB0cmVlIGFuZCB0aGUgZmllbGQgbGVuIGlzIHNldCBmb3IgYWxsIHRyZWUgZWxlbWVudHMuXG4gKiBPVVQgYXNzZXJ0aW9uOiB0aGUgZmllbGQgY29kZSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzIG9mIG5vblxuICogICAgIHplcm8gY29kZSBsZW5ndGguXG4gKi9cbmZ1bmN0aW9uIGdlbl9jb2Rlcyh0cmVlLCBtYXhfY29kZSwgYmxfY291bnQpXG4vLyAgICBjdF9kYXRhICp0cmVlOyAgICAgICAgICAgICAvKiB0aGUgdHJlZSB0byBkZWNvcmF0ZSAqL1xuLy8gICAgaW50IG1heF9jb2RlOyAgICAgICAgICAgICAgLyogbGFyZ2VzdCBjb2RlIHdpdGggbm9uIHplcm8gZnJlcXVlbmN5ICovXG4vLyAgICB1c2hmICpibF9jb3VudDsgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoICovXG57XG4gIHZhciBuZXh0X2NvZGUgPSBuZXcgQXJyYXkoTUFYX0JJVFMgKyAxKTsgLyogbmV4dCBjb2RlIHZhbHVlIGZvciBlYWNoIGJpdCBsZW5ndGggKi9cbiAgdmFyIGNvZGUgPSAwOyAgICAgICAgICAgICAgLyogcnVubmluZyBjb2RlIHZhbHVlICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgIC8qIGJpdCBpbmRleCAqL1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGluZGV4ICovXG5cbiAgLyogVGhlIGRpc3RyaWJ1dGlvbiBjb3VudHMgYXJlIGZpcnN0IHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGNvZGUgdmFsdWVzXG4gICAqIHdpdGhvdXQgYml0IHJldmVyc2FsLlxuICAgKi9cbiAgZm9yIChiaXRzID0gMTsgYml0cyA8PSBNQVhfQklUUzsgYml0cysrKSB7XG4gICAgbmV4dF9jb2RlW2JpdHNdID0gY29kZSA9IChjb2RlICsgYmxfY291bnRbYml0cyAtIDFdKSA8PCAxO1xuICB9XG4gIC8qIENoZWNrIHRoYXQgdGhlIGJpdCBjb3VudHMgaW4gYmxfY291bnQgYXJlIGNvbnNpc3RlbnQuIFRoZSBsYXN0IGNvZGVcbiAgICogbXVzdCBiZSBhbGwgb25lcy5cbiAgICovXG4gIC8vQXNzZXJ0IChjb2RlICsgYmxfY291bnRbTUFYX0JJVFNdLTEgPT0gKDE8PE1BWF9CSVRTKS0xLFxuICAvLyAgICAgICAgXCJpbmNvbnNpc3RlbnQgYml0IGNvdW50c1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmdlbl9jb2RlczogbWF4X2NvZGUgJWQgXCIsIG1heF9jb2RlKSk7XG5cbiAgZm9yIChuID0gMDsgIG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIHZhciBsZW4gPSB0cmVlW24gKiAyICsgMV0vKi5MZW4qLztcbiAgICBpZiAobGVuID09PSAwKSB7IGNvbnRpbnVlOyB9XG4gICAgLyogTm93IHJldmVyc2UgdGhlIGJpdHMgKi9cbiAgICB0cmVlW24gKiAyXS8qLkNvZGUqLyA9IGJpX3JldmVyc2UobmV4dF9jb2RlW2xlbl0rKywgbGVuKTtcblxuICAgIC8vVHJhY2Vjdih0cmVlICE9IHN0YXRpY19sdHJlZSwgKHN0ZGVycixcIlxcbm4gJTNkICVjIGwgJTJkIGMgJTR4ICgleCkgXCIsXG4gICAgLy8gICAgIG4sIChpc2dyYXBoKG4pID8gbiA6ICcgJyksIGxlbiwgdHJlZVtuXS5Db2RlLCBuZXh0X2NvZGVbbGVuXS0xKSk7XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHZhcmlvdXMgJ2NvbnN0YW50JyB0YWJsZXMuXG4gKi9cbmZ1bmN0aW9uIHRyX3N0YXRpY19pbml0KCkge1xuICB2YXIgbjsgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgdHJlZSBlbGVtZW50cyAqL1xuICB2YXIgYml0czsgICAgIC8qIGJpdCBjb3VudGVyICovXG4gIHZhciBsZW5ndGg7ICAgLyogbGVuZ3RoIHZhbHVlICovXG4gIHZhciBjb2RlOyAgICAgLyogY29kZSB2YWx1ZSAqL1xuICB2YXIgZGlzdDsgICAgIC8qIGRpc3RhbmNlIGluZGV4ICovXG4gIHZhciBibF9jb3VudCA9IG5ldyBBcnJheShNQVhfQklUUyArIDEpO1xuICAvKiBudW1iZXIgb2YgY29kZXMgYXQgZWFjaCBiaXQgbGVuZ3RoIGZvciBhbiBvcHRpbWFsIHRyZWUgKi9cblxuICAvLyBkbyBjaGVjayBpbiBfdHJfaW5pdCgpXG4gIC8vaWYgKHN0YXRpY19pbml0X2RvbmUpIHJldHVybjtcblxuICAvKiBGb3Igc29tZSBlbWJlZGRlZCB0YXJnZXRzLCBnbG9iYWwgdmFyaWFibGVzIGFyZSBub3QgaW5pdGlhbGl6ZWQ6ICovXG4vKiNpZmRlZiBOT19JTklUX0dMT0JBTF9QT0lOVEVSU1xuICBzdGF0aWNfbF9kZXNjLnN0YXRpY190cmVlID0gc3RhdGljX2x0cmVlO1xuICBzdGF0aWNfbF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9sYml0cztcbiAgc3RhdGljX2RfZGVzYy5zdGF0aWNfdHJlZSA9IHN0YXRpY19kdHJlZTtcbiAgc3RhdGljX2RfZGVzYy5leHRyYV9iaXRzID0gZXh0cmFfZGJpdHM7XG4gIHN0YXRpY19ibF9kZXNjLmV4dHJhX2JpdHMgPSBleHRyYV9ibGJpdHM7XG4jZW5kaWYqL1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgbGVuZ3RoICgwLi4yNTUpIC0+IGxlbmd0aCBjb2RlICgwLi4yOCkgKi9cbiAgbGVuZ3RoID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IExFTkdUSF9DT0RFUyAtIDE7IGNvZGUrKykge1xuICAgIGJhc2VfbGVuZ3RoW2NvZGVdID0gbGVuZ3RoO1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9sYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2xlbmd0aF9jb2RlW2xlbmd0aCsrXSA9IGNvZGU7XG4gICAgfVxuICB9XG4gIC8vQXNzZXJ0IChsZW5ndGggPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBsZW5ndGggIT0gMjU2XCIpO1xuICAvKiBOb3RlIHRoYXQgdGhlIGxlbmd0aCAyNTUgKG1hdGNoIGxlbmd0aCAyNTgpIGNhbiBiZSByZXByZXNlbnRlZFxuICAgKiBpbiB0d28gZGlmZmVyZW50IHdheXM6IGNvZGUgMjg0ICsgNSBiaXRzIG9yIGNvZGUgMjg1LCBzbyB3ZVxuICAgKiBvdmVyd3JpdGUgbGVuZ3RoX2NvZGVbMjU1XSB0byB1c2UgdGhlIGJlc3QgZW5jb2Rpbmc6XG4gICAqL1xuICBfbGVuZ3RoX2NvZGVbbGVuZ3RoIC0gMV0gPSBjb2RlO1xuXG4gIC8qIEluaXRpYWxpemUgdGhlIG1hcHBpbmcgZGlzdCAoMC4uMzJLKSAtPiBkaXN0IGNvZGUgKDAuLjI5KSAqL1xuICBkaXN0ID0gMDtcbiAgZm9yIChjb2RlID0gMDsgY29kZSA8IDE2OyBjb2RlKyspIHtcbiAgICBiYXNlX2Rpc3RbY29kZV0gPSBkaXN0O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCBleHRyYV9kYml0c1tjb2RlXSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVtkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiBkaXN0ICE9IDI1NlwiKTtcbiAgZGlzdCA+Pj0gNzsgLyogZnJvbSBub3cgb24sIGFsbCBkaXN0YW5jZXMgYXJlIGRpdmlkZWQgYnkgMTI4ICovXG4gIGZvciAoOyBjb2RlIDwgRF9DT0RFUzsgY29kZSsrKSB7XG4gICAgYmFzZV9kaXN0W2NvZGVdID0gZGlzdCA8PCA3O1xuICAgIGZvciAobiA9IDA7IG4gPCAoMSA8PCAoZXh0cmFfZGJpdHNbY29kZV0gLSA3KSk7IG4rKykge1xuICAgICAgX2Rpc3RfY29kZVsyNTYgKyBkaXN0KytdID0gY29kZTtcbiAgICB9XG4gIH1cbiAgLy9Bc3NlcnQgKGRpc3QgPT0gMjU2LCBcInRyX3N0YXRpY19pbml0OiAyNTYrZGlzdCAhPSA1MTJcIik7XG5cbiAgLyogQ29uc3RydWN0IHRoZSBjb2RlcyBvZiB0aGUgc3RhdGljIGxpdGVyYWwgdHJlZSAqL1xuICBmb3IgKGJpdHMgPSAwOyBiaXRzIDw9IE1BWF9CSVRTOyBiaXRzKyspIHtcbiAgICBibF9jb3VudFtiaXRzXSA9IDA7XG4gIH1cblxuICBuID0gMDtcbiAgd2hpbGUgKG4gPD0gMTQzKSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjU1KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDk7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzldKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjc5KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDc7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzddKys7XG4gIH1cbiAgd2hpbGUgKG4gPD0gMjg3KSB7XG4gICAgc3RhdGljX2x0cmVlW24gKiAyICsgMV0vKi5MZW4qLyA9IDg7XG4gICAgbisrO1xuICAgIGJsX2NvdW50WzhdKys7XG4gIH1cbiAgLyogQ29kZXMgMjg2IGFuZCAyODcgZG8gbm90IGV4aXN0LCBidXQgd2UgbXVzdCBpbmNsdWRlIHRoZW0gaW4gdGhlXG4gICAqIHRyZWUgY29uc3RydWN0aW9uIHRvIGdldCBhIGNhbm9uaWNhbCBIdWZmbWFuIHRyZWUgKGxvbmdlc3QgY29kZVxuICAgKiBhbGwgb25lcylcbiAgICovXG4gIGdlbl9jb2RlcyhzdGF0aWNfbHRyZWUsIExfQ09ERVMgKyAxLCBibF9jb3VudCk7XG5cbiAgLyogVGhlIHN0YXRpYyBkaXN0YW5jZSB0cmVlIGlzIHRyaXZpYWw6ICovXG4gIGZvciAobiA9IDA7IG4gPCBEX0NPREVTOyBuKyspIHtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDIgKyAxXS8qLkxlbiovID0gNTtcbiAgICBzdGF0aWNfZHRyZWVbbiAqIDJdLyouQ29kZSovID0gYmlfcmV2ZXJzZShuLCA1KTtcbiAgfVxuXG4gIC8vIE5vdyBkYXRhIHJlYWR5IGFuZCB3ZSBjYW4gaW5pdCBzdGF0aWMgdHJlZXNcbiAgc3RhdGljX2xfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfbHRyZWUsIGV4dHJhX2xiaXRzLCBMSVRFUkFMUyArIDEsIExfQ09ERVMsIE1BWF9CSVRTKTtcbiAgc3RhdGljX2RfZGVzYyA9IG5ldyBTdGF0aWNUcmVlRGVzYyhzdGF0aWNfZHRyZWUsIGV4dHJhX2RiaXRzLCAwLCAgICAgICAgICBEX0NPREVTLCBNQVhfQklUUyk7XG4gIHN0YXRpY19ibF9kZXNjID0gbmV3IFN0YXRpY1RyZWVEZXNjKG5ldyBBcnJheSgwKSwgZXh0cmFfYmxiaXRzLCAwLCAgICAgICAgIEJMX0NPREVTLCBNQVhfQkxfQklUUyk7XG5cbiAgLy9zdGF0aWNfaW5pdF9kb25lID0gdHJ1ZTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgYSBuZXcgYmxvY2suXG4gKi9cbmZ1bmN0aW9uIGluaXRfYmxvY2socykge1xuICB2YXIgbjsgLyogaXRlcmF0ZXMgb3ZlciB0cmVlIGVsZW1lbnRzICovXG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgdHJlZXMuICovXG4gIGZvciAobiA9IDA7IG4gPCBMX0NPREVTOyAgbisrKSB7IHMuZHluX2x0cmVlW24gKiAyXS8qLkZyZXEqLyA9IDA7IH1cbiAgZm9yIChuID0gMDsgbiA8IERfQ09ERVM7ICBuKyspIHsgcy5keW5fZHRyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuICBmb3IgKG4gPSAwOyBuIDwgQkxfQ09ERVM7IG4rKykgeyBzLmJsX3RyZWVbbiAqIDJdLyouRnJlcSovID0gMDsgfVxuXG4gIHMuZHluX2x0cmVlW0VORF9CTE9DSyAqIDJdLyouRnJlcSovID0gMTtcbiAgcy5vcHRfbGVuID0gcy5zdGF0aWNfbGVuID0gMDtcbiAgcy5sYXN0X2xpdCA9IHMubWF0Y2hlcyA9IDA7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBGbHVzaCB0aGUgYml0IGJ1ZmZlciBhbmQgYWxpZ24gdGhlIG91dHB1dCBvbiBhIGJ5dGUgYm91bmRhcnlcbiAqL1xuZnVuY3Rpb24gYmlfd2luZHVwKHMpXG57XG4gIGlmIChzLmJpX3ZhbGlkID4gOCkge1xuICAgIHB1dF9zaG9ydChzLCBzLmJpX2J1Zik7XG4gIH0gZWxzZSBpZiAocy5iaV92YWxpZCA+IDApIHtcbiAgICAvL3B1dF9ieXRlKHMsIChCeXRlKXMtPmJpX2J1Zik7XG4gICAgcy5wZW5kaW5nX2J1ZltzLnBlbmRpbmcrK10gPSBzLmJpX2J1ZjtcbiAgfVxuICBzLmJpX2J1ZiA9IDA7XG4gIHMuYmlfdmFsaWQgPSAwO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvcHkgYSBzdG9yZWQgYmxvY2ssIHN0b3JpbmcgZmlyc3QgdGhlIGxlbmd0aCBhbmQgaXRzXG4gKiBvbmUncyBjb21wbGVtZW50IGlmIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gY29weV9ibG9jayhzLCBidWYsIGxlbiwgaGVhZGVyKVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICAgICpidWY7ICAgIC8qIHRoZSBpbnB1dCBkYXRhICovXG4vL3Vuc2lnbmVkIGxlbjsgICAgIC8qIGl0cyBsZW5ndGggKi9cbi8vaW50ICAgICAgaGVhZGVyOyAgLyogdHJ1ZSBpZiBibG9jayBoZWFkZXIgbXVzdCBiZSB3cml0dGVuICovXG57XG4gIGJpX3dpbmR1cChzKTsgICAgICAgIC8qIGFsaWduIG9uIGJ5dGUgYm91bmRhcnkgKi9cblxuICBpZiAoaGVhZGVyKSB7XG4gICAgcHV0X3Nob3J0KHMsIGxlbik7XG4gICAgcHV0X3Nob3J0KHMsIH5sZW4pO1xuICB9XG4vLyAgd2hpbGUgKGxlbi0tKSB7XG4vLyAgICBwdXRfYnl0ZShzLCAqYnVmKyspO1xuLy8gIH1cbiAgdXRpbHMuYXJyYXlTZXQocy5wZW5kaW5nX2J1Ziwgcy53aW5kb3csIGJ1ZiwgbGVuLCBzLnBlbmRpbmcpO1xuICBzLnBlbmRpbmcgKz0gbGVuO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIENvbXBhcmVzIHRvIHN1YnRyZWVzLCB1c2luZyB0aGUgdHJlZSBkZXB0aCBhcyB0aWUgYnJlYWtlciB3aGVuXG4gKiB0aGUgc3VidHJlZXMgaGF2ZSBlcXVhbCBmcmVxdWVuY3kuIFRoaXMgbWluaW1pemVzIHRoZSB3b3JzdCBjYXNlIGxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gc21hbGxlcih0cmVlLCBuLCBtLCBkZXB0aCkge1xuICB2YXIgX24yID0gbiAqIDI7XG4gIHZhciBfbTIgPSBtICogMjtcbiAgcmV0dXJuICh0cmVlW19uMl0vKi5GcmVxKi8gPCB0cmVlW19tMl0vKi5GcmVxKi8gfHxcbiAgICAgICAgICh0cmVlW19uMl0vKi5GcmVxKi8gPT09IHRyZWVbX20yXS8qLkZyZXEqLyAmJiBkZXB0aFtuXSA8PSBkZXB0aFttXSkpO1xufVxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFJlc3RvcmUgdGhlIGhlYXAgcHJvcGVydHkgYnkgbW92aW5nIGRvd24gdGhlIHRyZWUgc3RhcnRpbmcgYXQgbm9kZSBrLFxuICogZXhjaGFuZ2luZyBhIG5vZGUgd2l0aCB0aGUgc21hbGxlc3Qgb2YgaXRzIHR3byBzb25zIGlmIG5lY2Vzc2FyeSwgc3RvcHBpbmdcbiAqIHdoZW4gdGhlIGhlYXAgcHJvcGVydHkgaXMgcmUtZXN0YWJsaXNoZWQgKGVhY2ggZmF0aGVyIHNtYWxsZXIgdGhhbiBpdHNcbiAqIHR3byBzb25zKS5cbiAqL1xuZnVuY3Rpb24gcHFkb3duaGVhcChzLCB0cmVlLCBrKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIGN0X2RhdGEgKnRyZWU7ICAvKiB0aGUgdHJlZSB0byByZXN0b3JlICovXG4vLyAgICBpbnQgazsgICAgICAgICAgICAgICAvKiBub2RlIHRvIG1vdmUgZG93biAqL1xue1xuICB2YXIgdiA9IHMuaGVhcFtrXTtcbiAgdmFyIGogPSBrIDw8IDE7ICAvKiBsZWZ0IHNvbiBvZiBrICovXG4gIHdoaWxlIChqIDw9IHMuaGVhcF9sZW4pIHtcbiAgICAvKiBTZXQgaiB0byB0aGUgc21hbGxlc3Qgb2YgdGhlIHR3byBzb25zOiAqL1xuICAgIGlmIChqIDwgcy5oZWFwX2xlbiAmJlxuICAgICAgc21hbGxlcih0cmVlLCBzLmhlYXBbaiArIDFdLCBzLmhlYXBbal0sIHMuZGVwdGgpKSB7XG4gICAgICBqKys7XG4gICAgfVxuICAgIC8qIEV4aXQgaWYgdiBpcyBzbWFsbGVyIHRoYW4gYm90aCBzb25zICovXG4gICAgaWYgKHNtYWxsZXIodHJlZSwgdiwgcy5oZWFwW2pdLCBzLmRlcHRoKSkgeyBicmVhazsgfVxuXG4gICAgLyogRXhjaGFuZ2UgdiB3aXRoIHRoZSBzbWFsbGVzdCBzb24gKi9cbiAgICBzLmhlYXBba10gPSBzLmhlYXBbal07XG4gICAgayA9IGo7XG5cbiAgICAvKiBBbmQgY29udGludWUgZG93biB0aGUgdHJlZSwgc2V0dGluZyBqIHRvIHRoZSBsZWZ0IHNvbiBvZiBrICovXG4gICAgaiA8PD0gMTtcbiAgfVxuICBzLmhlYXBba10gPSB2O1xufVxuXG5cbi8vIGlubGluZWQgbWFudWFsbHlcbi8vIHZhciBTTUFMTEVTVCA9IDE7XG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgYmxvY2sgZGF0YSBjb21wcmVzc2VkIHVzaW5nIHRoZSBnaXZlbiBIdWZmbWFuIHRyZWVzXG4gKi9cbmZ1bmN0aW9uIGNvbXByZXNzX2Jsb2NrKHMsIGx0cmVlLCBkdHJlZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjb25zdCBjdF9kYXRhICpsdHJlZTsgLyogbGl0ZXJhbCB0cmVlICovXG4vLyAgICBjb25zdCBjdF9kYXRhICpkdHJlZTsgLyogZGlzdGFuY2UgdHJlZSAqL1xue1xuICB2YXIgZGlzdDsgICAgICAgICAgIC8qIGRpc3RhbmNlIG9mIG1hdGNoZWQgc3RyaW5nICovXG4gIHZhciBsYzsgICAgICAgICAgICAgLyogbWF0Y2ggbGVuZ3RoIG9yIHVubWF0Y2hlZCBjaGFyIChpZiBkaXN0ID09IDApICovXG4gIHZhciBseCA9IDA7ICAgICAgICAgLyogcnVubmluZyBpbmRleCBpbiBsX2J1ZiAqL1xuICB2YXIgY29kZTsgICAgICAgICAgIC8qIHRoZSBjb2RlIHRvIHNlbmQgKi9cbiAgdmFyIGV4dHJhOyAgICAgICAgICAvKiBudW1iZXIgb2YgZXh0cmEgYml0cyB0byBzZW5kICovXG5cbiAgaWYgKHMubGFzdF9saXQgIT09IDApIHtcbiAgICBkbyB7XG4gICAgICBkaXN0ID0gKHMucGVuZGluZ19idWZbcy5kX2J1ZiArIGx4ICogMl0gPDwgOCkgfCAocy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgbHggKiAyICsgMV0pO1xuICAgICAgbGMgPSBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBseF07XG4gICAgICBseCsrO1xuXG4gICAgICBpZiAoZGlzdCA9PT0gMCkge1xuICAgICAgICBzZW5kX2NvZGUocywgbGMsIGx0cmVlKTsgLyogc2VuZCBhIGxpdGVyYWwgYnl0ZSAqL1xuICAgICAgICAvL1RyYWNlY3YoaXNncmFwaChsYyksIChzdGRlcnIsXCIgJyVjJyBcIiwgbGMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICAgICAgY29kZSA9IF9sZW5ndGhfY29kZVtsY107XG4gICAgICAgIHNlbmRfY29kZShzLCBjb2RlICsgTElURVJBTFMgKyAxLCBsdHJlZSk7IC8qIHNlbmQgdGhlIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfbGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGxjIC09IGJhc2VfbGVuZ3RoW2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBsYywgZXh0cmEpOyAgICAgICAvKiBzZW5kIHRoZSBleHRyYSBsZW5ndGggYml0cyAqL1xuICAgICAgICB9XG4gICAgICAgIGRpc3QtLTsgLyogZGlzdCBpcyBub3cgdGhlIG1hdGNoIGRpc3RhbmNlIC0gMSAqL1xuICAgICAgICBjb2RlID0gZF9jb2RlKGRpc3QpO1xuICAgICAgICAvL0Fzc2VydCAoY29kZSA8IERfQ09ERVMsIFwiYmFkIGRfY29kZVwiKTtcblxuICAgICAgICBzZW5kX2NvZGUocywgY29kZSwgZHRyZWUpOyAgICAgICAvKiBzZW5kIHRoZSBkaXN0YW5jZSBjb2RlICovXG4gICAgICAgIGV4dHJhID0gZXh0cmFfZGJpdHNbY29kZV07XG4gICAgICAgIGlmIChleHRyYSAhPT0gMCkge1xuICAgICAgICAgIGRpc3QgLT0gYmFzZV9kaXN0W2NvZGVdO1xuICAgICAgICAgIHNlbmRfYml0cyhzLCBkaXN0LCBleHRyYSk7ICAgLyogc2VuZCB0aGUgZXh0cmEgZGlzdGFuY2UgYml0cyAqL1xuICAgICAgICB9XG4gICAgICB9IC8qIGxpdGVyYWwgb3IgbWF0Y2ggcGFpciA/ICovXG5cbiAgICAgIC8qIENoZWNrIHRoYXQgdGhlIG92ZXJsYXkgYmV0d2VlbiBwZW5kaW5nX2J1ZiBhbmQgZF9idWYrbF9idWYgaXMgb2s6ICovXG4gICAgICAvL0Fzc2VydCgodUludCkocy0+cGVuZGluZykgPCBzLT5saXRfYnVmc2l6ZSArIDIqbHgsXG4gICAgICAvLyAgICAgICBcInBlbmRpbmdCdWYgb3ZlcmZsb3dcIik7XG5cbiAgICB9IHdoaWxlIChseCA8IHMubGFzdF9saXQpO1xuICB9XG5cbiAgc2VuZF9jb2RlKHMsIEVORF9CTE9DSywgbHRyZWUpO1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogQ29uc3RydWN0IG9uZSBIdWZmbWFuIHRyZWUgYW5kIGFzc2lnbnMgdGhlIGNvZGUgYml0IHN0cmluZ3MgYW5kIGxlbmd0aHMuXG4gKiBVcGRhdGUgdGhlIHRvdGFsIGJpdCBsZW5ndGggZm9yIHRoZSBjdXJyZW50IGJsb2NrLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGQgZnJlcSBpcyBzZXQgZm9yIGFsbCB0cmVlIGVsZW1lbnRzLlxuICogT1VUIGFzc2VydGlvbnM6IHRoZSBmaWVsZHMgbGVuIGFuZCBjb2RlIGFyZSBzZXQgdG8gdGhlIG9wdGltYWwgYml0IGxlbmd0aFxuICogICAgIGFuZCBjb3JyZXNwb25kaW5nIGNvZGUuIFRoZSBsZW5ndGggb3B0X2xlbiBpcyB1cGRhdGVkOyBzdGF0aWNfbGVuIGlzXG4gKiAgICAgYWxzbyB1cGRhdGVkIGlmIHN0cmVlIGlzIG5vdCBudWxsLiBUaGUgZmllbGQgbWF4X2NvZGUgaXMgc2V0LlxuICovXG5mdW5jdGlvbiBidWlsZF90cmVlKHMsIGRlc2MpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgdHJlZV9kZXNjICpkZXNjOyAvKiB0aGUgdHJlZSBkZXNjcmlwdG9yICovXG57XG4gIHZhciB0cmVlICAgICA9IGRlc2MuZHluX3RyZWU7XG4gIHZhciBzdHJlZSAgICA9IGRlc2Muc3RhdF9kZXNjLnN0YXRpY190cmVlO1xuICB2YXIgaGFzX3N0cmVlID0gZGVzYy5zdGF0X2Rlc2MuaGFzX3N0cmVlO1xuICB2YXIgZWxlbXMgICAgPSBkZXNjLnN0YXRfZGVzYy5lbGVtcztcbiAgdmFyIG4sIG07ICAgICAgICAgIC8qIGl0ZXJhdGUgb3ZlciBoZWFwIGVsZW1lbnRzICovXG4gIHZhciBtYXhfY29kZSA9IC0xOyAvKiBsYXJnZXN0IGNvZGUgd2l0aCBub24gemVybyBmcmVxdWVuY3kgKi9cbiAgdmFyIG5vZGU7ICAgICAgICAgIC8qIG5ldyBub2RlIGJlaW5nIGNyZWF0ZWQgKi9cblxuICAvKiBDb25zdHJ1Y3QgdGhlIGluaXRpYWwgaGVhcCwgd2l0aCBsZWFzdCBmcmVxdWVudCBlbGVtZW50IGluXG4gICAqIGhlYXBbU01BTExFU1RdLiBUaGUgc29ucyBvZiBoZWFwW25dIGFyZSBoZWFwWzIqbl0gYW5kIGhlYXBbMipuKzFdLlxuICAgKiBoZWFwWzBdIGlzIG5vdCB1c2VkLlxuICAgKi9cbiAgcy5oZWFwX2xlbiA9IDA7XG4gIHMuaGVhcF9tYXggPSBIRUFQX1NJWkU7XG5cbiAgZm9yIChuID0gMDsgbiA8IGVsZW1zOyBuKyspIHtcbiAgICBpZiAodHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gbWF4X2NvZGUgPSBuO1xuICAgICAgcy5kZXB0aFtuXSA9IDA7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgdHJlZVtuICogMiArIDFdLyouTGVuKi8gPSAwO1xuICAgIH1cbiAgfVxuXG4gIC8qIFRoZSBwa3ppcCBmb3JtYXQgcmVxdWlyZXMgdGhhdCBhdCBsZWFzdCBvbmUgZGlzdGFuY2UgY29kZSBleGlzdHMsXG4gICAqIGFuZCB0aGF0IGF0IGxlYXN0IG9uZSBiaXQgc2hvdWxkIGJlIHNlbnQgZXZlbiBpZiB0aGVyZSBpcyBvbmx5IG9uZVxuICAgKiBwb3NzaWJsZSBjb2RlLiBTbyB0byBhdm9pZCBzcGVjaWFsIGNoZWNrcyBsYXRlciBvbiB3ZSBmb3JjZSBhdCBsZWFzdFxuICAgKiB0d28gY29kZXMgb2Ygbm9uIHplcm8gZnJlcXVlbmN5LlxuICAgKi9cbiAgd2hpbGUgKHMuaGVhcF9sZW4gPCAyKSB7XG4gICAgbm9kZSA9IHMuaGVhcFsrK3MuaGVhcF9sZW5dID0gKG1heF9jb2RlIDwgMiA/ICsrbWF4X2NvZGUgOiAwKTtcbiAgICB0cmVlW25vZGUgKiAyXS8qLkZyZXEqLyA9IDE7XG4gICAgcy5kZXB0aFtub2RlXSA9IDA7XG4gICAgcy5vcHRfbGVuLS07XG5cbiAgICBpZiAoaGFzX3N0cmVlKSB7XG4gICAgICBzLnN0YXRpY19sZW4gLT0gc3RyZWVbbm9kZSAqIDIgKyAxXS8qLkxlbiovO1xuICAgIH1cbiAgICAvKiBub2RlIGlzIDAgb3IgMSBzbyBpdCBkb2VzIG5vdCBoYXZlIGV4dHJhIGJpdHMgKi9cbiAgfVxuICBkZXNjLm1heF9jb2RlID0gbWF4X2NvZGU7XG5cbiAgLyogVGhlIGVsZW1lbnRzIGhlYXBbaGVhcF9sZW4vMisxIC4uIGhlYXBfbGVuXSBhcmUgbGVhdmVzIG9mIHRoZSB0cmVlLFxuICAgKiBlc3RhYmxpc2ggc3ViLWhlYXBzIG9mIGluY3JlYXNpbmcgbGVuZ3RoczpcbiAgICovXG4gIGZvciAobiA9IChzLmhlYXBfbGVuID4+IDEvKmludCAvMiovKTsgbiA+PSAxOyBuLS0pIHsgcHFkb3duaGVhcChzLCB0cmVlLCBuKTsgfVxuXG4gIC8qIENvbnN0cnVjdCB0aGUgSHVmZm1hbiB0cmVlIGJ5IHJlcGVhdGVkbHkgY29tYmluaW5nIHRoZSBsZWFzdCB0d29cbiAgICogZnJlcXVlbnQgbm9kZXMuXG4gICAqL1xuICBub2RlID0gZWxlbXM7ICAgICAgICAgICAgICAvKiBuZXh0IGludGVybmFsIG5vZGUgb2YgdGhlIHRyZWUgKi9cbiAgZG8ge1xuICAgIC8vcHFyZW1vdmUocywgdHJlZSwgbik7ICAvKiBuID0gbm9kZSBvZiBsZWFzdCBmcmVxdWVuY3kgKi9cbiAgICAvKioqIHBxcmVtb3ZlICoqKi9cbiAgICBuID0gcy5oZWFwWzEvKlNNQUxMRVNUKi9dO1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IHMuaGVhcFtzLmhlYXBfbGVuLS1dO1xuICAgIHBxZG93bmhlYXAocywgdHJlZSwgMS8qU01BTExFU1QqLyk7XG4gICAgLyoqKi9cblxuICAgIG0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107IC8qIG0gPSBub2RlIG9mIG5leHQgbGVhc3QgZnJlcXVlbmN5ICovXG5cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG47IC8qIGtlZXAgdGhlIG5vZGVzIHNvcnRlZCBieSBmcmVxdWVuY3kgKi9cbiAgICBzLmhlYXBbLS1zLmhlYXBfbWF4XSA9IG07XG5cbiAgICAvKiBDcmVhdGUgYSBuZXcgbm9kZSBmYXRoZXIgb2YgbiBhbmQgbSAqL1xuICAgIHRyZWVbbm9kZSAqIDJdLyouRnJlcSovID0gdHJlZVtuICogMl0vKi5GcmVxKi8gKyB0cmVlW20gKiAyXS8qLkZyZXEqLztcbiAgICBzLmRlcHRoW25vZGVdID0gKHMuZGVwdGhbbl0gPj0gcy5kZXB0aFttXSA/IHMuZGVwdGhbbl0gOiBzLmRlcHRoW21dKSArIDE7XG4gICAgdHJlZVtuICogMiArIDFdLyouRGFkKi8gPSB0cmVlW20gKiAyICsgMV0vKi5EYWQqLyA9IG5vZGU7XG5cbiAgICAvKiBhbmQgaW5zZXJ0IHRoZSBuZXcgbm9kZSBpbiB0aGUgaGVhcCAqL1xuICAgIHMuaGVhcFsxLypTTUFMTEVTVCovXSA9IG5vZGUrKztcbiAgICBwcWRvd25oZWFwKHMsIHRyZWUsIDEvKlNNQUxMRVNUKi8pO1xuXG4gIH0gd2hpbGUgKHMuaGVhcF9sZW4gPj0gMik7XG5cbiAgcy5oZWFwWy0tcy5oZWFwX21heF0gPSBzLmhlYXBbMS8qU01BTExFU1QqL107XG5cbiAgLyogQXQgdGhpcyBwb2ludCwgdGhlIGZpZWxkcyBmcmVxIGFuZCBkYWQgYXJlIHNldC4gV2UgY2FuIG5vd1xuICAgKiBnZW5lcmF0ZSB0aGUgYml0IGxlbmd0aHMuXG4gICAqL1xuICBnZW5fYml0bGVuKHMsIGRlc2MpO1xuXG4gIC8qIFRoZSBmaWVsZCBsZW4gaXMgbm93IHNldCwgd2UgY2FuIGdlbmVyYXRlIHRoZSBiaXQgY29kZXMgKi9cbiAgZ2VuX2NvZGVzKHRyZWUsIG1heF9jb2RlLCBzLmJsX2NvdW50KTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNjYW4gYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgdG8gZGV0ZXJtaW5lIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29kZXNcbiAqIGluIHRoZSBiaXQgbGVuZ3RoIHRyZWUuXG4gKi9cbmZ1bmN0aW9uIHNjYW5fdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAgIC8qIHRoZSB0cmVlIHRvIGJlIHNjYW5uZWQgKi9cbi8vICAgIGludCBtYXhfY29kZTsgICAgLyogYW5kIGl0cyBsYXJnZXN0IGNvZGUgb2Ygbm9uIHplcm8gZnJlcXVlbmN5ICovXG57XG4gIHZhciBuOyAgICAgICAgICAgICAgICAgICAgIC8qIGl0ZXJhdGVzIG92ZXIgYWxsIHRyZWUgZWxlbWVudHMgKi9cbiAgdmFyIHByZXZsZW4gPSAtMTsgICAgICAgICAgLyogbGFzdCBlbWl0dGVkIGxlbmd0aCAqL1xuICB2YXIgY3VybGVuOyAgICAgICAgICAgICAgICAvKiBsZW5ndGggb2YgY3VycmVudCBjb2RlICovXG5cbiAgdmFyIG5leHRsZW4gPSB0cmVlWzAgKiAyICsgMV0vKi5MZW4qLzsgLyogbGVuZ3RoIG9mIG5leHQgY29kZSAqL1xuXG4gIHZhciBjb3VudCA9IDA7ICAgICAgICAgICAgIC8qIHJlcGVhdCBjb3VudCBvZiB0aGUgY3VycmVudCBjb2RlICovXG4gIHZhciBtYXhfY291bnQgPSA3OyAgICAgICAgIC8qIG1heCByZXBlYXQgY291bnQgKi9cbiAgdmFyIG1pbl9jb3VudCA9IDQ7ICAgICAgICAgLyogbWluIHJlcGVhdCBjb3VudCAqL1xuXG4gIGlmIChuZXh0bGVuID09PSAwKSB7XG4gICAgbWF4X2NvdW50ID0gMTM4O1xuICAgIG1pbl9jb3VudCA9IDM7XG4gIH1cbiAgdHJlZVsobWF4X2NvZGUgKyAxKSAqIDIgKyAxXS8qLkxlbiovID0gMHhmZmZmOyAvKiBndWFyZCAqL1xuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIHMuYmxfdHJlZVtjdXJsZW4gKiAyXS8qLkZyZXEqLyArPSBjb3VudDtcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuICE9PSAwKSB7XG5cbiAgICAgIGlmIChjdXJsZW4gIT09IHByZXZsZW4pIHsgcy5ibF90cmVlW2N1cmxlbiAqIDJdLyouRnJlcSovKys7IH1cbiAgICAgIHMuYmxfdHJlZVtSRVBfM182ICogMl0vKi5GcmVxKi8rKztcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzNfMTAgKiAyXS8qLkZyZXEqLysrO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIHMuYmxfdHJlZVtSRVBaXzExXzEzOCAqIDJdLyouRnJlcSovKys7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG5cbiAgICBpZiAobmV4dGxlbiA9PT0gMCkge1xuICAgICAgbWF4X2NvdW50ID0gMTM4O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSBpZiAoY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBtYXhfY291bnQgPSA2O1xuICAgICAgbWluX2NvdW50ID0gMztcblxuICAgIH0gZWxzZSB7XG4gICAgICBtYXhfY291bnQgPSA3O1xuICAgICAgbWluX2NvdW50ID0gNDtcbiAgICB9XG4gIH1cbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIFNlbmQgYSBsaXRlcmFsIG9yIGRpc3RhbmNlIHRyZWUgaW4gY29tcHJlc3NlZCBmb3JtLCB1c2luZyB0aGUgY29kZXMgaW5cbiAqIGJsX3RyZWUuXG4gKi9cbmZ1bmN0aW9uIHNlbmRfdHJlZShzLCB0cmVlLCBtYXhfY29kZSlcbi8vICAgIGRlZmxhdGVfc3RhdGUgKnM7XG4vLyAgICBjdF9kYXRhICp0cmVlOyAvKiB0aGUgdHJlZSB0byBiZSBzY2FubmVkICovXG4vLyAgICBpbnQgbWF4X2NvZGU7ICAgICAgIC8qIGFuZCBpdHMgbGFyZ2VzdCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXF1ZW5jeSAqL1xue1xuICB2YXIgbjsgICAgICAgICAgICAgICAgICAgICAvKiBpdGVyYXRlcyBvdmVyIGFsbCB0cmVlIGVsZW1lbnRzICovXG4gIHZhciBwcmV2bGVuID0gLTE7ICAgICAgICAgIC8qIGxhc3QgZW1pdHRlZCBsZW5ndGggKi9cbiAgdmFyIGN1cmxlbjsgICAgICAgICAgICAgICAgLyogbGVuZ3RoIG9mIGN1cnJlbnQgY29kZSAqL1xuXG4gIHZhciBuZXh0bGVuID0gdHJlZVswICogMiArIDFdLyouTGVuKi87IC8qIGxlbmd0aCBvZiBuZXh0IGNvZGUgKi9cblxuICB2YXIgY291bnQgPSAwOyAgICAgICAgICAgICAvKiByZXBlYXQgY291bnQgb2YgdGhlIGN1cnJlbnQgY29kZSAqL1xuICB2YXIgbWF4X2NvdW50ID0gNzsgICAgICAgICAvKiBtYXggcmVwZWF0IGNvdW50ICovXG4gIHZhciBtaW5fY291bnQgPSA0OyAgICAgICAgIC8qIG1pbiByZXBlYXQgY291bnQgKi9cblxuICAvKiB0cmVlW21heF9jb2RlKzFdLkxlbiA9IC0xOyAqLyAgLyogZ3VhcmQgYWxyZWFkeSBzZXQgKi9cbiAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICBtYXhfY291bnQgPSAxMzg7XG4gICAgbWluX2NvdW50ID0gMztcbiAgfVxuXG4gIGZvciAobiA9IDA7IG4gPD0gbWF4X2NvZGU7IG4rKykge1xuICAgIGN1cmxlbiA9IG5leHRsZW47XG4gICAgbmV4dGxlbiA9IHRyZWVbKG4gKyAxKSAqIDIgKyAxXS8qLkxlbiovO1xuXG4gICAgaWYgKCsrY291bnQgPCBtYXhfY291bnQgJiYgY3VybGVuID09PSBuZXh0bGVuKSB7XG4gICAgICBjb250aW51ZTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPCBtaW5fY291bnQpIHtcbiAgICAgIGRvIHsgc2VuZF9jb2RlKHMsIGN1cmxlbiwgcy5ibF90cmVlKTsgfSB3aGlsZSAoLS1jb3VudCAhPT0gMCk7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiAhPT0gMCkge1xuICAgICAgaWYgKGN1cmxlbiAhPT0gcHJldmxlbikge1xuICAgICAgICBzZW5kX2NvZGUocywgY3VybGVuLCBzLmJsX3RyZWUpO1xuICAgICAgICBjb3VudC0tO1xuICAgICAgfVxuICAgICAgLy9Bc3NlcnQoY291bnQgPj0gMyAmJiBjb3VudCA8PSA2LCBcIiAzXzY/XCIpO1xuICAgICAgc2VuZF9jb2RlKHMsIFJFUF8zXzYsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAyKTtcblxuICAgIH0gZWxzZSBpZiAoY291bnQgPD0gMTApIHtcbiAgICAgIHNlbmRfY29kZShzLCBSRVBaXzNfMTAsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAzLCAzKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICBzZW5kX2NvZGUocywgUkVQWl8xMV8xMzgsIHMuYmxfdHJlZSk7XG4gICAgICBzZW5kX2JpdHMocywgY291bnQgLSAxMSwgNyk7XG4gICAgfVxuXG4gICAgY291bnQgPSAwO1xuICAgIHByZXZsZW4gPSBjdXJsZW47XG4gICAgaWYgKG5leHRsZW4gPT09IDApIHtcbiAgICAgIG1heF9jb3VudCA9IDEzODtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2UgaWYgKGN1cmxlbiA9PT0gbmV4dGxlbikge1xuICAgICAgbWF4X2NvdW50ID0gNjtcbiAgICAgIG1pbl9jb3VudCA9IDM7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgbWF4X2NvdW50ID0gNztcbiAgICAgIG1pbl9jb3VudCA9IDQ7XG4gICAgfVxuICB9XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDb25zdHJ1Y3QgdGhlIEh1ZmZtYW4gdHJlZSBmb3IgdGhlIGJpdCBsZW5ndGhzIGFuZCByZXR1cm4gdGhlIGluZGV4IGluXG4gKiBibF9vcmRlciBvZiB0aGUgbGFzdCBiaXQgbGVuZ3RoIGNvZGUgdG8gc2VuZC5cbiAqL1xuZnVuY3Rpb24gYnVpbGRfYmxfdHJlZShzKSB7XG4gIHZhciBtYXhfYmxpbmRleDsgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBEZXRlcm1pbmUgdGhlIGJpdCBsZW5ndGggZnJlcXVlbmNpZXMgZm9yIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gIHNjYW5fdHJlZShzLCBzLmR5bl9sdHJlZSwgcy5sX2Rlc2MubWF4X2NvZGUpO1xuICBzY2FuX3RyZWUocywgcy5keW5fZHRyZWUsIHMuZF9kZXNjLm1heF9jb2RlKTtcblxuICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlOiAqL1xuICBidWlsZF90cmVlKHMsIHMuYmxfZGVzYyk7XG4gIC8qIG9wdF9sZW4gbm93IGluY2x1ZGVzIHRoZSBsZW5ndGggb2YgdGhlIHRyZWUgcmVwcmVzZW50YXRpb25zLCBleGNlcHRcbiAgICogdGhlIGxlbmd0aHMgb2YgdGhlIGJpdCBsZW5ndGhzIGNvZGVzIGFuZCB0aGUgNSs1KzQgYml0cyBmb3IgdGhlIGNvdW50cy5cbiAgICovXG5cbiAgLyogRGV0ZXJtaW5lIHRoZSBudW1iZXIgb2YgYml0IGxlbmd0aCBjb2RlcyB0byBzZW5kLiBUaGUgcGt6aXAgZm9ybWF0XG4gICAqIHJlcXVpcmVzIHRoYXQgYXQgbGVhc3QgNCBiaXQgbGVuZ3RoIGNvZGVzIGJlIHNlbnQuIChhcHBub3RlLnR4dCBzYXlzXG4gICAqIDMgYnV0IHRoZSBhY3R1YWwgdmFsdWUgdXNlZCBpcyA0LilcbiAgICovXG4gIGZvciAobWF4X2JsaW5kZXggPSBCTF9DT0RFUyAtIDE7IG1heF9ibGluZGV4ID49IDM7IG1heF9ibGluZGV4LS0pIHtcbiAgICBpZiAocy5ibF90cmVlW2JsX29yZGVyW21heF9ibGluZGV4XSAqIDIgKyAxXS8qLkxlbiovICE9PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgLyogVXBkYXRlIG9wdF9sZW4gdG8gaW5jbHVkZSB0aGUgYml0IGxlbmd0aCB0cmVlIGFuZCBjb3VudHMgKi9cbiAgcy5vcHRfbGVuICs9IDMgKiAobWF4X2JsaW5kZXggKyAxKSArIDUgKyA1ICsgNDtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5keW4gdHJlZXM6IGR5biAlbGQsIHN0YXQgJWxkXCIsXG4gIC8vICAgICAgICBzLT5vcHRfbGVuLCBzLT5zdGF0aWNfbGVuKSk7XG5cbiAgcmV0dXJuIG1heF9ibGluZGV4O1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCB0aGUgaGVhZGVyIGZvciBhIGJsb2NrIHVzaW5nIGR5bmFtaWMgSHVmZm1hbiB0cmVlczogdGhlIGNvdW50cywgdGhlXG4gKiBsZW5ndGhzIG9mIHRoZSBiaXQgbGVuZ3RoIGNvZGVzLCB0aGUgbGl0ZXJhbCB0cmVlIGFuZCB0aGUgZGlzdGFuY2UgdHJlZS5cbiAqIElOIGFzc2VydGlvbjogbGNvZGVzID49IDI1NywgZGNvZGVzID49IDEsIGJsY29kZXMgPj0gNC5cbiAqL1xuZnVuY3Rpb24gc2VuZF9hbGxfdHJlZXMocywgbGNvZGVzLCBkY29kZXMsIGJsY29kZXMpXG4vLyAgICBkZWZsYXRlX3N0YXRlICpzO1xuLy8gICAgaW50IGxjb2RlcywgZGNvZGVzLCBibGNvZGVzOyAvKiBudW1iZXIgb2YgY29kZXMgZm9yIGVhY2ggdHJlZSAqL1xue1xuICB2YXIgcmFuazsgICAgICAgICAgICAgICAgICAgIC8qIGluZGV4IGluIGJsX29yZGVyICovXG5cbiAgLy9Bc3NlcnQgKGxjb2RlcyA+PSAyNTcgJiYgZGNvZGVzID49IDEgJiYgYmxjb2RlcyA+PSA0LCBcIm5vdCBlbm91Z2ggY29kZXNcIik7XG4gIC8vQXNzZXJ0IChsY29kZXMgPD0gTF9DT0RFUyAmJiBkY29kZXMgPD0gRF9DT0RFUyAmJiBibGNvZGVzIDw9IEJMX0NPREVTLFxuICAvLyAgICAgICAgXCJ0b28gbWFueSBjb2Rlc1wiKTtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCBjb3VudHM6IFwiKSk7XG4gIHNlbmRfYml0cyhzLCBsY29kZXMgLSAyNTcsIDUpOyAvKiBub3QgKzI1NSBhcyBzdGF0ZWQgaW4gYXBwbm90ZS50eHQgKi9cbiAgc2VuZF9iaXRzKHMsIGRjb2RlcyAtIDEsICAgNSk7XG4gIHNlbmRfYml0cyhzLCBibGNvZGVzIC0gNCwgIDQpOyAvKiBub3QgLTMgYXMgc3RhdGVkIGluIGFwcG5vdGUudHh0ICovXG4gIGZvciAocmFuayA9IDA7IHJhbmsgPCBibGNvZGVzOyByYW5rKyspIHtcbiAgICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmJsIGNvZGUgJTJkIFwiLCBibF9vcmRlcltyYW5rXSkpO1xuICAgIHNlbmRfYml0cyhzLCBzLmJsX3RyZWVbYmxfb3JkZXJbcmFua10gKiAyICsgMV0vKi5MZW4qLywgMyk7XG4gIH1cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5ibCB0cmVlOiBzZW50ICVsZFwiLCBzLT5iaXRzX3NlbnQpKTtcblxuICBzZW5kX3RyZWUocywgcy5keW5fbHRyZWUsIGxjb2RlcyAtIDEpOyAvKiBsaXRlcmFsIHRyZWUgKi9cbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJcXG5saXQgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG5cbiAgc2VuZF90cmVlKHMsIHMuZHluX2R0cmVlLCBkY29kZXMgLSAxKTsgLyogZGlzdGFuY2UgdHJlZSAqL1xuICAvL1RyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgdHJlZTogc2VudCAlbGRcIiwgcy0+Yml0c19zZW50KSk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBDaGVjayBpZiB0aGUgZGF0YSB0eXBlIGlzIFRFWFQgb3IgQklOQVJZLCB1c2luZyB0aGUgZm9sbG93aW5nIGFsZ29yaXRobTpcbiAqIC0gVEVYVCBpZiB0aGUgdHdvIGNvbmRpdGlvbnMgYmVsb3cgYXJlIHNhdGlzZmllZDpcbiAqICAgIGEpIFRoZXJlIGFyZSBubyBub24tcG9ydGFibGUgY29udHJvbCBjaGFyYWN0ZXJzIGJlbG9uZ2luZyB0byB0aGVcbiAqICAgICAgIFwiYmxhY2sgbGlzdFwiICgwLi42LCAxNC4uMjUsIDI4Li4zMSkuXG4gKiAgICBiKSBUaGVyZSBpcyBhdCBsZWFzdCBvbmUgcHJpbnRhYmxlIGNoYXJhY3RlciBiZWxvbmdpbmcgdG8gdGhlXG4gKiAgICAgICBcIndoaXRlIGxpc3RcIiAoOSB7VEFCfSwgMTAge0xGfSwgMTMge0NSfSwgMzIuLjI1NSkuXG4gKiAtIEJJTkFSWSBvdGhlcndpc2UuXG4gKiAtIFRoZSBmb2xsb3dpbmcgcGFydGlhbGx5LXBvcnRhYmxlIGNvbnRyb2wgY2hhcmFjdGVycyBmb3JtIGFcbiAqICAgXCJncmF5IGxpc3RcIiB0aGF0IGlzIGlnbm9yZWQgaW4gdGhpcyBkZXRlY3Rpb24gYWxnb3JpdGhtOlxuICogICAoNyB7QkVMfSwgOCB7QlN9LCAxMSB7VlR9LCAxMiB7RkZ9LCAyNiB7U1VCfSwgMjcge0VTQ30pLlxuICogSU4gYXNzZXJ0aW9uOiB0aGUgZmllbGRzIEZyZXEgb2YgZHluX2x0cmVlIGFyZSBzZXQuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdF9kYXRhX3R5cGUocykge1xuICAvKiBibGFja19tYXNrIGlzIHRoZSBiaXQgbWFzayBvZiBibGFjay1saXN0ZWQgYnl0ZXNcbiAgICogc2V0IGJpdHMgMC4uNiwgMTQuLjI1LCBhbmQgMjguLjMxXG4gICAqIDB4ZjNmZmMwN2YgPSBiaW5hcnkgMTExMTAwMTExMTExMTExMTExMDAwMDAwMDExMTExMTFcbiAgICovXG4gIHZhciBibGFja19tYXNrID0gMHhmM2ZmYzA3ZjtcbiAgdmFyIG47XG5cbiAgLyogQ2hlY2sgZm9yIG5vbi10ZXh0dWFsIChcImJsYWNrLWxpc3RlZFwiKSBieXRlcy4gKi9cbiAgZm9yIChuID0gMDsgbiA8PSAzMTsgbisrLCBibGFja19tYXNrID4+Pj0gMSkge1xuICAgIGlmICgoYmxhY2tfbWFzayAmIDEpICYmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApKSB7XG4gICAgICByZXR1cm4gWl9CSU5BUlk7XG4gICAgfVxuICB9XG5cbiAgLyogQ2hlY2sgZm9yIHRleHR1YWwgKFwid2hpdGUtbGlzdGVkXCIpIGJ5dGVzLiAqL1xuICBpZiAocy5keW5fbHRyZWVbOSAqIDJdLyouRnJlcSovICE9PSAwIHx8IHMuZHluX2x0cmVlWzEwICogMl0vKi5GcmVxKi8gIT09IDAgfHxcbiAgICAgIHMuZHluX2x0cmVlWzEzICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICByZXR1cm4gWl9URVhUO1xuICB9XG4gIGZvciAobiA9IDMyOyBuIDwgTElURVJBTFM7IG4rKykge1xuICAgIGlmIChzLmR5bl9sdHJlZVtuICogMl0vKi5GcmVxKi8gIT09IDApIHtcbiAgICAgIHJldHVybiBaX1RFWFQ7XG4gICAgfVxuICB9XG5cbiAgLyogVGhlcmUgYXJlIG5vIFwiYmxhY2stbGlzdGVkXCIgb3IgXCJ3aGl0ZS1saXN0ZWRcIiBieXRlczpcbiAgICogdGhpcyBzdHJlYW0gZWl0aGVyIGlzIGVtcHR5IG9yIGhhcyB0b2xlcmF0ZWQgKFwiZ3JheS1saXN0ZWRcIikgYnl0ZXMgb25seS5cbiAgICovXG4gIHJldHVybiBaX0JJTkFSWTtcbn1cblxuXG52YXIgc3RhdGljX2luaXRfZG9uZSA9IGZhbHNlO1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIEluaXRpYWxpemUgdGhlIHRyZWUgZGF0YSBzdHJ1Y3R1cmVzIGZvciBhIG5ldyB6bGliIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gX3RyX2luaXQocylcbntcblxuICBpZiAoIXN0YXRpY19pbml0X2RvbmUpIHtcbiAgICB0cl9zdGF0aWNfaW5pdCgpO1xuICAgIHN0YXRpY19pbml0X2RvbmUgPSB0cnVlO1xuICB9XG5cbiAgcy5sX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2x0cmVlLCBzdGF0aWNfbF9kZXNjKTtcbiAgcy5kX2Rlc2MgID0gbmV3IFRyZWVEZXNjKHMuZHluX2R0cmVlLCBzdGF0aWNfZF9kZXNjKTtcbiAgcy5ibF9kZXNjID0gbmV3IFRyZWVEZXNjKHMuYmxfdHJlZSwgc3RhdGljX2JsX2Rlc2MpO1xuXG4gIHMuYmlfYnVmID0gMDtcbiAgcy5iaV92YWxpZCA9IDA7XG5cbiAgLyogSW5pdGlhbGl6ZSB0aGUgZmlyc3QgYmxvY2sgb2YgdGhlIGZpcnN0IGZpbGU6ICovXG4gIGluaXRfYmxvY2socyk7XG59XG5cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTZW5kIGEgc3RvcmVkIGJsb2NrXG4gKi9cbmZ1bmN0aW9uIF90cl9zdG9yZWRfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrICovXG4vL3VsZyBzdG9yZWRfbGVuOyAgIC8qIGxlbmd0aCBvZiBpbnB1dCBibG9jayAqL1xuLy9pbnQgbGFzdDsgICAgICAgICAvKiBvbmUgaWYgdGhpcyBpcyB0aGUgbGFzdCBibG9jayBmb3IgYSBmaWxlICovXG57XG4gIHNlbmRfYml0cyhzLCAoU1RPUkVEX0JMT0NLIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpOyAgICAvKiBzZW5kIGJsb2NrIHR5cGUgKi9cbiAgY29weV9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIHRydWUpOyAvKiB3aXRoIGhlYWRlciAqL1xufVxuXG5cbi8qID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICogU2VuZCBvbmUgZW1wdHkgc3RhdGljIGJsb2NrIHRvIGdpdmUgZW5vdWdoIGxvb2thaGVhZCBmb3IgaW5mbGF0ZS5cbiAqIFRoaXMgdGFrZXMgMTAgYml0cywgb2Ygd2hpY2ggNyBtYXkgcmVtYWluIGluIHRoZSBiaXQgYnVmZmVyLlxuICovXG5mdW5jdGlvbiBfdHJfYWxpZ24ocykge1xuICBzZW5kX2JpdHMocywgU1RBVElDX1RSRUVTIDw8IDEsIDMpO1xuICBzZW5kX2NvZGUocywgRU5EX0JMT0NLLCBzdGF0aWNfbHRyZWUpO1xuICBiaV9mbHVzaChzKTtcbn1cblxuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZyBmb3IgdGhlIGN1cnJlbnQgYmxvY2s6IGR5bmFtaWMgdHJlZXMsIHN0YXRpY1xuICogdHJlZXMgb3Igc3RvcmUsIGFuZCBvdXRwdXQgdGhlIGVuY29kZWQgYmxvY2sgdG8gdGhlIHppcCBmaWxlLlxuICovXG5mdW5jdGlvbiBfdHJfZmx1c2hfYmxvY2socywgYnVmLCBzdG9yZWRfbGVuLCBsYXN0KVxuLy9EZWZsYXRlU3RhdGUgKnM7XG4vL2NoYXJmICpidWY7ICAgICAgIC8qIGlucHV0IGJsb2NrLCBvciBOVUxMIGlmIHRvbyBvbGQgKi9cbi8vdWxnIHN0b3JlZF9sZW47ICAgLyogbGVuZ3RoIG9mIGlucHV0IGJsb2NrICovXG4vL2ludCBsYXN0OyAgICAgICAgIC8qIG9uZSBpZiB0aGlzIGlzIHRoZSBsYXN0IGJsb2NrIGZvciBhIGZpbGUgKi9cbntcbiAgdmFyIG9wdF9sZW5iLCBzdGF0aWNfbGVuYjsgIC8qIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gaW4gYnl0ZXMgKi9cbiAgdmFyIG1heF9ibGluZGV4ID0gMDsgICAgICAgIC8qIGluZGV4IG9mIGxhc3QgYml0IGxlbmd0aCBjb2RlIG9mIG5vbiB6ZXJvIGZyZXEgKi9cblxuICAvKiBCdWlsZCB0aGUgSHVmZm1hbiB0cmVlcyB1bmxlc3MgYSBzdG9yZWQgYmxvY2sgaXMgZm9yY2VkICovXG4gIGlmIChzLmxldmVsID4gMCkge1xuXG4gICAgLyogQ2hlY2sgaWYgdGhlIGZpbGUgaXMgYmluYXJ5IG9yIHRleHQgKi9cbiAgICBpZiAocy5zdHJtLmRhdGFfdHlwZSA9PT0gWl9VTktOT1dOKSB7XG4gICAgICBzLnN0cm0uZGF0YV90eXBlID0gZGV0ZWN0X2RhdGFfdHlwZShzKTtcbiAgICB9XG5cbiAgICAvKiBDb25zdHJ1Y3QgdGhlIGxpdGVyYWwgYW5kIGRpc3RhbmNlIHRyZWVzICovXG4gICAgYnVpbGRfdHJlZShzLCBzLmxfZGVzYyk7XG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxubGl0IGRhdGE6IGR5biAlbGQsIHN0YXQgJWxkXCIsIHMtPm9wdF9sZW4sXG4gICAgLy8gICAgICAgIHMtPnN0YXRpY19sZW4pKTtcblxuICAgIGJ1aWxkX3RyZWUocywgcy5kX2Rlc2MpO1xuICAgIC8vIFRyYWNldigoc3RkZXJyLCBcIlxcbmRpc3QgZGF0YTogZHluICVsZCwgc3RhdCAlbGRcIiwgcy0+b3B0X2xlbixcbiAgICAvLyAgICAgICAgcy0+c3RhdGljX2xlbikpO1xuICAgIC8qIEF0IHRoaXMgcG9pbnQsIG9wdF9sZW4gYW5kIHN0YXRpY19sZW4gYXJlIHRoZSB0b3RhbCBiaXQgbGVuZ3RocyBvZlxuICAgICAqIHRoZSBjb21wcmVzc2VkIGJsb2NrIGRhdGEsIGV4Y2x1ZGluZyB0aGUgdHJlZSByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG5cbiAgICAvKiBCdWlsZCB0aGUgYml0IGxlbmd0aCB0cmVlIGZvciB0aGUgYWJvdmUgdHdvIHRyZWVzLCBhbmQgZ2V0IHRoZSBpbmRleFxuICAgICAqIGluIGJsX29yZGVyIG9mIHRoZSBsYXN0IGJpdCBsZW5ndGggY29kZSB0byBzZW5kLlxuICAgICAqL1xuICAgIG1heF9ibGluZGV4ID0gYnVpbGRfYmxfdHJlZShzKTtcblxuICAgIC8qIERldGVybWluZSB0aGUgYmVzdCBlbmNvZGluZy4gQ29tcHV0ZSB0aGUgYmxvY2sgbGVuZ3RocyBpbiBieXRlcy4gKi9cbiAgICBvcHRfbGVuYiA9IChzLm9wdF9sZW4gKyAzICsgNykgPj4+IDM7XG4gICAgc3RhdGljX2xlbmIgPSAocy5zdGF0aWNfbGVuICsgMyArIDcpID4+PiAzO1xuXG4gICAgLy8gVHJhY2V2KChzdGRlcnIsIFwiXFxub3B0ICVsdSglbHUpIHN0YXQgJWx1KCVsdSkgc3RvcmVkICVsdSBsaXQgJXUgXCIsXG4gICAgLy8gICAgICAgIG9wdF9sZW5iLCBzLT5vcHRfbGVuLCBzdGF0aWNfbGVuYiwgcy0+c3RhdGljX2xlbiwgc3RvcmVkX2xlbixcbiAgICAvLyAgICAgICAgcy0+bGFzdF9saXQpKTtcblxuICAgIGlmIChzdGF0aWNfbGVuYiA8PSBvcHRfbGVuYikgeyBvcHRfbGVuYiA9IHN0YXRpY19sZW5iOyB9XG5cbiAgfSBlbHNlIHtcbiAgICAvLyBBc3NlcnQoYnVmICE9IChjaGFyKikwLCBcImxvc3QgYnVmXCIpO1xuICAgIG9wdF9sZW5iID0gc3RhdGljX2xlbmIgPSBzdG9yZWRfbGVuICsgNTsgLyogZm9yY2UgYSBzdG9yZWQgYmxvY2sgKi9cbiAgfVxuXG4gIGlmICgoc3RvcmVkX2xlbiArIDQgPD0gb3B0X2xlbmIpICYmIChidWYgIT09IC0xKSkge1xuICAgIC8qIDQ6IHR3byB3b3JkcyBmb3IgdGhlIGxlbmd0aHMgKi9cblxuICAgIC8qIFRoZSB0ZXN0IGJ1ZiAhPSBOVUxMIGlzIG9ubHkgbmVjZXNzYXJ5IGlmIExJVF9CVUZTSVpFID4gV1NJWkUuXG4gICAgICogT3RoZXJ3aXNlIHdlIGNhbid0IGhhdmUgcHJvY2Vzc2VkIG1vcmUgdGhhbiBXU0laRSBpbnB1dCBieXRlcyBzaW5jZVxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGZsdXNoLCBiZWNhdXNlIGNvbXByZXNzaW9uIHdvdWxkIGhhdmUgYmVlblxuICAgICAqIHN1Y2Nlc3NmdWwuIElmIExJVF9CVUZTSVpFIDw9IFdTSVpFLCBpdCBpcyBuZXZlciB0b28gbGF0ZSB0b1xuICAgICAqIHRyYW5zZm9ybSBhIGJsb2NrIGludG8gYSBzdG9yZWQgYmxvY2suXG4gICAgICovXG4gICAgX3RyX3N0b3JlZF9ibG9jayhzLCBidWYsIHN0b3JlZF9sZW4sIGxhc3QpO1xuXG4gIH0gZWxzZSBpZiAocy5zdHJhdGVneSA9PT0gWl9GSVhFRCB8fCBzdGF0aWNfbGVuYiA9PT0gb3B0X2xlbmIpIHtcblxuICAgIHNlbmRfYml0cyhzLCAoU1RBVElDX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHN0YXRpY19sdHJlZSwgc3RhdGljX2R0cmVlKTtcblxuICB9IGVsc2Uge1xuICAgIHNlbmRfYml0cyhzLCAoRFlOX1RSRUVTIDw8IDEpICsgKGxhc3QgPyAxIDogMCksIDMpO1xuICAgIHNlbmRfYWxsX3RyZWVzKHMsIHMubF9kZXNjLm1heF9jb2RlICsgMSwgcy5kX2Rlc2MubWF4X2NvZGUgKyAxLCBtYXhfYmxpbmRleCArIDEpO1xuICAgIGNvbXByZXNzX2Jsb2NrKHMsIHMuZHluX2x0cmVlLCBzLmR5bl9kdHJlZSk7XG4gIH1cbiAgLy8gQXNzZXJ0IChzLT5jb21wcmVzc2VkX2xlbiA9PSBzLT5iaXRzX3NlbnQsIFwiYmFkIGNvbXByZXNzZWQgc2l6ZVwiKTtcbiAgLyogVGhlIGFib3ZlIGNoZWNrIGlzIG1hZGUgbW9kIDJeMzIsIGZvciBmaWxlcyBsYXJnZXIgdGhhbiA1MTIgTUJcbiAgICogYW5kIHVMb25nIGltcGxlbWVudGVkIG9uIDMyIGJpdHMuXG4gICAqL1xuICBpbml0X2Jsb2NrKHMpO1xuXG4gIGlmIChsYXN0KSB7XG4gICAgYmlfd2luZHVwKHMpO1xuICB9XG4gIC8vIFRyYWNldigoc3RkZXJyLFwiXFxuY29tcHJsZW4gJWx1KCVsdSkgXCIsIHMtPmNvbXByZXNzZWRfbGVuPj4zLFxuICAvLyAgICAgICBzLT5jb21wcmVzc2VkX2xlbi03Kmxhc3QpKTtcbn1cblxuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKiBTYXZlIHRoZSBtYXRjaCBpbmZvIGFuZCB0YWxseSB0aGUgZnJlcXVlbmN5IGNvdW50cy4gUmV0dXJuIHRydWUgaWZcbiAqIHRoZSBjdXJyZW50IGJsb2NrIG11c3QgYmUgZmx1c2hlZC5cbiAqL1xuZnVuY3Rpb24gX3RyX3RhbGx5KHMsIGRpc3QsIGxjKVxuLy8gICAgZGVmbGF0ZV9zdGF0ZSAqcztcbi8vICAgIHVuc2lnbmVkIGRpc3Q7ICAvKiBkaXN0YW5jZSBvZiBtYXRjaGVkIHN0cmluZyAqL1xuLy8gICAgdW5zaWduZWQgbGM7ICAgIC8qIG1hdGNoIGxlbmd0aC1NSU5fTUFUQ0ggb3IgdW5tYXRjaGVkIGNoYXIgKGlmIGRpc3Q9PTApICovXG57XG4gIC8vdmFyIG91dF9sZW5ndGgsIGluX2xlbmd0aCwgZGNvZGU7XG5cbiAgcy5wZW5kaW5nX2J1ZltzLmRfYnVmICsgcy5sYXN0X2xpdCAqIDJdICAgICA9IChkaXN0ID4+PiA4KSAmIDB4ZmY7XG4gIHMucGVuZGluZ19idWZbcy5kX2J1ZiArIHMubGFzdF9saXQgKiAyICsgMV0gPSBkaXN0ICYgMHhmZjtcblxuICBzLnBlbmRpbmdfYnVmW3MubF9idWYgKyBzLmxhc3RfbGl0XSA9IGxjICYgMHhmZjtcbiAgcy5sYXN0X2xpdCsrO1xuXG4gIGlmIChkaXN0ID09PSAwKSB7XG4gICAgLyogbGMgaXMgdGhlIHVubWF0Y2hlZCBjaGFyICovXG4gICAgcy5keW5fbHRyZWVbbGMgKiAyXS8qLkZyZXEqLysrO1xuICB9IGVsc2Uge1xuICAgIHMubWF0Y2hlcysrO1xuICAgIC8qIEhlcmUsIGxjIGlzIHRoZSBtYXRjaCBsZW5ndGggLSBNSU5fTUFUQ0ggKi9cbiAgICBkaXN0LS07ICAgICAgICAgICAgIC8qIGRpc3QgPSBtYXRjaCBkaXN0YW5jZSAtIDEgKi9cbiAgICAvL0Fzc2VydCgodXNoKWRpc3QgPCAodXNoKU1BWF9ESVNUKHMpICYmXG4gICAgLy8gICAgICAgKHVzaClsYyA8PSAodXNoKShNQVhfTUFUQ0gtTUlOX01BVENIKSAmJlxuICAgIC8vICAgICAgICh1c2gpZF9jb2RlKGRpc3QpIDwgKHVzaClEX0NPREVTLCAgXCJfdHJfdGFsbHk6IGJhZCBtYXRjaFwiKTtcblxuICAgIHMuZHluX2x0cmVlWyhfbGVuZ3RoX2NvZGVbbGNdICsgTElURVJBTFMgKyAxKSAqIDJdLyouRnJlcSovKys7XG4gICAgcy5keW5fZHRyZWVbZF9jb2RlKGRpc3QpICogMl0vKi5GcmVxKi8rKztcbiAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmF1bHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuXG4vLyNpZmRlZiBUUlVOQ0FURV9CTE9DS1xuLy8gIC8qIFRyeSB0byBndWVzcyBpZiBpdCBpcyBwcm9maXRhYmxlIHRvIHN0b3AgdGhlIGN1cnJlbnQgYmxvY2sgaGVyZSAqL1xuLy8gIGlmICgocy5sYXN0X2xpdCAmIDB4MWZmZikgPT09IDAgJiYgcy5sZXZlbCA+IDIpIHtcbi8vICAgIC8qIENvbXB1dGUgYW4gdXBwZXIgYm91bmQgZm9yIHRoZSBjb21wcmVzc2VkIGxlbmd0aCAqL1xuLy8gICAgb3V0X2xlbmd0aCA9IHMubGFzdF9saXQqODtcbi8vICAgIGluX2xlbmd0aCA9IHMuc3Ryc3RhcnQgLSBzLmJsb2NrX3N0YXJ0O1xuLy9cbi8vICAgIGZvciAoZGNvZGUgPSAwOyBkY29kZSA8IERfQ09ERVM7IGRjb2RlKyspIHtcbi8vICAgICAgb3V0X2xlbmd0aCArPSBzLmR5bl9kdHJlZVtkY29kZSoyXS8qLkZyZXEqLyAqICg1ICsgZXh0cmFfZGJpdHNbZGNvZGVdKTtcbi8vICAgIH1cbi8vICAgIG91dF9sZW5ndGggPj4+PSAzO1xuLy8gICAgLy9UcmFjZXYoKHN0ZGVycixcIlxcbmxhc3RfbGl0ICV1LCBpbiAlbGQsIG91dCB+JWxkKCVsZCUlKSBcIixcbi8vICAgIC8vICAgICAgIHMtPmxhc3RfbGl0LCBpbl9sZW5ndGgsIG91dF9sZW5ndGgsXG4vLyAgICAvLyAgICAgICAxMDBMIC0gb3V0X2xlbmd0aCoxMDBML2luX2xlbmd0aCkpO1xuLy8gICAgaWYgKHMubWF0Y2hlcyA8IChzLmxhc3RfbGl0Pj4xKS8qaW50IC8yKi8gJiYgb3V0X2xlbmd0aCA8IChpbl9sZW5ndGg+PjEpLyppbnQgLzIqLykge1xuLy8gICAgICByZXR1cm4gdHJ1ZTtcbi8vICAgIH1cbi8vICB9XG4vLyNlbmRpZlxuXG4gIHJldHVybiAocy5sYXN0X2xpdCA9PT0gcy5saXRfYnVmc2l6ZSAtIDEpO1xuICAvKiBXZSBhdm9pZCBlcXVhbGl0eSB3aXRoIGxpdF9idWZzaXplIGJlY2F1c2Ugb2Ygd3JhcGFyb3VuZCBhdCA2NEtcbiAgICogb24gMTYgYml0IG1hY2hpbmVzIGFuZCBiZWNhdXNlIHN0b3JlZCBibG9ja3MgYXJlIHJlc3RyaWN0ZWQgdG9cbiAgICogNjRLLTEgYnl0ZXMuXG4gICAqL1xufVxuXG5leHBvcnRzLl90cl9pbml0ICA9IF90cl9pbml0O1xuZXhwb3J0cy5fdHJfc3RvcmVkX2Jsb2NrID0gX3RyX3N0b3JlZF9ibG9jaztcbmV4cG9ydHMuX3RyX2ZsdXNoX2Jsb2NrICA9IF90cl9mbHVzaF9ibG9jaztcbmV4cG9ydHMuX3RyX3RhbGx5ID0gX3RyX3RhbGx5O1xuZXhwb3J0cy5fdHJfYWxpZ24gPSBfdHJfYWxpZ247XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vIChDKSAxOTk1LTIwMTMgSmVhbi1sb3VwIEdhaWxseSBhbmQgTWFyayBBZGxlclxuLy8gKEMpIDIwMTQtMjAxNyBWaXRhbHkgUHV6cmluIGFuZCBBbmRyZXkgVHVwaXRzaW5cbi8vXG4vLyBUaGlzIHNvZnR3YXJlIGlzIHByb3ZpZGVkICdhcy1pcycsIHdpdGhvdXQgYW55IGV4cHJlc3Mgb3IgaW1wbGllZFxuLy8gd2FycmFudHkuIEluIG5vIGV2ZW50IHdpbGwgdGhlIGF1dGhvcnMgYmUgaGVsZCBsaWFibGUgZm9yIGFueSBkYW1hZ2VzXG4vLyBhcmlzaW5nIGZyb20gdGhlIHVzZSBvZiB0aGlzIHNvZnR3YXJlLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgZ3JhbnRlZCB0byBhbnlvbmUgdG8gdXNlIHRoaXMgc29mdHdhcmUgZm9yIGFueSBwdXJwb3NlLFxuLy8gaW5jbHVkaW5nIGNvbW1lcmNpYWwgYXBwbGljYXRpb25zLCBhbmQgdG8gYWx0ZXIgaXQgYW5kIHJlZGlzdHJpYnV0ZSBpdFxuLy8gZnJlZWx5LCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgcmVzdHJpY3Rpb25zOlxuLy9cbi8vIDEuIFRoZSBvcmlnaW4gb2YgdGhpcyBzb2Z0d2FyZSBtdXN0IG5vdCBiZSBtaXNyZXByZXNlbnRlZDsgeW91IG11c3Qgbm90XG4vLyAgIGNsYWltIHRoYXQgeW91IHdyb3RlIHRoZSBvcmlnaW5hbCBzb2Z0d2FyZS4gSWYgeW91IHVzZSB0aGlzIHNvZnR3YXJlXG4vLyAgIGluIGEgcHJvZHVjdCwgYW4gYWNrbm93bGVkZ21lbnQgaW4gdGhlIHByb2R1Y3QgZG9jdW1lbnRhdGlvbiB3b3VsZCBiZVxuLy8gICBhcHByZWNpYXRlZCBidXQgaXMgbm90IHJlcXVpcmVkLlxuLy8gMi4gQWx0ZXJlZCBzb3VyY2UgdmVyc2lvbnMgbXVzdCBiZSBwbGFpbmx5IG1hcmtlZCBhcyBzdWNoLCBhbmQgbXVzdCBub3QgYmVcbi8vICAgbWlzcmVwcmVzZW50ZWQgYXMgYmVpbmcgdGhlIG9yaWdpbmFsIHNvZnR3YXJlLlxuLy8gMy4gVGhpcyBub3RpY2UgbWF5IG5vdCBiZSByZW1vdmVkIG9yIGFsdGVyZWQgZnJvbSBhbnkgc291cmNlIGRpc3RyaWJ1dGlvbi5cblxuZnVuY3Rpb24gWlN0cmVhbSgpIHtcbiAgLyogbmV4dCBpbnB1dCBieXRlICovXG4gIHRoaXMuaW5wdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9pbiA9IDA7XG4gIC8qIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUgYXQgaW5wdXQgKi9cbiAgdGhpcy5hdmFpbF9pbiA9IDA7XG4gIC8qIHRvdGFsIG51bWJlciBvZiBpbnB1dCBieXRlcyByZWFkIHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX2luID0gMDtcbiAgLyogbmV4dCBvdXRwdXQgYnl0ZSBzaG91bGQgYmUgcHV0IHRoZXJlICovXG4gIHRoaXMub3V0cHV0ID0gbnVsbDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuICB0aGlzLm5leHRfb3V0ID0gMDtcbiAgLyogcmVtYWluaW5nIGZyZWUgc3BhY2UgYXQgb3V0cHV0ICovXG4gIHRoaXMuYXZhaWxfb3V0ID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGJ5dGVzIG91dHB1dCBzbyBmYXIgKi9cbiAgdGhpcy50b3RhbF9vdXQgPSAwO1xuICAvKiBsYXN0IGVycm9yIG1lc3NhZ2UsIE5VTEwgaWYgbm8gZXJyb3IgKi9cbiAgdGhpcy5tc2cgPSAnJy8qWl9OVUxMKi87XG4gIC8qIG5vdCB2aXNpYmxlIGJ5IGFwcGxpY2F0aW9ucyAqL1xuICB0aGlzLnN0YXRlID0gbnVsbDtcbiAgLyogYmVzdCBndWVzcyBhYm91dCB0aGUgZGF0YSB0eXBlOiBiaW5hcnkgb3IgdGV4dCAqL1xuICB0aGlzLmRhdGFfdHlwZSA9IDIvKlpfVU5LTk9XTiovO1xuICAvKiBhZGxlcjMyIHZhbHVlIG9mIHRoZSB1bmNvbXByZXNzZWQgZGF0YSAqL1xuICB0aGlzLmFkbGVyID0gMDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBaU3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAodHlwZW9mIHByb2Nlc3MgPT09ICd1bmRlZmluZWQnIHx8XG4gICAgIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHsgbmV4dFRpY2s6IG5leHRUaWNrIH07XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3Ncbn1cblxuZnVuY3Rpb24gbmV4dFRpY2soZm4sIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiY2FsbGJhY2tcIiBhcmd1bWVudCBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGFyZ3MsIGk7XG4gIHN3aXRjaCAobGVuKSB7XG4gIGNhc2UgMDpcbiAgY2FzZSAxOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcbiAgY2FzZSAyOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja09uZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XG4gICAgfSk7XG4gIGNhc2UgMzpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIpO1xuICAgIH0pO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVGhyZWUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICAgIH0pO1xuICBkZWZhdWx0OlxuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgaSA9IDA7XG4gICAgd2hpbGUgKGkgPCBhcmdzLmxlbmd0aCkge1xuICAgICAgYXJnc1tpKytdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2soKSB7XG4gICAgICBmbi5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9KTtcbiAgfVxufVxuXG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuRHVwbGV4XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG57XG4gIC8vIGF2b2lkIHNjb3BlIGNyZWVwLCB0aGUga2V5cyBhcnJheSBjYW4gdGhlbiBiZSBjb2xsZWN0ZWRcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXG4gIC8vIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLmFsbG93SGFsZk9wZW4gfHwgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG4gIHBuYS5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbkR1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIHRoaXMuZW5kKCk7XG5cbiAgcG5hLm5leHRUaWNrKGNiLCBlcnIpO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSBPYmplY3QuY3JlYXRlKHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pO1xuXG4gIC8vIFRoaXMgaXMgYSBoYWNrIHRvIG1ha2Ugc3VyZSB0aGF0IG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSBhbnlcbiAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgLy8gdGhlIHByZXBlbmRMaXN0ZW5lcigpIG1ldGhvZC4gVGhlIGdvYWwgaXMgdG8gZXZlbnR1YWxseSByZW1vdmUgdGhpcyBoYWNrLlxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG4gIHZhciBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHJlYWRhYmxlSHdtID0gb3B0aW9ucy5yZWFkYWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAocmVhZGFibGVId20gfHwgcmVhZGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSByZWFkYWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcG5hLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwbmEubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwbmEubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwbmEubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcG5hLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuXG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIHN0cmVhbS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgIGRlYnVnKCd3cmFwcGVkIGRhdGEnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcblxuICAgIC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHRoaXMuZW1pdC5iaW5kKHRoaXMsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHBuYS5uZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IE9iamVjdC5jcmVhdGUocmVxdWlyZSgnY29yZS11dGlsLWlzJykpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUgY2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJykpO1xuICB9XG5cbiAgdHMud3JpdGVjaHVuayA9IG51bGw7XG4gIHRzLndyaXRlY2IgPSBudWxsO1xuXG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07XG5cbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB0aHJvdyBuZXcgRXJyb3IoJ190cmFuc2Zvcm0oKSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLndyaXRlY2IgPSBjYjtcbiAgdHMud3JpdGVjaHVuayA9IGNodW5rO1xuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTtcblxuLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuXG4gIGlmICh0cy53cml0ZWNodW5rICE9PSBudWxsICYmIHRzLndyaXRlY2IgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBtYXJrIHRoYXQgd2UgbmVlZCBhIHRyYW5zZm9ybSwgc28gdGhhdCBhbnkgZGF0YSB0aGF0IGNvbWVzIGluXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXG4gICAgdHMubmVlZFRyYW5zZm9ybSA9IHRydWU7XG4gIH1cbn07XG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB2YXIgX3RoaXMyID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzMi5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7XG5cbiAgLy8gaWYgdGhlcmUncyBub3RoaW5nIGluIHRoZSB3cml0ZSBidWZmZXIsIHRoZW4gdGhhdCBtZWFuc1xuICAvLyB0aGF0IG5vdGhpbmcgbW9yZSB3aWxsIGV2ZXIgYmUgcHJvdmlkZWRcbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XG5cbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHBuYS5uZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gT2JqZWN0LmNyZWF0ZShyZXF1aXJlKCdjb3JlLXV0aWwtaXMnKSk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxuLyo8L3JlcGxhY2VtZW50PiovXG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnV0aWwuaW5oZXJpdHMoV3JpdGFibGUsIFN0cmVhbSk7XG5cbmZ1bmN0aW9uIG5vcCgpIHt9XG5cbmZ1bmN0aW9uIFdyaXRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuICB2YXIgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7XG5cbiAgLy8gb2JqZWN0IHN0cmVhbSBmbGFnIHRvIGluZGljYXRlIHdoZXRoZXIgb3Igbm90IHRoaXMgc3RyZWFtXG4gIC8vIGNvbnRhaW5zIGJ1ZmZlcnMgb3Igb2JqZWN0cy5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIHdyaXRhYmxlSHdtID0gb3B0aW9ucy53cml0YWJsZUhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG5cbiAgaWYgKGh3bSB8fCBod20gPT09IDApIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bTtlbHNlIGlmIChpc0R1cGxleCAmJiAod3JpdGFibGVId20gfHwgd3JpdGFibGVId20gPT09IDApKSB0aGlzLmhpZ2hXYXRlck1hcmsgPSB3cml0YWJsZUh3bTtlbHNlIHRoaXMuaGlnaFdhdGVyTWFyayA9IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwbmEubmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pO1xuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcG5hLm5leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHBuYS5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHBuYS5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcG5hLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTtcblxuaWYgKHV0aWwgJiYgdXRpbC5pbnNwZWN0ICYmIHV0aWwuaW5zcGVjdC5jdXN0b20pIHtcbiAgbW9kdWxlLmV4cG9ydHMucHJvdG90eXBlW3V0aWwuaW5zcGVjdC5jdXN0b21dID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYmogPSB1dGlsLmluc3BlY3QoeyBsZW5ndGg6IHRoaXMubGVuZ3RoIH0pO1xuICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgKyBvYmo7XG4gIH07XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcG5hID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xuICAgICAgcG5hLm5leHRUaWNrKGVtaXRFcnJvck5ULCB0aGlzLCBlcnIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHBuYS5uZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmlmIChwcm9jZXNzLmVudi5SRUFEQUJMRV9TVFJFQU0gPT09ICdkaXNhYmxlJyAmJiBTdHJlYW0pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG4gIGV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFN0cmVhbS5SZWFkYWJsZTtcbiAgZXhwb3J0cy5SZWFkYWJsZSA9IFN0cmVhbS5SZWFkYWJsZTtcbiAgZXhwb3J0cy5Xcml0YWJsZSA9IFN0cmVhbS5Xcml0YWJsZTtcbiAgZXhwb3J0cy5EdXBsZXggPSBTdHJlYW0uRHVwbGV4O1xuICBleHBvcnRzLlRyYW5zZm9ybSA9IFN0cmVhbS5UcmFuc2Zvcm07XG4gIGV4cG9ydHMuUGFzc1Rocm91Z2ggPSBTdHJlYW0uUGFzc1Rocm91Z2g7XG4gIGV4cG9ydHMuU3RyZWFtID0gU3RyZWFtO1xufSBlbHNlIHtcbiAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuICBleHBvcnRzLlN0cmVhbSA9IFN0cmVhbSB8fCBleHBvcnRzO1xuICBleHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbiAgZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiAgZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuICBleHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG4gIGV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKFwic3RyZWFtXCIpXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKFwiLi9saWIvX3N0cmVhbV93cml0YWJsZS5qc1wiKVxuXG5pZiAocHJvY2Vzcy5lbnYuUkVBREFCTEVfU1RSRUFNID09PSAnZGlzYWJsZScpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBTdHJlYW0gJiYgU3RyZWFtLldyaXRhYmxlIHx8IFdyaXRhYmxlXG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlXG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xuXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5pbmhlcml0cyhTdHJlYW0sIEVFKTtcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xuU3RyZWFtLldyaXRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLmpzJyk7XG5TdHJlYW0uRHVwbGV4ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL2R1cGxleC5qcycpO1xuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcblN0cmVhbS5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcycpO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxuU3RyZWFtLlN0cmVhbSA9IFN0cmVhbTtcblxuXG5cbi8vIG9sZC1zdHlsZSBzdHJlYW1zLiAgTm90ZSB0aGF0IHRoZSBwaXBlIG1ldGhvZCAodGhlIG9ubHkgcmVsZXZhbnRcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXG5cbmZ1bmN0aW9uIFN0cmVhbSgpIHtcbiAgRUUuY2FsbCh0aGlzKTtcbn1cblxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xuICB2YXIgc291cmNlID0gdGhpcztcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBpZiAoZGVzdC53cml0YWJsZSkge1xuICAgICAgaWYgKGZhbHNlID09PSBkZXN0LndyaXRlKGNodW5rKSAmJiBzb3VyY2UucGF1c2UpIHtcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRyYWluKCkge1xuICAgIGlmIChzb3VyY2UucmVhZGFibGUgJiYgc291cmNlLnJlc3VtZSkge1xuICAgICAgc291cmNlLnJlc3VtZSgpO1xuICAgIH1cbiAgfVxuXG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG5cbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxuICAvLyBzb3VyY2UgZ2V0cyB0aGUgJ2VuZCcgb3IgJ2Nsb3NlJyBldmVudHMuICBPbmx5IGRlc3QuZW5kKCkgb25jZS5cbiAgaWYgKCFkZXN0Ll9pc1N0ZGlvICYmICghb3B0aW9ucyB8fCBvcHRpb25zLmVuZCAhPT0gZmFsc2UpKSB7XG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICB9XG5cbiAgdmFyIGRpZE9uRW5kID0gZmFsc2U7XG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgaWYgKHR5cGVvZiBkZXN0LmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIGRlc3QuZGVzdHJveSgpO1xuICB9XG5cbiAgLy8gZG9uJ3QgbGVhdmUgZGFuZ2xpbmcgcGlwZXMgd2hlbiB0aGVyZSBhcmUgZXJyb3JzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgY2xlYW51cCgpO1xuICAgIGlmIChFRS5saXN0ZW5lckNvdW50KHRoaXMsICdlcnJvcicpID09PSAwKSB7XG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgZGVzdC5vbignZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyByZW1vdmUgYWxsIHRoZSBldmVudCBsaXN0ZW5lcnMgdGhhdCB3ZXJlIGFkZGVkLlxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuICB9XG5cbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgc291cmNlLm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc291cmNlKTtcblxuICAvLyBBbGxvdyBmb3IgdW5peC1saWtlIHVzYWdlOiBBLnBpcGUoQikucGlwZShDKVxuICByZXR1cm4gZGVzdDtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIndXNlIHN0cmljdCc7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBoYXNGbGFnID0gcmVxdWlyZSgnaGFzLWZsYWcnKTtcblxuY29uc3QgZW52ID0gcHJvY2Vzcy5lbnY7XG5cbmxldCBmb3JjZUNvbG9yO1xuaWYgKGhhc0ZsYWcoJ25vLWNvbG9yJykgfHxcblx0aGFzRmxhZygnbm8tY29sb3JzJykgfHxcblx0aGFzRmxhZygnY29sb3I9ZmFsc2UnKSkge1xuXHRmb3JjZUNvbG9yID0gZmFsc2U7XG59IGVsc2UgaWYgKGhhc0ZsYWcoJ2NvbG9yJykgfHxcblx0aGFzRmxhZygnY29sb3JzJykgfHxcblx0aGFzRmxhZygnY29sb3I9dHJ1ZScpIHx8XG5cdGhhc0ZsYWcoJ2NvbG9yPWFsd2F5cycpKSB7XG5cdGZvcmNlQ29sb3IgPSB0cnVlO1xufVxuaWYgKCdGT1JDRV9DT0xPUicgaW4gZW52KSB7XG5cdGZvcmNlQ29sb3IgPSBlbnYuRk9SQ0VfQ09MT1IubGVuZ3RoID09PSAwIHx8IHBhcnNlSW50KGVudi5GT1JDRV9DT0xPUiwgMTApICE9PSAwO1xufVxuXG5mdW5jdGlvbiB0cmFuc2xhdGVMZXZlbChsZXZlbCkge1xuXHRpZiAobGV2ZWwgPT09IDApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGxldmVsLFxuXHRcdGhhc0Jhc2ljOiB0cnVlLFxuXHRcdGhhczI1NjogbGV2ZWwgPj0gMixcblx0XHRoYXMxNm06IGxldmVsID49IDNcblx0fTtcbn1cblxuZnVuY3Rpb24gc3VwcG9ydHNDb2xvcihzdHJlYW0pIHtcblx0aWYgKGZvcmNlQ29sb3IgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIDA7XG5cdH1cblxuXHRpZiAoaGFzRmxhZygnY29sb3I9MTZtJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj1mdWxsJykgfHxcblx0XHRoYXNGbGFnKCdjb2xvcj10cnVlY29sb3InKSkge1xuXHRcdHJldHVybiAzO1xuXHR9XG5cblx0aWYgKGhhc0ZsYWcoJ2NvbG9yPTI1NicpKSB7XG5cdFx0cmV0dXJuIDI7XG5cdH1cblxuXHRpZiAoc3RyZWFtICYmICFzdHJlYW0uaXNUVFkgJiYgZm9yY2VDb2xvciAhPT0gdHJ1ZSkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Y29uc3QgbWluID0gZm9yY2VDb2xvciA/IDEgOiAwO1xuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XG5cdFx0Ly8gTm9kZS5qcyA3LjUuMCBpcyB0aGUgZmlyc3QgdmVyc2lvbiBvZiBOb2RlLmpzIHRvIGluY2x1ZGUgYSBwYXRjaCB0b1xuXHRcdC8vIGxpYnV2IHRoYXQgZW5hYmxlcyAyNTYgY29sb3Igb3V0cHV0IG9uIFdpbmRvd3MuIEFueXRoaW5nIGVhcmxpZXIgYW5kIGl0XG5cdFx0Ly8gd29uJ3Qgd29yay4gSG93ZXZlciwgaGVyZSB3ZSB0YXJnZXQgTm9kZS5qcyA4IGF0IG1pbmltdW0gYXMgaXQgaXMgYW4gTFRTXG5cdFx0Ly8gcmVsZWFzZSwgYW5kIE5vZGUuanMgNyBpcyBub3QuIFdpbmRvd3MgMTAgYnVpbGQgMTA1ODYgaXMgdGhlIGZpcnN0IFdpbmRvd3Ncblx0XHQvLyByZWxlYXNlIHRoYXQgc3VwcG9ydHMgMjU2IGNvbG9ycy4gV2luZG93cyAxMCBidWlsZCAxNDkzMSBpcyB0aGUgZmlyc3QgcmVsZWFzZVxuXHRcdC8vIHRoYXQgc3VwcG9ydHMgMTZtL1RydWVDb2xvci5cblx0XHRjb25zdCBvc1JlbGVhc2UgPSBvcy5yZWxlYXNlKCkuc3BsaXQoJy4nKTtcblx0XHRpZiAoXG5cdFx0XHROdW1iZXIocHJvY2Vzcy52ZXJzaW9ucy5ub2RlLnNwbGl0KCcuJylbMF0pID49IDggJiZcblx0XHRcdE51bWJlcihvc1JlbGVhc2VbMF0pID49IDEwICYmXG5cdFx0XHROdW1iZXIob3NSZWxlYXNlWzJdKSA+PSAxMDU4NlxuXHRcdCkge1xuXHRcdFx0cmV0dXJuIE51bWJlcihvc1JlbGVhc2VbMl0pID49IDE0OTMxID8gMyA6IDI7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIDE7XG5cdH1cblxuXHRpZiAoJ0NJJyBpbiBlbnYpIHtcblx0XHRpZiAoWydUUkFWSVMnLCAnQ0lSQ0xFQ0knLCAnQVBQVkVZT1InLCAnR0lUTEFCX0NJJ10uc29tZShzaWduID0+IHNpZ24gaW4gZW52KSB8fCBlbnYuQ0lfTkFNRSA9PT0gJ2NvZGVzaGlwJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdGlmICgnVEVBTUNJVFlfVkVSU0lPTicgaW4gZW52KSB7XG5cdFx0cmV0dXJuIC9eKDlcXC4oMCpbMS05XVxcZCopXFwufFxcZHsyLH1cXC4pLy50ZXN0KGVudi5URUFNQ0lUWV9WRVJTSU9OKSA/IDEgOiAwO1xuXHR9XG5cblx0aWYgKGVudi5DT0xPUlRFUk0gPT09ICd0cnVlY29sb3InKSB7XG5cdFx0cmV0dXJuIDM7XG5cdH1cblxuXHRpZiAoJ1RFUk1fUFJPR1JBTScgaW4gZW52KSB7XG5cdFx0Y29uc3QgdmVyc2lvbiA9IHBhcnNlSW50KChlbnYuVEVSTV9QUk9HUkFNX1ZFUlNJT04gfHwgJycpLnNwbGl0KCcuJylbMF0sIDEwKTtcblxuXHRcdHN3aXRjaCAoZW52LlRFUk1fUFJPR1JBTSkge1xuXHRcdFx0Y2FzZSAnaVRlcm0uYXBwJzpcblx0XHRcdFx0cmV0dXJuIHZlcnNpb24gPj0gMyA/IDMgOiAyO1xuXHRcdFx0Y2FzZSAnQXBwbGVfVGVybWluYWwnOlxuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdC8vIE5vIGRlZmF1bHRcblx0XHR9XG5cdH1cblxuXHRpZiAoLy0yNTYoY29sb3IpPyQvaS50ZXN0KGVudi5URVJNKSkge1xuXHRcdHJldHVybiAyO1xuXHR9XG5cblx0aWYgKC9ec2NyZWVufF54dGVybXxednQxMDB8XnZ0MjIwfF5yeHZ0fGNvbG9yfGFuc2l8Y3lnd2lufGxpbnV4L2kudGVzdChlbnYuVEVSTSkpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmICgnQ09MT1JURVJNJyBpbiBlbnYpIHtcblx0XHRyZXR1cm4gMTtcblx0fVxuXG5cdGlmIChlbnYuVEVSTSA9PT0gJ2R1bWInKSB7XG5cdFx0cmV0dXJuIG1pbjtcblx0fVxuXG5cdHJldHVybiBtaW47XG59XG5cbmZ1bmN0aW9uIGdldFN1cHBvcnRMZXZlbChzdHJlYW0pIHtcblx0Y29uc3QgbGV2ZWwgPSBzdXBwb3J0c0NvbG9yKHN0cmVhbSk7XG5cdHJldHVybiB0cmFuc2xhdGVMZXZlbChsZXZlbCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuXHRzdXBwb3J0c0NvbG9yOiBnZXRTdXBwb3J0TGV2ZWwsXG5cdHN0ZG91dDogZ2V0U3VwcG9ydExldmVsKHByb2Nlc3Muc3Rkb3V0KSxcblx0c3RkZXJyOiBnZXRTdXBwb3J0TGV2ZWwocHJvY2Vzcy5zdGRlcnIpXG59O1xuIiwiZXhwb3J0cy5pc2F0dHkgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcblxuZnVuY3Rpb24gUmVhZFN0cmVhbSgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCd0dHkuUmVhZFN0cmVhbSBpcyBub3QgaW1wbGVtZW50ZWQnKTtcbn1cbmV4cG9ydHMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW07XG5cbmZ1bmN0aW9uIFdyaXRlU3RyZWFtKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ3R0eS5SZWFkU3RyZWFtIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufVxuZXhwb3J0cy5Xcml0ZVN0cmVhbSA9IFdyaXRlU3RyZWFtO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHB1bnljb2RlID0gcmVxdWlyZSgncHVueWNvZGUnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbmV4cG9ydHMucGFyc2UgPSB1cmxQYXJzZTtcbmV4cG9ydHMucmVzb2x2ZSA9IHVybFJlc29sdmU7XG5leHBvcnRzLnJlc29sdmVPYmplY3QgPSB1cmxSZXNvbHZlT2JqZWN0O1xuZXhwb3J0cy5mb3JtYXQgPSB1cmxGb3JtYXQ7XG5cbmV4cG9ydHMuVXJsID0gVXJsO1xuXG5mdW5jdGlvbiBVcmwoKSB7XG4gIHRoaXMucHJvdG9jb2wgPSBudWxsO1xuICB0aGlzLnNsYXNoZXMgPSBudWxsO1xuICB0aGlzLmF1dGggPSBudWxsO1xuICB0aGlzLmhvc3QgPSBudWxsO1xuICB0aGlzLnBvcnQgPSBudWxsO1xuICB0aGlzLmhvc3RuYW1lID0gbnVsbDtcbiAgdGhpcy5oYXNoID0gbnVsbDtcbiAgdGhpcy5zZWFyY2ggPSBudWxsO1xuICB0aGlzLnF1ZXJ5ID0gbnVsbDtcbiAgdGhpcy5wYXRobmFtZSA9IG51bGw7XG4gIHRoaXMucGF0aCA9IG51bGw7XG4gIHRoaXMuaHJlZiA9IG51bGw7XG59XG5cbi8vIFJlZmVyZW5jZTogUkZDIDM5ODYsIFJGQyAxODA4LCBSRkMgMjM5NlxuXG4vLyBkZWZpbmUgdGhlc2UgaGVyZSBzbyBhdCBsZWFzdCB0aGV5IG9ubHkgaGF2ZSB0byBiZVxuLy8gY29tcGlsZWQgb25jZSBvbiB0aGUgZmlyc3QgbW9kdWxlIGxvYWQuXG52YXIgcHJvdG9jb2xQYXR0ZXJuID0gL14oW2EtejAtOS4rLV0rOikvaSxcbiAgICBwb3J0UGF0dGVybiA9IC86WzAtOV0qJC8sXG5cbiAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIGEgc2ltcGxlIHBhdGggVVJMXG4gICAgc2ltcGxlUGF0aFBhdHRlcm4gPSAvXihcXC9cXC8/KD8hXFwvKVteXFw/XFxzXSopKFxcP1teXFxzXSopPyQvLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgcmVzZXJ2ZWQgZm9yIGRlbGltaXRpbmcgVVJMcy5cbiAgICAvLyBXZSBhY3R1YWxseSBqdXN0IGF1dG8tZXNjYXBlIHRoZXNlLlxuICAgIGRlbGltcyA9IFsnPCcsICc+JywgJ1wiJywgJ2AnLCAnICcsICdcXHInLCAnXFxuJywgJ1xcdCddLFxuXG4gICAgLy8gUkZDIDIzOTY6IGNoYXJhY3RlcnMgbm90IGFsbG93ZWQgZm9yIHZhcmlvdXMgcmVhc29ucy5cbiAgICB1bndpc2UgPSBbJ3snLCAnfScsICd8JywgJ1xcXFwnLCAnXicsICdgJ10uY29uY2F0KGRlbGltcyksXG5cbiAgICAvLyBBbGxvd2VkIGJ5IFJGQ3MsIGJ1dCBjYXVzZSBvZiBYU1MgYXR0YWNrcy4gIEFsd2F5cyBlc2NhcGUgdGhlc2UuXG4gICAgYXV0b0VzY2FwZSA9IFsnXFwnJ10uY29uY2F0KHVud2lzZSksXG4gICAgLy8gQ2hhcmFjdGVycyB0aGF0IGFyZSBuZXZlciBldmVyIGFsbG93ZWQgaW4gYSBob3N0bmFtZS5cbiAgICAvLyBOb3RlIHRoYXQgYW55IGludmFsaWQgY2hhcnMgYXJlIGFsc28gaGFuZGxlZCwgYnV0IHRoZXNlXG4gICAgLy8gYXJlIHRoZSBvbmVzIHRoYXQgYXJlICpleHBlY3RlZCogdG8gYmUgc2Vlbiwgc28gd2UgZmFzdC1wYXRoXG4gICAgLy8gdGhlbS5cbiAgICBub25Ib3N0Q2hhcnMgPSBbJyUnLCAnLycsICc/JywgJzsnLCAnIyddLmNvbmNhdChhdXRvRXNjYXBlKSxcbiAgICBob3N0RW5kaW5nQ2hhcnMgPSBbJy8nLCAnPycsICcjJ10sXG4gICAgaG9zdG5hbWVNYXhMZW4gPSAyNTUsXG4gICAgaG9zdG5hbWVQYXJ0UGF0dGVybiA9IC9eWythLXowLTlBLVpfLV17MCw2M30kLyxcbiAgICBob3N0bmFtZVBhcnRTdGFydCA9IC9eKFsrYS16MC05QS1aXy1dezAsNjN9KSguKikkLyxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBjYW4gYWxsb3cgXCJ1bnNhZmVcIiBhbmQgXCJ1bndpc2VcIiBjaGFycy5cbiAgICB1bnNhZmVQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IG5ldmVyIGhhdmUgYSBob3N0bmFtZS5cbiAgICBob3N0bGVzc1Byb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgYWx3YXlzIGNvbnRhaW4gYSAvLyBiaXQuXG4gICAgc2xhc2hlZFByb3RvY29sID0ge1xuICAgICAgJ2h0dHAnOiB0cnVlLFxuICAgICAgJ2h0dHBzJzogdHJ1ZSxcbiAgICAgICdmdHAnOiB0cnVlLFxuICAgICAgJ2dvcGhlcic6IHRydWUsXG4gICAgICAnZmlsZSc6IHRydWUsXG4gICAgICAnaHR0cDonOiB0cnVlLFxuICAgICAgJ2h0dHBzOic6IHRydWUsXG4gICAgICAnZnRwOic6IHRydWUsXG4gICAgICAnZ29waGVyOic6IHRydWUsXG4gICAgICAnZmlsZTonOiB0cnVlXG4gICAgfSxcbiAgICBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5cbmZ1bmN0aW9uIHVybFBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKHVybCAmJiB1dGlsLmlzT2JqZWN0KHVybCkgJiYgdXJsIGluc3RhbmNlb2YgVXJsKSByZXR1cm4gdXJsO1xuXG4gIHZhciB1ID0gbmV3IFVybDtcbiAgdS5wYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KTtcbiAgcmV0dXJuIHU7XG59XG5cblVybC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbih1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICghdXRpbC5pc1N0cmluZyh1cmwpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhcmFtZXRlciAndXJsJyBtdXN0IGJlIGEgc3RyaW5nLCBub3QgXCIgKyB0eXBlb2YgdXJsKTtcbiAgfVxuXG4gIC8vIENvcHkgY2hyb21lLCBJRSwgb3BlcmEgYmFja3NsYXNoLWhhbmRsaW5nIGJlaGF2aW9yLlxuICAvLyBCYWNrIHNsYXNoZXMgYmVmb3JlIHRoZSBxdWVyeSBzdHJpbmcgZ2V0IGNvbnZlcnRlZCB0byBmb3J3YXJkIHNsYXNoZXNcbiAgLy8gU2VlOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjU5MTZcbiAgdmFyIHF1ZXJ5SW5kZXggPSB1cmwuaW5kZXhPZignPycpLFxuICAgICAgc3BsaXR0ZXIgPVxuICAgICAgICAgIChxdWVyeUluZGV4ICE9PSAtMSAmJiBxdWVyeUluZGV4IDwgdXJsLmluZGV4T2YoJyMnKSkgPyAnPycgOiAnIycsXG4gICAgICB1U3BsaXQgPSB1cmwuc3BsaXQoc3BsaXR0ZXIpLFxuICAgICAgc2xhc2hSZWdleCA9IC9cXFxcL2c7XG4gIHVTcGxpdFswXSA9IHVTcGxpdFswXS5yZXBsYWNlKHNsYXNoUmVnZXgsICcvJyk7XG4gIHVybCA9IHVTcGxpdC5qb2luKHNwbGl0dGVyKTtcblxuICB2YXIgcmVzdCA9IHVybDtcblxuICAvLyB0cmltIGJlZm9yZSBwcm9jZWVkaW5nLlxuICAvLyBUaGlzIGlzIHRvIHN1cHBvcnQgcGFyc2Ugc3R1ZmYgbGlrZSBcIiAgaHR0cDovL2Zvby5jb20gIFxcblwiXG4gIHJlc3QgPSByZXN0LnRyaW0oKTtcblxuICBpZiAoIXNsYXNoZXNEZW5vdGVIb3N0ICYmIHVybC5zcGxpdCgnIycpLmxlbmd0aCA9PT0gMSkge1xuICAgIC8vIFRyeSBmYXN0IHBhdGggcmVnZXhwXG4gICAgdmFyIHNpbXBsZVBhdGggPSBzaW1wbGVQYXRoUGF0dGVybi5leGVjKHJlc3QpO1xuICAgIGlmIChzaW1wbGVQYXRoKSB7XG4gICAgICB0aGlzLnBhdGggPSByZXN0O1xuICAgICAgdGhpcy5ocmVmID0gcmVzdDtcbiAgICAgIHRoaXMucGF0aG5hbWUgPSBzaW1wbGVQYXRoWzFdO1xuICAgICAgaWYgKHNpbXBsZVBhdGhbMl0pIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSBzaW1wbGVQYXRoWzJdO1xuICAgICAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnNlYXJjaC5zdWJzdHIoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucXVlcnkgPSB0aGlzLnNlYXJjaC5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgICAgICB0aGlzLnF1ZXJ5ID0ge307XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH1cblxuICB2YXIgcHJvdG8gPSBwcm90b2NvbFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgaWYgKHByb3RvKSB7XG4gICAgcHJvdG8gPSBwcm90b1swXTtcbiAgICB2YXIgbG93ZXJQcm90byA9IHByb3RvLnRvTG93ZXJDYXNlKCk7XG4gICAgdGhpcy5wcm90b2NvbCA9IGxvd2VyUHJvdG87XG4gICAgcmVzdCA9IHJlc3Quc3Vic3RyKHByb3RvLmxlbmd0aCk7XG4gIH1cblxuICAvLyBmaWd1cmUgb3V0IGlmIGl0J3MgZ290IGEgaG9zdFxuICAvLyB1c2VyQHNlcnZlciBpcyAqYWx3YXlzKiBpbnRlcnByZXRlZCBhcyBhIGhvc3RuYW1lLCBhbmQgdXJsXG4gIC8vIHJlc29sdXRpb24gd2lsbCB0cmVhdCAvL2Zvby9iYXIgYXMgaG9zdD1mb28scGF0aD1iYXIgYmVjYXVzZSB0aGF0J3NcbiAgLy8gaG93IHRoZSBicm93c2VyIHJlc29sdmVzIHJlbGF0aXZlIFVSTHMuXG4gIGlmIChzbGFzaGVzRGVub3RlSG9zdCB8fCBwcm90byB8fCByZXN0Lm1hdGNoKC9eXFwvXFwvW15AXFwvXStAW15AXFwvXSsvKSkge1xuICAgIHZhciBzbGFzaGVzID0gcmVzdC5zdWJzdHIoMCwgMikgPT09ICcvLyc7XG4gICAgaWYgKHNsYXNoZXMgJiYgIShwcm90byAmJiBob3N0bGVzc1Byb3RvY29sW3Byb3RvXSkpIHtcbiAgICAgIHJlc3QgPSByZXN0LnN1YnN0cigyKTtcbiAgICAgIHRoaXMuc2xhc2hlcyA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFob3N0bGVzc1Byb3RvY29sW3Byb3RvXSAmJlxuICAgICAgKHNsYXNoZXMgfHwgKHByb3RvICYmICFzbGFzaGVkUHJvdG9jb2xbcHJvdG9dKSkpIHtcblxuICAgIC8vIHRoZXJlJ3MgYSBob3N0bmFtZS5cbiAgICAvLyB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgLywgPywgOywgb3IgIyBlbmRzIHRoZSBob3N0LlxuICAgIC8vXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gQCBpbiB0aGUgaG9zdG5hbWUsIHRoZW4gbm9uLWhvc3QgY2hhcnMgKmFyZSogYWxsb3dlZFxuICAgIC8vIHRvIHRoZSBsZWZ0IG9mIHRoZSBsYXN0IEAgc2lnbiwgdW5sZXNzIHNvbWUgaG9zdC1lbmRpbmcgY2hhcmFjdGVyXG4gICAgLy8gY29tZXMgKmJlZm9yZSogdGhlIEAtc2lnbi5cbiAgICAvLyBVUkxzIGFyZSBvYm5veGlvdXMuXG4gICAgLy9cbiAgICAvLyBleDpcbiAgICAvLyBodHRwOi8vYUBiQGMvID0+IHVzZXI6YUBiIGhvc3Q6Y1xuICAgIC8vIGh0dHA6Ly9hQGI/QGMgPT4gdXNlcjphIGhvc3Q6YyBwYXRoOi8/QGNcblxuICAgIC8vIHYwLjEyIFRPRE8oaXNhYWNzKTogVGhpcyBpcyBub3QgcXVpdGUgaG93IENocm9tZSBkb2VzIHRoaW5ncy5cbiAgICAvLyBSZXZpZXcgb3VyIHRlc3QgY2FzZSBhZ2FpbnN0IGJyb3dzZXJzIG1vcmUgY29tcHJlaGVuc2l2ZWx5LlxuXG4gICAgLy8gZmluZCB0aGUgZmlyc3QgaW5zdGFuY2Ugb2YgYW55IGhvc3RFbmRpbmdDaGFyc1xuICAgIHZhciBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0RW5kaW5nQ2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2YoaG9zdEVuZGluZ0NoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50LCBlaXRoZXIgd2UgaGF2ZSBhbiBleHBsaWNpdCBwb2ludCB3aGVyZSB0aGVcbiAgICAvLyBhdXRoIHBvcnRpb24gY2Fubm90IGdvIHBhc3QsIG9yIHRoZSBsYXN0IEAgY2hhciBpcyB0aGUgZGVjaWRlci5cbiAgICB2YXIgYXV0aCwgYXRTaWduO1xuICAgIGlmIChob3N0RW5kID09PSAtMSkge1xuICAgICAgLy8gYXRTaWduIGNhbiBiZSBhbnl3aGVyZS5cbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYXRTaWduIG11c3QgYmUgaW4gYXV0aCBwb3J0aW9uLlxuICAgICAgLy8gaHR0cDovL2FAYi9jQGQgPT4gaG9zdDpiIGF1dGg6YSBwYXRoOi9jQGRcbiAgICAgIGF0U2lnbiA9IHJlc3QubGFzdEluZGV4T2YoJ0AnLCBob3N0RW5kKTtcbiAgICB9XG5cbiAgICAvLyBOb3cgd2UgaGF2ZSBhIHBvcnRpb24gd2hpY2ggaXMgZGVmaW5pdGVseSB0aGUgYXV0aC5cbiAgICAvLyBQdWxsIHRoYXQgb2ZmLlxuICAgIGlmIChhdFNpZ24gIT09IC0xKSB7XG4gICAgICBhdXRoID0gcmVzdC5zbGljZSgwLCBhdFNpZ24pO1xuICAgICAgcmVzdCA9IHJlc3Quc2xpY2UoYXRTaWduICsgMSk7XG4gICAgICB0aGlzLmF1dGggPSBkZWNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgfVxuXG4gICAgLy8gdGhlIGhvc3QgaXMgdGhlIHJlbWFpbmluZyB0byB0aGUgbGVmdCBvZiB0aGUgZmlyc3Qgbm9uLWhvc3QgY2hhclxuICAgIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vbkhvc3RDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihub25Ib3N0Q2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cbiAgICAvLyBpZiB3ZSBzdGlsbCBoYXZlIG5vdCBoaXQgaXQsIHRoZW4gdGhlIGVudGlyZSB0aGluZyBpcyBhIGhvc3QuXG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKVxuICAgICAgaG9zdEVuZCA9IHJlc3QubGVuZ3RoO1xuXG4gICAgdGhpcy5ob3N0ID0gcmVzdC5zbGljZSgwLCBob3N0RW5kKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZShob3N0RW5kKTtcblxuICAgIC8vIHB1bGwgb3V0IHBvcnQuXG4gICAgdGhpcy5wYXJzZUhvc3QoKTtcblxuICAgIC8vIHdlJ3ZlIGluZGljYXRlZCB0aGF0IHRoZXJlIGlzIGEgaG9zdG5hbWUsXG4gICAgLy8gc28gZXZlbiBpZiBpdCdzIGVtcHR5LCBpdCBoYXMgdG8gYmUgcHJlc2VudC5cbiAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcblxuICAgIC8vIGlmIGhvc3RuYW1lIGJlZ2lucyB3aXRoIFsgYW5kIGVuZHMgd2l0aCBdXG4gICAgLy8gYXNzdW1lIHRoYXQgaXQncyBhbiBJUHY2IGFkZHJlc3MuXG4gICAgdmFyIGlwdjZIb3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVbMF0gPT09ICdbJyAmJlxuICAgICAgICB0aGlzLmhvc3RuYW1lW3RoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMV0gPT09ICddJztcblxuICAgIC8vIHZhbGlkYXRlIGEgbGl0dGxlLlxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB2YXIgaG9zdHBhcnRzID0gdGhpcy5ob3N0bmFtZS5zcGxpdCgvXFwuLyk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGhvc3RwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIHBhcnQgPSBob3N0cGFydHNbaV07XG4gICAgICAgIGlmICghcGFydCkgY29udGludWU7XG4gICAgICAgIGlmICghcGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgIHZhciBuZXdwYXJ0ID0gJyc7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGsgPSBwYXJ0Lmxlbmd0aDsgaiA8IGs7IGorKykge1xuICAgICAgICAgICAgaWYgKHBhcnQuY2hhckNvZGVBdChqKSA+IDEyNykge1xuICAgICAgICAgICAgICAvLyB3ZSByZXBsYWNlIG5vbi1BU0NJSSBjaGFyIHdpdGggYSB0ZW1wb3JhcnkgcGxhY2Vob2xkZXJcbiAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0aGlzIHRvIG1ha2Ugc3VyZSBzaXplIG9mIGhvc3RuYW1lIGlzIG5vdFxuICAgICAgICAgICAgICAvLyBicm9rZW4gYnkgcmVwbGFjaW5nIG5vbi1BU0NJSSBieSBub3RoaW5nXG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gJ3gnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3cGFydCArPSBwYXJ0W2pdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyB3ZSB0ZXN0IGFnYWluIHdpdGggQVNDSUkgY2hhciBvbmx5XG4gICAgICAgICAgaWYgKCFuZXdwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgICB2YXIgdmFsaWRQYXJ0cyA9IGhvc3RwYXJ0cy5zbGljZSgwLCBpKTtcbiAgICAgICAgICAgIHZhciBub3RIb3N0ID0gaG9zdHBhcnRzLnNsaWNlKGkgKyAxKTtcbiAgICAgICAgICAgIHZhciBiaXQgPSBwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFN0YXJ0KTtcbiAgICAgICAgICAgIGlmIChiaXQpIHtcbiAgICAgICAgICAgICAgdmFsaWRQYXJ0cy5wdXNoKGJpdFsxXSk7XG4gICAgICAgICAgICAgIG5vdEhvc3QudW5zaGlmdChiaXRbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vdEhvc3QubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIHJlc3QgPSAnLycgKyBub3RIb3N0LmpvaW4oJy4nKSArIHJlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmhvc3RuYW1lID0gdmFsaWRQYXJ0cy5qb2luKCcuJyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5ob3N0bmFtZS5sZW5ndGggPiBob3N0bmFtZU1heExlbikge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9ICcnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBob3N0bmFtZXMgYXJlIGFsd2F5cyBsb3dlciBjYXNlLlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgLy8gSUROQSBTdXBwb3J0OiBSZXR1cm5zIGEgcHVueWNvZGVkIHJlcHJlc2VudGF0aW9uIG9mIFwiZG9tYWluXCIuXG4gICAgICAvLyBJdCBvbmx5IGNvbnZlcnRzIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB0aGF0XG4gICAgICAvLyBoYXZlIG5vbi1BU0NJSSBjaGFyYWN0ZXJzLCBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmXG4gICAgICAvLyB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQgYWxyZWFkeSBpcyBBU0NJSS1vbmx5LlxuICAgICAgdGhpcy5ob3N0bmFtZSA9IHB1bnljb2RlLnRvQVNDSUkodGhpcy5ob3N0bmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHAgPSB0aGlzLnBvcnQgPyAnOicgKyB0aGlzLnBvcnQgOiAnJztcbiAgICB2YXIgaCA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG4gICAgdGhpcy5ob3N0ID0gaCArIHA7XG4gICAgdGhpcy5ocmVmICs9IHRoaXMuaG9zdDtcblxuICAgIC8vIHN0cmlwIFsgYW5kIF0gZnJvbSB0aGUgaG9zdG5hbWVcbiAgICAvLyB0aGUgaG9zdCBmaWVsZCBzdGlsbCByZXRhaW5zIHRoZW0sIHRob3VnaFxuICAgIGlmIChpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnN1YnN0cigxLCB0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDIpO1xuICAgICAgaWYgKHJlc3RbMF0gIT09ICcvJykge1xuICAgICAgICByZXN0ID0gJy8nICsgcmVzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBub3cgcmVzdCBpcyBzZXQgdG8gdGhlIHBvc3QtaG9zdCBzdHVmZi5cbiAgLy8gY2hvcCBvZmYgYW55IGRlbGltIGNoYXJzLlxuICBpZiAoIXVuc2FmZVByb3RvY29sW2xvd2VyUHJvdG9dKSB7XG5cbiAgICAvLyBGaXJzdCwgbWFrZSAxMDAlIHN1cmUgdGhhdCBhbnkgXCJhdXRvRXNjYXBlXCIgY2hhcnMgZ2V0XG4gICAgLy8gZXNjYXBlZCwgZXZlbiBpZiBlbmNvZGVVUklDb21wb25lbnQgZG9lc24ndCB0aGluayB0aGV5XG4gICAgLy8gbmVlZCB0byBiZS5cbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGF1dG9Fc2NhcGUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICB2YXIgYWUgPSBhdXRvRXNjYXBlW2ldO1xuICAgICAgaWYgKHJlc3QuaW5kZXhPZihhZSkgPT09IC0xKVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIHZhciBlc2MgPSBlbmNvZGVVUklDb21wb25lbnQoYWUpO1xuICAgICAgaWYgKGVzYyA9PT0gYWUpIHtcbiAgICAgICAgZXNjID0gZXNjYXBlKGFlKTtcbiAgICAgIH1cbiAgICAgIHJlc3QgPSByZXN0LnNwbGl0KGFlKS5qb2luKGVzYyk7XG4gICAgfVxuICB9XG5cblxuICAvLyBjaG9wIG9mZiBmcm9tIHRoZSB0YWlsIGZpcnN0LlxuICB2YXIgaGFzaCA9IHJlc3QuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaCAhPT0gLTEpIHtcbiAgICAvLyBnb3QgYSBmcmFnbWVudCBzdHJpbmcuXG4gICAgdGhpcy5oYXNoID0gcmVzdC5zdWJzdHIoaGFzaCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgaGFzaCk7XG4gIH1cbiAgdmFyIHFtID0gcmVzdC5pbmRleE9mKCc/Jyk7XG4gIGlmIChxbSAhPT0gLTEpIHtcbiAgICB0aGlzLnNlYXJjaCA9IHJlc3Quc3Vic3RyKHFtKTtcbiAgICB0aGlzLnF1ZXJ5ID0gcmVzdC5zdWJzdHIocW0gKyAxKTtcbiAgICBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMucXVlcnkpO1xuICAgIH1cbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBxbSk7XG4gIH0gZWxzZSBpZiAocGFyc2VRdWVyeVN0cmluZykge1xuICAgIC8vIG5vIHF1ZXJ5IHN0cmluZywgYnV0IHBhcnNlUXVlcnlTdHJpbmcgc3RpbGwgcmVxdWVzdGVkXG4gICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICB0aGlzLnF1ZXJ5ID0ge307XG4gIH1cbiAgaWYgKHJlc3QpIHRoaXMucGF0aG5hbWUgPSByZXN0O1xuICBpZiAoc2xhc2hlZFByb3RvY29sW2xvd2VyUHJvdG9dICYmXG4gICAgICB0aGlzLmhvc3RuYW1lICYmICF0aGlzLnBhdGhuYW1lKSB7XG4gICAgdGhpcy5wYXRobmFtZSA9ICcvJztcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgaWYgKHRoaXMucGF0aG5hbWUgfHwgdGhpcy5zZWFyY2gpIHtcbiAgICB2YXIgcCA9IHRoaXMucGF0aG5hbWUgfHwgJyc7XG4gICAgdmFyIHMgPSB0aGlzLnNlYXJjaCB8fCAnJztcbiAgICB0aGlzLnBhdGggPSBwICsgcztcbiAgfVxuXG4gIC8vIGZpbmFsbHksIHJlY29uc3RydWN0IHRoZSBocmVmIGJhc2VkIG9uIHdoYXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICB0aGlzLmhyZWYgPSB0aGlzLmZvcm1hdCgpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGZvcm1hdCBhIHBhcnNlZCBvYmplY3QgaW50byBhIHVybCBzdHJpbmdcbmZ1bmN0aW9uIHVybEZvcm1hdChvYmopIHtcbiAgLy8gZW5zdXJlIGl0J3MgYW4gb2JqZWN0LCBhbmQgbm90IGEgc3RyaW5nIHVybC5cbiAgLy8gSWYgaXQncyBhbiBvYmosIHRoaXMgaXMgYSBuby1vcC5cbiAgLy8gdGhpcyB3YXksIHlvdSBjYW4gY2FsbCB1cmxfZm9ybWF0KCkgb24gc3RyaW5nc1xuICAvLyB0byBjbGVhbiB1cCBwb3RlbnRpYWxseSB3b25reSB1cmxzLlxuICBpZiAodXRpbC5pc1N0cmluZyhvYmopKSBvYmogPSB1cmxQYXJzZShvYmopO1xuICBpZiAoIShvYmogaW5zdGFuY2VvZiBVcmwpKSByZXR1cm4gVXJsLnByb3RvdHlwZS5mb3JtYXQuY2FsbChvYmopO1xuICByZXR1cm4gb2JqLmZvcm1hdCgpO1xufVxuXG5VcmwucHJvdG90eXBlLmZvcm1hdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgYXV0aCA9IHRoaXMuYXV0aCB8fCAnJztcbiAgaWYgKGF1dGgpIHtcbiAgICBhdXRoID0gZW5jb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIGF1dGggPSBhdXRoLnJlcGxhY2UoLyUzQS9pLCAnOicpO1xuICAgIGF1dGggKz0gJ0AnO1xuICB9XG5cbiAgdmFyIHByb3RvY29sID0gdGhpcy5wcm90b2NvbCB8fCAnJyxcbiAgICAgIHBhdGhuYW1lID0gdGhpcy5wYXRobmFtZSB8fCAnJyxcbiAgICAgIGhhc2ggPSB0aGlzLmhhc2ggfHwgJycsXG4gICAgICBob3N0ID0gZmFsc2UsXG4gICAgICBxdWVyeSA9ICcnO1xuXG4gIGlmICh0aGlzLmhvc3QpIHtcbiAgICBob3N0ID0gYXV0aCArIHRoaXMuaG9zdDtcbiAgfSBlbHNlIGlmICh0aGlzLmhvc3RuYW1lKSB7XG4gICAgaG9zdCA9IGF1dGggKyAodGhpcy5ob3N0bmFtZS5pbmRleE9mKCc6JykgPT09IC0xID9cbiAgICAgICAgdGhpcy5ob3N0bmFtZSA6XG4gICAgICAgICdbJyArIHRoaXMuaG9zdG5hbWUgKyAnXScpO1xuICAgIGlmICh0aGlzLnBvcnQpIHtcbiAgICAgIGhvc3QgKz0gJzonICsgdGhpcy5wb3J0O1xuICAgIH1cbiAgfVxuXG4gIGlmICh0aGlzLnF1ZXJ5ICYmXG4gICAgICB1dGlsLmlzT2JqZWN0KHRoaXMucXVlcnkpICYmXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLnF1ZXJ5KS5sZW5ndGgpIHtcbiAgICBxdWVyeSA9IHF1ZXJ5c3RyaW5nLnN0cmluZ2lmeSh0aGlzLnF1ZXJ5KTtcbiAgfVxuXG4gIHZhciBzZWFyY2ggPSB0aGlzLnNlYXJjaCB8fCAocXVlcnkgJiYgKCc/JyArIHF1ZXJ5KSkgfHwgJyc7XG5cbiAgaWYgKHByb3RvY29sICYmIHByb3RvY29sLnN1YnN0cigtMSkgIT09ICc6JykgcHJvdG9jb2wgKz0gJzonO1xuXG4gIC8vIG9ubHkgdGhlIHNsYXNoZWRQcm90b2NvbHMgZ2V0IHRoZSAvLy4gIE5vdCBtYWlsdG86LCB4bXBwOiwgZXRjLlxuICAvLyB1bmxlc3MgdGhleSBoYWQgdGhlbSB0byBiZWdpbiB3aXRoLlxuICBpZiAodGhpcy5zbGFzaGVzIHx8XG4gICAgICAoIXByb3RvY29sIHx8IHNsYXNoZWRQcm90b2NvbFtwcm90b2NvbF0pICYmIGhvc3QgIT09IGZhbHNlKSB7XG4gICAgaG9zdCA9ICcvLycgKyAoaG9zdCB8fCAnJyk7XG4gICAgaWYgKHBhdGhuYW1lICYmIHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSBwYXRobmFtZSA9ICcvJyArIHBhdGhuYW1lO1xuICB9IGVsc2UgaWYgKCFob3N0KSB7XG4gICAgaG9zdCA9ICcnO1xuICB9XG5cbiAgaWYgKGhhc2ggJiYgaGFzaC5jaGFyQXQoMCkgIT09ICcjJykgaGFzaCA9ICcjJyArIGhhc2g7XG4gIGlmIChzZWFyY2ggJiYgc2VhcmNoLmNoYXJBdCgwKSAhPT0gJz8nKSBzZWFyY2ggPSAnPycgKyBzZWFyY2g7XG5cbiAgcGF0aG5hbWUgPSBwYXRobmFtZS5yZXBsYWNlKC9bPyNdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChtYXRjaCk7XG4gIH0pO1xuICBzZWFyY2ggPSBzZWFyY2gucmVwbGFjZSgnIycsICclMjMnKTtcblxuICByZXR1cm4gcHJvdG9jb2wgKyBob3N0ICsgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZShzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlKHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgcmV0dXJuIHRoaXMucmVzb2x2ZU9iamVjdCh1cmxQYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpKS5mb3JtYXQoKTtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmVPYmplY3Qoc291cmNlLCByZWxhdGl2ZSkge1xuICBpZiAoIXNvdXJjZSkgcmV0dXJuIHJlbGF0aXZlO1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZU9iamVjdChyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZU9iamVjdCA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIGlmICh1dGlsLmlzU3RyaW5nKHJlbGF0aXZlKSkge1xuICAgIHZhciByZWwgPSBuZXcgVXJsKCk7XG4gICAgcmVsLnBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgcmVsYXRpdmUgPSByZWw7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gbmV3IFVybCgpO1xuICB2YXIgdGtleXMgPSBPYmplY3Qua2V5cyh0aGlzKTtcbiAgZm9yICh2YXIgdGsgPSAwOyB0ayA8IHRrZXlzLmxlbmd0aDsgdGsrKykge1xuICAgIHZhciB0a2V5ID0gdGtleXNbdGtdO1xuICAgIHJlc3VsdFt0a2V5XSA9IHRoaXNbdGtleV07XG4gIH1cblxuICAvLyBoYXNoIGlzIGFsd2F5cyBvdmVycmlkZGVuLCBubyBtYXR0ZXIgd2hhdC5cbiAgLy8gZXZlbiBocmVmPVwiXCIgd2lsbCByZW1vdmUgaXQuXG4gIHJlc3VsdC5oYXNoID0gcmVsYXRpdmUuaGFzaDtcblxuICAvLyBpZiB0aGUgcmVsYXRpdmUgdXJsIGlzIGVtcHR5LCB0aGVuIHRoZXJlJ3Mgbm90aGluZyBsZWZ0IHRvIGRvIGhlcmUuXG4gIGlmIChyZWxhdGl2ZS5ocmVmID09PSAnJykge1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBocmVmcyBsaWtlIC8vZm9vL2JhciBhbHdheXMgY3V0IHRvIHRoZSBwcm90b2NvbC5cbiAgaWYgKHJlbGF0aXZlLnNsYXNoZXMgJiYgIXJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgLy8gdGFrZSBldmVyeXRoaW5nIGV4Y2VwdCB0aGUgcHJvdG9jb2wgZnJvbSByZWxhdGl2ZVxuICAgIHZhciBya2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICBmb3IgKHZhciByayA9IDA7IHJrIDwgcmtleXMubGVuZ3RoOyByaysrKSB7XG4gICAgICB2YXIgcmtleSA9IHJrZXlzW3JrXTtcbiAgICAgIGlmIChya2V5ICE9PSAncHJvdG9jb2wnKVxuICAgICAgICByZXN1bHRbcmtleV0gPSByZWxhdGl2ZVtya2V5XTtcbiAgICB9XG5cbiAgICAvL3VybFBhcnNlIGFwcGVuZHMgdHJhaWxpbmcgLyB0byB1cmxzIGxpa2UgaHR0cDovL3d3dy5leGFtcGxlLmNvbVxuICAgIGlmIChzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXSAmJlxuICAgICAgICByZXN1bHQuaG9zdG5hbWUgJiYgIXJlc3VsdC5wYXRobmFtZSkge1xuICAgICAgcmVzdWx0LnBhdGggPSByZXN1bHQucGF0aG5hbWUgPSAnLyc7XG4gICAgfVxuXG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmIChyZWxhdGl2ZS5wcm90b2NvbCAmJiByZWxhdGl2ZS5wcm90b2NvbCAhPT0gcmVzdWx0LnByb3RvY29sKSB7XG4gICAgLy8gaWYgaXQncyBhIGtub3duIHVybCBwcm90b2NvbCwgdGhlbiBjaGFuZ2luZ1xuICAgIC8vIHRoZSBwcm90b2NvbCBkb2VzIHdlaXJkIHRoaW5nc1xuICAgIC8vIGZpcnN0LCBpZiBpdCdzIG5vdCBmaWxlOiwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBob3N0LFxuICAgIC8vIGFuZCBpZiB0aGVyZSB3YXMgYSBwYXRoXG4gICAgLy8gdG8gYmVnaW4gd2l0aCwgdGhlbiB3ZSBNVVNUIGhhdmUgYSBwYXRoLlxuICAgIC8vIGlmIGl0IGlzIGZpbGU6LCB0aGVuIHRoZSBob3N0IGlzIGRyb3BwZWQsXG4gICAgLy8gYmVjYXVzZSB0aGF0J3Mga25vd24gdG8gYmUgaG9zdGxlc3MuXG4gICAgLy8gYW55dGhpbmcgZWxzZSBpcyBhc3N1bWVkIHRvIGJlIGFic29sdXRlLlxuICAgIGlmICghc2xhc2hlZFByb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgICBmb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgICAgICAgdmFyIGsgPSBrZXlzW3ZdO1xuICAgICAgICByZXN1bHRba10gPSByZWxhdGl2ZVtrXTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICByZXN1bHQucHJvdG9jb2wgPSByZWxhdGl2ZS5wcm90b2NvbDtcbiAgICBpZiAoIXJlbGF0aXZlLmhvc3QgJiYgIWhvc3RsZXNzUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIgcmVsUGF0aCA9IChyZWxhdGl2ZS5wYXRobmFtZSB8fCAnJykuc3BsaXQoJy8nKTtcbiAgICAgIHdoaWxlIChyZWxQYXRoLmxlbmd0aCAmJiAhKHJlbGF0aXZlLmhvc3QgPSByZWxQYXRoLnNoaWZ0KCkpKTtcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdCkgcmVsYXRpdmUuaG9zdCA9ICcnO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0bmFtZSkgcmVsYXRpdmUuaG9zdG5hbWUgPSAnJztcbiAgICAgIGlmIChyZWxQYXRoWzBdICE9PSAnJykgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIGlmIChyZWxQYXRoLmxlbmd0aCA8IDIpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxQYXRoLmpvaW4oJy8nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsYXRpdmUucGF0aG5hbWU7XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgcmVzdWx0Lmhvc3QgPSByZWxhdGl2ZS5ob3N0IHx8ICcnO1xuICAgIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0O1xuICAgIHJlc3VsdC5wb3J0ID0gcmVsYXRpdmUucG9ydDtcbiAgICAvLyB0byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQucGF0aG5hbWUgfHwgcmVzdWx0LnNlYXJjaCkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucGF0aG5hbWUgfHwgJyc7XG4gICAgICB2YXIgcyA9IHJlc3VsdC5zZWFyY2ggfHwgJyc7XG4gICAgICByZXN1bHQucGF0aCA9IHAgKyBzO1xuICAgIH1cbiAgICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHZhciBpc1NvdXJjZUFicyA9IChyZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSxcbiAgICAgIGlzUmVsQWJzID0gKFxuICAgICAgICAgIHJlbGF0aXZlLmhvc3QgfHxcbiAgICAgICAgICByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJ1xuICAgICAgKSxcbiAgICAgIG11c3RFbmRBYnMgPSAoaXNSZWxBYnMgfHwgaXNTb3VyY2VBYnMgfHxcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5ob3N0ICYmIHJlbGF0aXZlLnBhdGhuYW1lKSksXG4gICAgICByZW1vdmVBbGxEb3RzID0gbXVzdEVuZEFicyxcbiAgICAgIHNyY1BhdGggPSByZXN1bHQucGF0aG5hbWUgJiYgcmVzdWx0LnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICByZWxQYXRoID0gcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHBzeWNob3RpYyA9IHJlc3VsdC5wcm90b2NvbCAmJiAhc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF07XG5cbiAgLy8gaWYgdGhlIHVybCBpcyBhIG5vbi1zbGFzaGVkIHVybCwgdGhlbiByZWxhdGl2ZVxuICAvLyBsaW5rcyBsaWtlIC4uLy4uIHNob3VsZCBiZSBhYmxlXG4gIC8vIHRvIGNyYXdsIHVwIHRvIHRoZSBob3N0bmFtZSwgYXMgd2VsbC4gIFRoaXMgaXMgc3RyYW5nZS5cbiAgLy8gcmVzdWx0LnByb3RvY29sIGhhcyBhbHJlYWR5IGJlZW4gc2V0IGJ5IG5vdy5cbiAgLy8gTGF0ZXIgb24sIHB1dCB0aGUgZmlyc3QgcGF0aCBwYXJ0IGludG8gdGhlIGhvc3QgZmllbGQuXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAnJztcbiAgICByZXN1bHQucG9ydCA9IG51bGw7XG4gICAgaWYgKHJlc3VsdC5ob3N0KSB7XG4gICAgICBpZiAoc3JjUGF0aFswXSA9PT0gJycpIHNyY1BhdGhbMF0gPSByZXN1bHQuaG9zdDtcbiAgICAgIGVsc2Ugc3JjUGF0aC51bnNoaWZ0KHJlc3VsdC5ob3N0KTtcbiAgICB9XG4gICAgcmVzdWx0Lmhvc3QgPSAnJztcbiAgICBpZiAocmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAgIHJlbGF0aXZlLmhvc3RuYW1lID0gbnVsbDtcbiAgICAgIHJlbGF0aXZlLnBvcnQgPSBudWxsO1xuICAgICAgaWYgKHJlbGF0aXZlLmhvc3QpIHtcbiAgICAgICAgaWYgKHJlbFBhdGhbMF0gPT09ICcnKSByZWxQYXRoWzBdID0gcmVsYXRpdmUuaG9zdDtcbiAgICAgICAgZWxzZSByZWxQYXRoLnVuc2hpZnQocmVsYXRpdmUuaG9zdCk7XG4gICAgICB9XG4gICAgICByZWxhdGl2ZS5ob3N0ID0gbnVsbDtcbiAgICB9XG4gICAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgJiYgKHJlbFBhdGhbMF0gPT09ICcnIHx8IHNyY1BhdGhbMF0gPT09ICcnKTtcbiAgfVxuXG4gIGlmIChpc1JlbEFicykge1xuICAgIC8vIGl0J3MgYWJzb2x1dGUuXG4gICAgcmVzdWx0Lmhvc3QgPSAocmVsYXRpdmUuaG9zdCB8fCByZWxhdGl2ZS5ob3N0ID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdCA6IHJlc3VsdC5ob3N0O1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IChyZWxhdGl2ZS5ob3N0bmFtZSB8fCByZWxhdGl2ZS5ob3N0bmFtZSA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0bmFtZSA6IHJlc3VsdC5ob3N0bmFtZTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHNyY1BhdGggPSByZWxQYXRoO1xuICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0aGUgZG90LWhhbmRsaW5nIGJlbG93LlxuICB9IGVsc2UgaWYgKHJlbFBhdGgubGVuZ3RoKSB7XG4gICAgLy8gaXQncyByZWxhdGl2ZVxuICAgIC8vIHRocm93IGF3YXkgdGhlIGV4aXN0aW5nIGZpbGUsIGFuZCB0YWtlIHRoZSBuZXcgcGF0aCBpbnN0ZWFkLlxuICAgIGlmICghc3JjUGF0aCkgc3JjUGF0aCA9IFtdO1xuICAgIHNyY1BhdGgucG9wKCk7XG4gICAgc3JjUGF0aCA9IHNyY1BhdGguY29uY2F0KHJlbFBhdGgpO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOdWxsT3JVbmRlZmluZWQocmVsYXRpdmUuc2VhcmNoKSkge1xuICAgIC8vIGp1c3QgcHVsbCBvdXQgdGhlIHNlYXJjaC5cbiAgICAvLyBsaWtlIGhyZWY9Jz9mb28nLlxuICAgIC8vIFB1dCB0aGlzIGFmdGVyIHRoZSBvdGhlciB0d28gY2FzZXMgYmVjYXVzZSBpdCBzaW1wbGlmaWVzIHRoZSBib29sZWFuc1xuICAgIGlmIChwc3ljaG90aWMpIHtcbiAgICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gc3JjUGF0aC5zaGlmdCgpO1xuICAgICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgLy8gbm8gcGF0aCBhdCBhbGwuICBlYXN5LlxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgaGFuZGxlZCB0aGUgb3RoZXIgc3R1ZmYgYWJvdmUuXG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gJy8nICsgcmVzdWx0LnNlYXJjaDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaWYgYSB1cmwgRU5EcyBpbiAuIG9yIC4uLCB0aGVuIGl0IG11c3QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIC8vIGhvd2V2ZXIsIGlmIGl0IGVuZHMgaW4gYW55dGhpbmcgZWxzZSBub24tc2xhc2h5LFxuICAvLyB0aGVuIGl0IG11c3QgTk9UIGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICB2YXIgbGFzdCA9IHNyY1BhdGguc2xpY2UoLTEpWzBdO1xuICB2YXIgaGFzVHJhaWxpbmdTbGFzaCA9IChcbiAgICAgIChyZXN1bHQuaG9zdCB8fCByZWxhdGl2ZS5ob3N0IHx8IHNyY1BhdGgubGVuZ3RoID4gMSkgJiZcbiAgICAgIChsYXN0ID09PSAnLicgfHwgbGFzdCA9PT0gJy4uJykgfHwgbGFzdCA9PT0gJycpO1xuXG4gIC8vIHN0cmlwIHNpbmdsZSBkb3RzLCByZXNvbHZlIGRvdWJsZSBkb3RzIHRvIHBhcmVudCBkaXJcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHNyY1BhdGgubGVuZ3RoOyBpID49IDA7IGktLSkge1xuICAgIGxhc3QgPSBzcmNQYXRoW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAobGFzdCA9PT0gJy4uJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmICghbXVzdEVuZEFicyAmJiAhcmVtb3ZlQWxsRG90cykge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgc3JjUGF0aC51bnNoaWZ0KCcuLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtdXN0RW5kQWJzICYmIHNyY1BhdGhbMF0gIT09ICcnICYmXG4gICAgICAoIXNyY1BhdGhbMF0gfHwgc3JjUGF0aFswXS5jaGFyQXQoMCkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKGhhc1RyYWlsaW5nU2xhc2ggJiYgKHNyY1BhdGguam9pbignLycpLnN1YnN0cigtMSkgIT09ICcvJykpIHtcbiAgICBzcmNQYXRoLnB1c2goJycpO1xuICB9XG5cbiAgdmFyIGlzQWJzb2x1dGUgPSBzcmNQYXRoWzBdID09PSAnJyB8fFxuICAgICAgKHNyY1BhdGhbMF0gJiYgc3JjUGF0aFswXS5jaGFyQXQoMCkgPT09ICcvJyk7XG5cbiAgLy8gcHV0IHRoZSBob3N0IGJhY2tcbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlc3VsdC5ob3N0ID0gaXNBYnNvbHV0ZSA/ICcnIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNyY1BhdGgubGVuZ3RoID8gc3JjUGF0aC5zaGlmdCgpIDogJyc7XG4gICAgLy9vY2NhdGlvbmFseSB0aGUgYXV0aCBjYW4gZ2V0IHN0dWNrIG9ubHkgaW4gaG9zdFxuICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgdmFyIGF1dGhJbkhvc3QgPSByZXN1bHQuaG9zdCAmJiByZXN1bHQuaG9zdC5pbmRleE9mKCdAJykgPiAwID9cbiAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgcmVzdWx0LmF1dGggPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICB9XG4gIH1cblxuICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyB8fCAocmVzdWx0Lmhvc3QgJiYgc3JjUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChtdXN0RW5kQWJzICYmICFpc0Fic29sdXRlKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQucGF0aG5hbWUgPSBzcmNQYXRoLmpvaW4oJy8nKTtcbiAgfVxuXG4gIC8vdG8gc3VwcG9ydCByZXF1ZXN0Lmh0dHBcbiAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocmVzdWx0LnNlYXJjaCA/IHJlc3VsdC5zZWFyY2ggOiAnJyk7XG4gIH1cbiAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoIHx8IHJlc3VsdC5hdXRoO1xuICByZXN1bHQuc2xhc2hlcyA9IHJlc3VsdC5zbGFzaGVzIHx8IHJlbGF0aXZlLnNsYXNoZXM7XG4gIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuVXJsLnByb3RvdHlwZS5wYXJzZUhvc3QgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGhvc3QgPSB0aGlzLmhvc3Q7XG4gIHZhciBwb3J0ID0gcG9ydFBhdHRlcm4uZXhlYyhob3N0KTtcbiAgaWYgKHBvcnQpIHtcbiAgICBwb3J0ID0gcG9ydFswXTtcbiAgICBpZiAocG9ydCAhPT0gJzonKSB7XG4gICAgICB0aGlzLnBvcnQgPSBwb3J0LnN1YnN0cigxKTtcbiAgICB9XG4gICAgaG9zdCA9IGhvc3Quc3Vic3RyKDAsIGhvc3QubGVuZ3RoIC0gcG9ydC5sZW5ndGgpO1xuICB9XG4gIGlmIChob3N0KSB0aGlzLmhvc3RuYW1lID0gaG9zdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc1N0cmluZzogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnc3RyaW5nJztcbiAgfSxcbiAgaXNPYmplY3Q6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xuICB9LFxuICBpc051bGw6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbE9yVW5kZWZpbmVkOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09IG51bGw7XG4gIH1cbn07XG4iLCJcbi8qKlxuICogRm9yIE5vZGUuanMsIHNpbXBseSByZS1leHBvcnQgdGhlIGNvcmUgYHV0aWwuZGVwcmVjYXRlYCBmdW5jdGlvbi5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ3V0aWwnKS5kZXByZWNhdGU7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZiAoIW1vZHVsZS53ZWJwYWNrUG9seWZpbGwpIHtcblx0XHRtb2R1bGUuZGVwcmVjYXRlID0gZnVuY3Rpb24oKSB7fTtcblx0XHRtb2R1bGUucGF0aHMgPSBbXTtcblx0XHQvLyBtb2R1bGUucGFyZW50ID0gdW5kZWZpbmVkIGJ5IGRlZmF1bHRcblx0XHRpZiAoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG4iXSwic291cmNlUm9vdCI6IiJ9